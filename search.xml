<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JSOI冬令营D2 题]]></title>
    <url>%2F2019%2F01%2F28%2FJSOI%E5%86%AC%E4%BB%A4%E8%90%A5D2-%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这场比赛真是不难啊不难，但是我还是只会写暴力啊暴力~~~ T1 箱子 T2 准备 T3 回忆 T1 箱子考试时想了各种方法，什么dp、网络流、数据结构，总觉得昨天那么难，今天不可能只出一道贪心。结果谁知道，就是一道极水极水的小贪心。 $a \le b$ 的那部分显然按照a递增排序。 $a &gt; b$ 的部分按b递减排序。证明如下：假设$ b_x &gt; b_y $若x排在y的前面不合法，也就是$ sumV+b_x-a_x &lt; a_y $则易得$ sumV + b_y - a_y &lt; a_x $也就是说y排在x的前面也一定不合法。所以x排在前面一定不会更差。因此把b较大的x排在前面。 my代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;int read() &#123; int res = 0, f = 1; char c = getchar(); while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar(); if(c == '-') f = -1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + c - '0', c = getchar(); return f * res; &#125;int n;long long v;struct P&#123; int a, b; &#125;p[N];bool cmp(P x, P y) &#123; if(x.a &lt; x.b) if(y.a &lt; y.b) return x.a &lt; y.a; else return 1; else if(y.a &lt;= y.b) return 0; else return x.b &gt; y.b;&#125;int main() &#123; freopen("a.in", "r", stdin); freopen("a.out", "w", stdout); int T; T = read(); while(T--) &#123; n = read(); v = read(); int flag = 0; for(int i = 1; i &lt;= n; i++) p[i].a = read(), p[i].b = read(); sort(p + 1, p + 1 + n, cmp); for(int i = 1; i &lt;= n; i++) &#123; if(v - p[i].a &lt; 0) &#123; flag = 1; break; &#125; v -= p[i].a; v += p[i].b; &#125; if(flag) printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; T2 准备事实上这题我在考场上想到正解了，只是最后没有调出来而已。后来发现有一个地方写错了一个字母。唉~。 考虑用一定计算过的答案得到下一次的答案，也就是维护。容易看出，只要知道每一次有多少个负数就可以$ O(1) $转移了。 而每一次有多少个负数实际上是内定了的，也就是根据$ a[i] $可以预处理出来。考虑每个$ a[i] $对他的贡献，也就是这个a何时会变成负的。所有这样的时刻都是区间，可以用差分实现。 代码实现时要注意差分的位置，我第一也在这个地方晕了。其他没有什么难的。关键注意从不同角度思考问题吧。 my代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4000020, inf = 0x3f3f3f3f;typedef long long ll;ll read() &#123; ll res = 0, f = 1; char c = getchar(); while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar(); if(c == '-') f = -1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + c - '0', c = getchar(); return f * res; &#125;ll a[N+N], n, ans = 1e16;ll s[N+N], b[N+N], res;int main() &#123; freopen("b.in", "r", stdin); freopen("b.out", "w", stdout); n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); for(int i = 1; i &lt;= n; i++) if(a[i] &lt; i) s[1]++, s[i+1-a[i]]--; for(int i = 1; i &lt;= n; i++) s[i+1]++, s[i + n - a[i] + 1]--; for(int i = 1; i &lt;= n; i++) b[i] = b[i-1] + s[i];// for(int i = 1; i &lt;= n; i++) cout &lt;&lt; b[i] &lt;&lt; ' '; cout &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) res += abs(a[i] - i); ans = min(ans, res); for(int i = 2; i &lt;= n; i++) &#123; res -= b[i-1]; res += n - b[i-1]; res -= a[i-1]; res += abs(a[i-1] - n); ans = min(ans, res); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; T3 回忆其实我考试时也想到用线段树维护了，但但但，没有想到只要单点修改就可以。 我感觉这题就巧妙在这里，我们很容易想到用两个线段树分别维护$ l[i] - r[i] $和$ l[i] + r[i] $，但在哪些点上维护？有在哪个区间查询？ 我们按l从小到大处理每个区间，把每个已处理过的区间的右端点在线段树上单点更新。查询时，不包含情况是查询$ [l,r] $，包含的情况查询$ [r, +\infty] $，这真巧妙，非常棒地区分了两种情况，还十分简洁。以后要记住这种方法。 细节部分脑补一下就可以了，别忘了离散化。 my代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010, inf = 1e9;int read() &#123; int res = 0, f = 1; char c = getchar(); while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar(); if(c == '-') f = -1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + c - '0', c = getchar(); return f * res; &#125;int n, ans, refl[N+N], num;struct intv&#123; int l, r; &#125;p[N];bool cmp(intv x, intv y) &#123; return x.l == y.l ? x.r &gt; y.r : x.l &lt; y.l; &#125;int tr1[N*40], tr2[N*40];void build(int *tr, int p, int l, int r) &#123; tr[p] = inf; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(tr, p*2, l, mid); build(tr, p*2+1, mid + 1, r);&#125;void change(int *tr, int p, int l, int r, int pos, int x) &#123; tr[p] = min(tr[p], x); if(l == r) return; int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) change(tr, p*2, l, mid, pos, x); if(pos &gt; mid) change(tr, p*2+1, mid + 1, r, pos, x);&#125;int query(int *tr, int p, int l, int r, int L, int R) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return tr[p]; int mid = (l + r) &gt;&gt; 1, res = inf; if(L &lt;= mid) res = min(res, query(tr, p*2, l, mid, L, R)); if(R &gt; mid) res = min(res, query(tr, p*2+1, mid + 1, r, L, R)); return res;&#125;int main() &#123; freopen("c.in", "r", stdin); freopen("c.out", "w", stdout); n = read(); int tmp; for(int i = 1; i &lt;= n; i++) p[i].l = read(), p[i].r = read(), refl[++num] = p[i].l, refl[++num] = p[i].r; sort(p + 1, p + 1 + n, cmp); sort(refl + 1, refl + 1 + num); num = unique(refl + 1, refl + 1 + num) - refl - 1; for(int i = 1; i &lt;= n; i++) p[i].l = lower_bound(refl + 1, refl + 1 + num, p[i].l) - refl, p[i].r = lower_bound(refl + 1, refl + 1 + num, p[i].r) - refl; build(tr1, 1, 1, num); build(tr2, 1, 1, num); for(int i = 1; i &lt;= n; i++) &#123; tmp = query(tr1, 1, 1, num, p[i].l, p[i].r); ans = max(ans, refl[p[i].r] + refl[p[i].l] - tmp); tmp = query(tr2, 1, 1, num, p[i].r, num); ans = max(ans, refl[p[i].l] - refl[p[i].r] - tmp); change(tr1, 1, 1, num, p[i].r, refl[p[i].l] + refl[p[i].r]); change(tr2, 1, 1, num, p[i].r, refl[p[i].l] - refl[p[i].r]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 明天再接再厉，不信做不出来水题。]]></content>
      <categories>
        <category>集训</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSOI冬令营D1 题]]></title>
    <url>%2F2019%2F01%2F28%2FJSOI%E5%86%AC%E4%BB%A4%E8%90%A5D1-%E9%A2%98%2F</url>
    <content type="text"><![CDATA[T1 小L的占卜 T2 小F的星术 T3 小X的咒语 T1 小L的占卜首先发现，T = 1时，问的就是区间异或和，因为偶数个数的异或和为0，剩下的只是奇数了。 当T = 2时，可以求出区间内所有出现过的数的异或和（每种数只算一次），然后异或掉区间异或和就可以了。那么考虑怎么每种数只算一次。考虑离线操作。把所有的操作按照左端点排序。先把每种数第一次出现的位置在树状数组上使能（也就是异或这个位置的数），然后从前往后扫描每一个询问，L向后推移，把L之前的数在树状数组上的贡献去掉，同时使能它下一次出现的位置。查询R的前缀异或和就可以了。 听说这是一个很套路的方法，但我真不会套路啊，学习了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;int read() &#123; int res = 0, f = 0; char c = getchar(); while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar(); if(c == '-') f = 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + c - '0', c = getchar(); return f ? -res : res; &#125;int n, m, s[N], a[N], tmp[N], c[N], ans[N], p[N], num, na[N];int nxt[N], v[N];void add(int p) &#123; if(!p) return; for(int x = p; p &lt;= n; p += p&amp;-p) c[p] ^= a[x];&#125;int query(int p) &#123; int res = 0; for(; p; p -= p&amp;-p) res ^= c[p]; return res;&#125;struct Q&#123; int i, l, r, t; &#125;q[N];bool cmp(Q x, Q y) &#123; return x.l &lt; y.l; &#125;int main() &#123; freopen("augury.in", "r", stdin); freopen("augury.out", "w", stdout); int kase; kase = read(); n = read(), m = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(), p[++num] = a[i]; sort(p + 1, p + 1 + num); num = unique(p + 1, p + 1 + num) - p - 1; for(int i = 1; i &lt;= n; i++) na[i] = lower_bound(p + 1, p + 1 + num, a[i]) - p; for(int i = 1; i &lt;= n; i++) s[i] = s[i-1] ^ a[i]; for(int i = 1; i &lt;= m; i++) q[i].l = read(), q[i].r = read(), q[i].t = read(), q[i].i = i; sort(q + 1, q + 1 + m, cmp); for(int i = 1; i &lt;= n; i++) &#123; if(!v[na[i]]) add(i), v[na[i]] = i; else nxt[v[na[i]]] = i, v[na[i]] = i; &#125; int ll = 1; for(int i = 1; i &lt;= m; i++) &#123; while(ll &lt; q[i].l) add(ll), add(nxt[ll]), ll++; ans[q[i].i] = s[q[i].r] ^ s[q[i].l - 1]; if(q[i].t == 1) ans[q[i].i] ^= query(q[i].r); &#125; for(int i = 1; i &lt;= m; i++) printf("%d\n", ans[i]); return 0;&#125; T2 小F的星术数学期望 + 树形dp，我们都知道，但怎么做呢，我连链的情况都没写出来~。 要先想到$$E(x) = P(x\ge 1) + P(x\ge 2) + P(x\ge 3) + …$$其中x为正整数。 也就是说，我们只要求出找到K条不相交路径的方案数，把他们加起来，在乘以$ \frac{n(n+1)}2 $的逆元就可以了。 这个和第二天讲的一道树形dp题一样。用$ dp[i][j][0/1/2] $表示以i为根的子树，j条路径，i不取、i取且路径未结束、i取且路径无法向上延伸的方案数。 然后考虑状态转移，假设我们当前处于pos节点的儿子x处，dp[pos]记录的是x之前的信息，我们要把x的信息也合并进去。分类讨论。 这里情况比较繁琐，我看了很久才看懂标程，就不重新写一遍了，直接贴标程如下，转移写的很清楚:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 5005;const int P = 998244353;typedef long long ll;typedef long double ld;typedef unsigned long long ull;template &lt;typename T&gt; void chkmax(T &amp;x, T y) &#123;x = max(x, y); &#125;template &lt;typename T&gt; void chkmin(T &amp;x, T y) &#123;x = min(x, y); &#125; template &lt;typename T&gt; void read(T &amp;x) &#123; x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = -f; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; x *= f;&#125;template &lt;typename T&gt; void write(T x) &#123; if (x &lt; 0) x = -x, putchar('-'); if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;template &lt;typename T&gt; void writeln(T x) &#123; write(x); puts("");&#125;int n, sz[MAXN], dp[MAXN][MAXN][3];vector &lt;int&gt; a[MAXN];void update(int &amp;x, int y) &#123; x += y; if (x &gt;= P) x -= P;&#125;void work(int pos, int fa) &#123; sz[pos] = 1; dp[pos][1][0] = dp[pos][0][2] = 1; for (auto x : a[pos]) if (x != fa) &#123; work(x, pos); static int res[MAXN][3]; for (int i = 1; i &lt;= sz[pos] + sz[x]; i++) res[i][0] = res[i][1] = res[i][2] = 0; for (int i = 0; i &lt;= sz[pos]; i++) for (int j = 0; j &lt;= sz[x]; j++) &#123; update(res[i + j][0], 1ll * dp[pos][i][0] * dp[x][j][0] % P); if (i + j) update(res[i + j - 1][1], 1ll * dp[pos][i][0] * dp[x][j][0] % P); update(res[i + j][0], 1ll * dp[pos][i][0] * dp[x][j][1] % P); if (i + j) update(res[i + j - 1][1], 1ll * dp[pos][i][0] * dp[x][j][1] % P); update(res[i + j][0], 1ll * dp[pos][i][0] * dp[x][j][2] % P); update(res[i + j][1], 1ll * dp[pos][i][1] * dp[x][j][0] % P); if (i + j) update(res[i + j - 1][2], 1ll * dp[pos][i][1] * dp[x][j][0] % P); update(res[i + j][1], 1ll * dp[pos][i][1] * dp[x][j][1] % P); if (i + j) update(res[i + j - 1][2], 1ll * dp[pos][i][1] * dp[x][j][1] % P); update(res[i + j][1], 1ll * dp[pos][i][1] * dp[x][j][2] % P); update(res[i + j][2], 1ll * dp[pos][i][2] * dp[x][j][0] % P); update(res[i + j][2], 1ll * dp[pos][i][2] * dp[x][j][1] % P); update(res[i + j][2], 1ll * dp[pos][i][2] * dp[x][j][2] % P); &#125; for (int i = 1; i &lt;= sz[pos] + sz[x]; i++) &#123; dp[pos][i][0] = res[i][0]; dp[pos][i][1] = res[i][1]; dp[pos][i][2] = res[i][2]; &#125; sz[pos] += sz[x]; &#125;&#125;int power(int x, int y) &#123; if (y == 0) return 1; int tmp = power(x, y / 2); if (y % 2 == 0) return 1ll * tmp * tmp % P; else return 1ll * tmp * tmp % P * x % P;&#125;int main() &#123; freopen("astrology.in", "r", stdin); freopen("astrology.out", "w", stdout); int num; read(num); read(n); for (int i = 1; i &lt;= n - 1; i++) &#123; int x, y; read(x), read(y); a[x].push_back(y); a[y].push_back(x); &#125; work(1, 0); int ans = 1, tot = ((dp[1][1][1] + dp[1][1][2]) % P + dp[1][1][0]) % P; int fac = 1, frac = 1; for (int i = 1; i &lt;= n; i++) &#123; fac = 1ll * fac * i % P; frac = 1ll * frac * tot % P; int now = ((dp[1][i][1] + dp[1][i][2]) % P + dp[1][i][0]) % P; update(ans, 1ll * now * fac % P * power(frac, P - 2) % P); &#125; writeln(ans); return 0;&#125; T3 小X的咒语组合数学毒瘤题，推公式，要能够清晰地运用容斥原理，很难了。 my proud code:1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 510;ll c[N][N], fac[N+N], rev[N], p, n, ans;int main() &#123; freopen("abracadabra.in", "r", stdin); freopen("abracadabra.out", "w", stdout); int kase; scanf("%d", &amp;kase); scanf("%lld%lld", &amp;n, &amp;p); fac[0] = 1; for(int i = 1; i &lt;= n + n; i++) fac[i] = fac[i-1] * i % p; for(int i = 0; i &lt;= n; i++) c[i][0] = 1; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) c[i][j] = (c[i-1][j-1] + c[i-1][j]) % p; rev[0] = 1; rev[1] = (p + 1) / 2; for(int i = 2; i &lt;= n; i++) rev[i] = rev[i-1] * rev[1] % p; for(int j = 0; j &lt;= n; j++) for(int k = 0; k + j &lt;= n; k++) for(int i = 0; i + j + k &lt;= n; i++) &#123; ll tmp = c[n][j] * c[n-j][k] % p * c[n-j-k][i] % p * c[j+k][j] % p * rev[j+k] % p * rev[k] % p * fac[j] % p * fac[2*k+i] % p; if((i + j) % 2 == 0) ans = (ans + tmp) % p; else ans = (ans + tmp * (p-1) % p) % p; // cout &lt;&lt; ans &lt;&lt; endl; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>集训</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>组合数学</tag>
        <tag>树形动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSOI冬令营D2 课]]></title>
    <url>%2F2019%2F01%2F28%2FJSOI%E5%86%AC%E4%BB%A4%E8%90%A5D2-%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[树形动态规划一些关于树和dp的题，比较有难度，请谨慎 给定一个图G，求两点之间最短距离的最大值G是普通图G是树G是基环树 基环树情况：先不考虑环，每一棵树求一个到根的最长路径。这棵树就没用了。然后把环拆成链，单调队列维护dp就可以。 给定一棵树T，求k条不想交的路径的方案数（点构成的路径） k = 2：考虑树上的一条链有一个lca，这两条链的lca会有一个lca。如果他们位于大lca的不同子树，则求出每个子树的大小，答案贡献为$\sum_{u\not =v}C_{u+1}^2C_{v+1}^2$其中u、v为两棵子树，但这样需要$ O(n^2) $枚举，太慢了，变形为$(\sum_uC_{u+1}^2)^2-\sum_u(C_{u+1}^2)^2$这样就可以$ O(n) $了如果大lca就是其中一点，枚举另一点位置，另外一条链在这棵树剩下部分（也就是砍掉那棵子树），用组合数算就可以了。 k 任意用$dp[i][j][0/1/2]$表示以i为根的子树，j条链，i取且其链继续向上扩展、i取但这条链已结束、i不取的方案数。树形+背包dp状态转移尚未搞懂，回头再说 给定一棵数，求最小点覆盖 $ dp[i][0/1] $表示以i为根子树，i去或不取的最小点覆盖。$ dp[i][0] = \sum_{fa[j] = i}dp[j][1] $$ dp[i][1] = \sum_{fa[j] = i}max(dp[j][0], dp[j][1]) $ 给定一棵树T，求所有简单路径边权积的和取模SPOJ MTREE $ f[i] $表示从i往下的链积的和。可以维护出来$ f[i] $然后枚举lca，求出$ \sum_{x\not=y}f[x] w_x f[y] * w[y] $，x、y为lca的子树，化简同上。 给定一个树T，在T上寻找两条严格不想交的路径，使其长度之积最大，求这个积。SPOJ TWOPATHS 分两种情况 一条路径就是直径，另一条是其他路径中最大的 两条路径都只包含直径的一部分，枚举直径上相邻的两个点即可 给定一棵树T，在T上先去掉一条边，再加上一条树边，重新构成一棵树T’，要使T’的直径最小，求一种方案。SPOJ treecst 加边时一定是加在两棵树直径的中点上。从根开始dfs枚举砍掉的边，维护两个直径，更新答案。 给定一棵树T，以及起点X终点Y，T上每一个节点都以给定的概率向其相邻的节点走，允许重复经过同一个点，求从X到Y的期望步数。SPOJ GS 以Y为根。令$ f[i] $表示从i走到i的父亲的期望步数，$ p_i $表示i走向父亲的概率，$ p_{ij} $表示i走向第j个儿子的概率。$ f[i] = p_i * 1 + \sum_{j=1}^kp_{ij}(1+f[son[i][j]] + f[i]) $ ，其中k为i的子树个数。这事实上是一个方程，$ f[i] $为未知数，其他都是已求或已知的常量。手动求解即可。 给定一棵树或者基环树，以相等的概率选择一个起点，每一步等概率地走向未经过得点，求期望的移动步数PS:给定的基环树中，环长不超过20NOI2012 Day2 T1 迷失游乐园 $ up[i] $表示从i向上走的期望步数。$ down[i] $表示从i向下走的期望步数。一遍dfs可以求出down，再一遍求出up，树的情况解决了。 基环树时，先对每个数向上面一样求down。预处理出$ p[i][j][0/1] $表示从i顺/逆时针到j的概率。之后dfs统计up，计算答案。 给定一棵带权无根树T，先选一点作为树根，然后每一步操作可以任选一点u，将树边$ (u,fa(u)), (fa(u), fa(fa(u))) $一起覆盖。同时，所有操作要满足，每条树边只被覆盖至多一次，求所有被覆盖的树边总长度的最大值。APIO2014 T3 连珠线 $ dp[i][0/1] $表示以i为根的子树，i是不是中间点，最大被覆盖边权任选一个根，$ O(n) $求出所有dp值然后考虑换根，选当前根的一个儿子作为新的根，对dp数组进行维护，可以$ O(1) $做到，多记录一些信息，和之前的转移是一样的。取最大值即可。]]></content>
      <categories>
        <category>集训</category>
      </categories>
      <tags>
        <tag>基环树</tag>
        <tag>树上乱搞</tag>
        <tag>树形动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学整理集锦]]></title>
    <url>%2F2019%2F01%2F23%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[排列的生成 按字典序思想生成下一个排列 排列和组合的计数 基本组合恒等式 两种特殊的排列组合技术公式 Catalan数 公式 应用 操练 Bell数 Stirling数 多重集的排列组合 多重集的排列 多重集的组合 容斥原理与鸽笼原理 鸽笼原理 容斥原理 计算并集元素个数 计算错排的方案数 Ramsey定理 Ramsey数 波利亚定理 定义们 Bornside引理 波利亚定理 递推与生成函数 k阶常系数线性齐次递推关系 生成函数 排列的生成按字典序思想生成下一个排列设当前序列为$ (p) = p_1p_2p_3…p_n $，按字典序思想生成下一个排列方法如下： 从右向左，计算最后一个増序的尾元素的下标i，即$ i = max{j\ |\ p_{j-1} &lt; p_j,\ p_j \ge p_{j+1} } $ 从右向左找到$p_{i-1}$后面比$p_{i-1}$大的最后一个元素的下标j，即$j = max{ k\ |\ k \ge i,\ p_{i-1} &lt; p_k }$ 交换$p_{i-1}$与$p_j$，得到$p_1…p_{i-2}p_jp_ip_{i+1}…p_{j-1}p_{i-1}p_{j+1}…p_n$ 翻转新的$p_j$后面的元素，使其递增（也就是说原来是递减的），得到$p_1…p_{i-2}p_jp_n…p_{j+1}p_{i-1}p_{j-1}…p_{i+1}p_i$ 原理想想就明白啦，下面有一道题： POJ1146 ID Codes 就是一道很裸的题，直接来代码：12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;using namespace std;char str[100];int len;int main() &#123; while(scanf("%s", str) &amp;&amp; strcmp(str, "#")) &#123; len = strlen(str); bool flag = 0; for(int i = len - 1; i; i--) &#123; if(str[i-1] &lt; str[i]) &#123; for(int j = len - 1; j &gt;= i; j--) if(str[i-1] &lt; str[j]) &#123; swap(str[i-1], str[j]); break; &#125; for(int j = i; j &lt;= len - (j - i + 1); j++) swap(str[j], str[len - (j - i + 1)]); puts(str); flag = 1; break; &#125; &#125; if(!flag) puts("No Successor"); &#125; return 0;&#125; 再说一句，要注意看清楚流程中的大于号和大于等于号，另外就是当找不到时代表已经找完了，这就是最后一个，算法结束。 排列和组合的计数基本组合恒等式$$\sum_{i=0}^{n} {n \choose i} = 2 ^ n $$$$ \sum_{i=0}^{n} {i \choose x} = {n+1 \choose x+1} $$$$ \sum_{i=0}^{n} {k+i \choose i} = {k+n+1 \choose n} $$$$ \sum_{i=0}^{m} {m \choose i} {n-m \choose m-i} = {n \choose m}$$ 两种特殊的排列组合技术公式Catalan数公式 Catalan数是序列｛C｝，其中 $ C_0=1,\ C_1=1,$$$C_n = C_0C_{n-1}+C_1C_{n-2}+…+C_{n-1}C_0,\ n\ge2. $$ 在定义中就已经给出了它最一般的递推式，下面还有几个计算是很常用的： 变形递推式$$ C_n = \frac{4n-2}{n+1}\times C_{n-1}, n &gt; 1 $$ 通项公式$$ C_n = \frac{C(2n, n)}{n+1}, n = 0, 1, 2… $$$$C_n=C(2n,n)-C(2n,n+1),n=0,1,2…$$ 酌情使用，方便为上要注意卡特兰数的下标从0开始，不要随意改，会出现意想不到的问题。 应用 由n个1和n个0构成2n项满足所有前缀中1比0多的序列个数等于第n个Catalan数。证明：我们先求出所有的序列，然后减去不合法的序列即是答案。所有序列个数直接根据组合数的定义为$C(n,2n)$，现在要证明满足存在一个结论中所说的序列与n+1个0与n-1个1构成的01序列构成一个双射，即11对应关系，因为很显然，后者的数量为$C(n−1,2n)$。对前者，很显然可以找到一个位置为$2p+1$的前缀，使得其中有$p+1$个1和$p$个0，好的我们把它取反，即得到了后者。对后者，同理。于是得到了上述第二个通项公式。&emsp; 我们可以将应用1变换形式：将1看成右括号，0看成左括号，就变成了左括号和右括号各有n个时，合法括号表达式的个数。比如2个左括号和2个右括号组成的合法表达式有种，是()()和(())。&emsp; n个节点构造二叉树的所有可能形态数为$C_n$。考虑随便取一个节点作为根，那么他左边和右边的儿子节点个数就确定了，假定根节点标号为x，那么左子树的标号就是从1到x-1,共x-1个，右子树的标号就是从x+1到n，共n-x个，那么将x从1取到n，就获得了所有的情况数。得到的为定义递推式。&emsp; n个非叶节点的满二叉树的形态数（对称后得到的二叉树除非自己本身对称，否则算是不同）。对于满二叉树，实际上就是将应用4中的每个子节点的空儿子上都加上叶子，就形成了对应的满二叉树，那么n个非叶节点形成的满二叉树的形态数即为$C_n$&emsp; 对于一个n*n的正方形网格，每次只能向右或者向上移动一格，那么从左下角到右上角所有在副对角线右下方的路径总数为$C_n$。可以将一条水平边记为+1,垂直边记为-1,那么就组成了一个n个+1和n个-1的序列，并且保证前k步中水平边数不小于垂直边数，换句话说前k个元素的和非负。&emsp; 对凸n+2边形进行不同的三角形分割（只连接顶点对形成n个三角形）数为$C_n$&emsp; n个数入栈后的出栈的排列总数是$C_n$。例如1,2,3入栈的出栈排序有123，132，213，231和321五种&emsp; n层的阶梯切割为n个矩形的切法数也是。如下图所示：考虑先绘制如下图片，即n为5的时候的阶梯：注意到每个切割出来的矩形都必需包括一块标示为*的小正方形，那么此时枚举每个*与#标示的两角作为矩形，剩下的两个小阶梯就是我们的两个更小的子问题了。 &emsp;事实上，从应用中我们也可以看到很多证明通项公式的方法。 操练给道题目吧： BZOJ2822: [AHOI2012]树屋阶梯 卡特兰数+高精度，比较裸，代码如下：12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 10000;int n, a[100000];void mul(int a[], int x)&#123; int &amp;l = a[0]; int left = 0; for(int i = 1; i &lt;= l; i++)&#123; a[i] = a[i] * x + left; left = a[i] / mod; a[i] = a[i] % mod; &#125; while(left) a[++l] = left % mod, left /= mod;&#125;void div(int a[], int x)&#123; int &amp;l = a[0]; int left = 0; for(int i = l; i; i--)&#123; a[i] += left * mod; left = a[i] % x; a[i] /= x; &#125; while(!a[l]) l--;&#125;void print(int a[])&#123; int l = a[0]; printf("%d", a[l]); for(int i = l - 1; i; i--) printf("%04d", a[i]); cout &lt;&lt; endl;&#125;int main()&#123; cin &gt;&gt; n; a[0] = a[1] = 1; for(int i = n + 1; i &lt;= 2 * n; i++) mul(a, i); for(int i = 1; i &lt;= n; i++) div(a, i); div(a, n + 1); print(a); return 0;&#125; Bell数 Bell数是集合的划分数，也是一个集合上的等价关系的数目；Bell数{B}, 其中$B_n$是包含n个元素的集合的划分方法的数目。显然，$B_0=1, B_1=1, B_2=2, B_3=5$$$B_{n+1} = \sum_{k=0}^nC(n, k)B_k $$ 很简单吧 Stirling数 第一类Stirling数是将n个不同元素放入m个环排列的数目。其中，$S(n, 0)=0,\ S(1,1)=1$$$S(n, m) = S(n-1, k-1) + (n-1)*S(n-1, m)$$ 生成函数:$$\begin{aligned}&amp; x^{\overline{n}} = \sum_{i=0}^{n} \begin{bmatrix} n \ i \end{bmatrix} x^i \&amp; x^{\underline{n}}= \sum_{i=0}^{n} (-1)^{n-i} \begin{bmatrix} n \ i \end{bmatrix} x^i\end{aligned}$$ 第二类Stirling数是将n个元素的集合划分为k个不为空的子集的方式的个数，其中$S(n, n) = S(n, 1) = 1 $$$S(n, m) = S(n-1, m-1) + k * S(n-1, m) $$ 生成函数: $$\begin{aligned}&amp; x^n = \sum_{i=0}^{n} {n \brace i} x^{\underline{i}} \&amp; m!{n \brace m} = \sum_{i=0}^{m} (-1)^{m-i} {m \choose i} i^n\end{aligned}$$ 多重集的排列组合 多重集是可重复出现的元素组成的集合。若多重集中不同元素个数为k，称该多重集为k元多重集。多重集中元素$a_i$出现的次数$n_i$称为元素$ai$的重数。若有限多重集S有$a_1, a_2, …, a_k$共k个不同元素，且ai的重数为ni，则S可记为：${ n_1•a_1, n_2•a_2, ……, n_k•a_k }$。 多重集的排列 设有限多重集$S={ n_1•a_1, n_2•a_2, …, n_k•a_k }$，且$n=n_1+n_2+ ……+n_k$，从S中有序选取r个元素称为S的一个r-排列$(r\le|S|=n)$，当$r=n$时，称为S的一个全排列。 从k元多重集$S= { \infty•a_1, \infty•a_2, …, \infty•a_k }$中有序选取r个元素我们也称为S的一个r-排列。 设k元多重集$S= { \infty•a_1, \infty•a_2, …, \infty•a_k }$，则S的r-排列数是$k^r$。 证明太简单，不写了。 多重集的组合 设多重集$S={ n_1•a_1, n_2•a_2, ……, n_k•a_k }$，（这里$n_i$可以是有限也可以是无限的）。S的含有r个元素的子多重集称为S的r-组合。 设k元多重集$S= { \infty•a_1, \infty•a_2, …, \infty•a_k }$，设$r\le n_i(\forall i \in [1, k])$则S的r-组合数是$$C_{k+r-1}^r$$ 证明：原问题等价于统计下列集合的数量：$ { x_1\cdot a_1, x_2\cdot a_2,…,x_k\cdot a_k } $，其中，$ \sum_{i=1}^k x_i = r $并且$x_i\le n_i$，故原问题等价于r个0，k-1个1构成的全排列数——k-1个1把r个0分成k组，每组的0的数量对应$x_i$。而多重集${ r\cdot 0, (k-1)\cdot 1 }$的全排列数为$$ \frac{(r+k-1)!}{r!(k-1)!} = C_{k+r-1}^r = C_{k+r-1}^{k-1} $$ 对于更为一般的r的情况，需要用到下面的容斥原理，之后再说，敬请期待。 容斥原理与鸽笼原理鸽笼原理 应用鸽笼原理解题的一般步骤： 分析题意，分清什么是“元素”，什么是“集合”；也就是说，什么可以作为“元素”，什么可以作为“集合”。 构造集合。这是关键的一步。根据题目条件和结论，结合有关的数学知识，抓住最基本的数量关系，设计和确定解决问题所需的集合及其个数，为应用鸽笼原理奠定基础。应用鸽笼原理解题。 有一道题目，比较巧妙，巧妙在思路上，代码并不复杂 POJ2356 Find a multiple 鸽笼原理主要还是在于能不能想得到，解决的题目往往令人惊叹，比如这一题，结合起算法中常用的前缀和，就非常非常巧妙。还是要灵活运用啊。 容斥原理 定义就是这样，开启我们的练习吧—— 计算并集元素个数 Ural 1091 Tmutarakan Exams (这是vjudge上的网址哦) AC代码：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int k, s, p[60];long long ans, c[60][60];bool judge(int x)&#123; for(int i = 2; i &lt;= s; i++) if(x % i == 0 &amp;&amp; !p[i] &amp;&amp; !p[x / i] &amp;&amp; i != x / i) return true; return false;&#125;int main() &#123; scanf("%d%d", &amp;k, &amp;s); for(int i = 0; i &lt;= s; i++) c[i][0] = 1; for(int i = 1; i &lt;= s; i++) for(int j = 1; j &lt;= k; j++) c[i][j] = c[i-1][j-1] + c[i-1][j]; p[0] = p[1] = 1; for(int i = 2; i &lt;= s; i++) if(!p[i]) for(int j = i + i; j &lt;= s; j += i) p[j] = 1; for(int i = 2; i &lt;= s; i++) &#123; if(!p[i]) &#123; ans += c[(s - i) / i + 1][k]; &#125; else if(judge(i)) ans -= c[(s - i) / i + 1][k]; &#125; cout &lt;&lt; min(ans, (long long)10000) &lt;&lt; endl; return 0;&#125; 下面是一道难一点的 ZOJ3638 Fruit Ninja 下面是我的不知为何没有AC的代码，segment falt，但样例至少是可以过得，一般这种时候我就认为它对了，总之贴出来吧（不过话说这题的输入格式好恶心啊）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 100000007;typedef long long ll;int n, m, gr, le[20], cnt, num[1 &lt;&lt; 20];ll c[10000100][20], ans;string str;char s[1000], tmp1[1000], ty[1000], tmp2[1000];int main() &#123; int x; for(int i = 1; i &lt; (1 &lt;&lt; 17); i++) for(int j = i; j; j -= j&amp;-j) num[i]++; for(int i = 0; i &lt;= 1e7+20; i++) c[i][0] = 1; for(int i = 1; i &lt;= 1e7+20; i++) for(int j = 1; j &lt;= 18; j++) c[i][j] = (c[i-1][j-1] + c[i-1][j]) % mod; while(scanf("%d%d", &amp;n, &amp;m) == 2 &amp;&amp; (n || m != 1)) &#123; ans = gr = cnt = 0; /*getchar(); while(1) &#123; getline(cin, str); strcpy(s, str.c_str()); if(!strcmp(s, "")) break; sscanf(s, "%s%s%s%d", tmp1, ty, tmp2, &amp;x); if(ty[0] == 'g') gr += x + 1; else if(ty[0] == 'l') le[cnt++] = x; &#125;*/ gets(s); while(1)&#123; if(!gets(s)) break; if(strlen(s) &lt; 2) break; sscanf(s,"%s %s %s %d",tmp1,ty,tmp2,&amp;x); if(ty[0] == 'g') gr += x + 1; else le[cnt++] = x; &#125; for(int i = 0; i &lt; (1 &lt;&lt; cnt); i++) &#123; int cur = 0; for(int j = 0; j &lt; cnt; j++) if(i &amp; (1 &lt;&lt; j)) cur += le[j]; if(n + m - gr - cur - 1 &gt;= 0) ans = (ans + 1ll * (num[i] % 2 == 0 ? 1 : -1) * c[n + m - gr - cur - 1][n - 1] % mod) % mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; &emsp;还记得在上面讲多重集的时候说，r任意的情况要使用容斥原理讨论吗，事实上，上一题已经利用了这一方法。这里再系统讲一下。 设多重集$ $。对于任意整数$ $，从S中取出r个元素组成一个多重集(不考虑顺序)，产生的不同的多重集的数量为$$ C_{k+r-1}^{k-1}- \sum_{i=1}^kC_{k+r-n_i-2}^{k-1} + \sum_{1\le i &lt; j \le k}C_{k+r-n_i-n_j-3}^{k-1} - …+(-1)^kC_{k+r-\sum_{i=1}^kn_i-(k+1)}^{k-1}$$ 证明：不考虑$n_i$的限制，从S中任选r个元素，相当于上一节讨论过的情况，方法数为$C_{k+r-1}^{k-1}$。设$S_i(1\le i\le k)$表示至少包含$n_i+1$个$a_i$的多重集。我们先从S中取出$n_i+1$个$a_i$，然后在任选$r-n_i-1$个元素，即可构成$S_i$。与上面同理，可以构成的不同的$S_i$的数量为$C_{k+r-n_i-2}^{k-1}$进一步地，先从S中取出$n_i+1$个$a_i$和$n_j+1$个$a_j$，然后在任选$r-n_i-n_j-2$个元素，即可构成$S_i\cap S_j$，方法数为$C_{k+r-n_i-n_j-3}^{k-1}$。根据容斥原理，至少有一种$a_i$选取的数量超过$n_i$限制的多重集共有：$$ \begin{vmatrix} \bigcup_{i=1}^kS_i\end{vmatrix} = \sum_{i=1}^kC_{k+r-n_i-2}^{k-1} - \sum_{1\le i &lt; j \le k}C_{k+r-n_i-n_j-3}^{k-1} + …-(-1)^kC_{k+r-\sum_{i=1}^kn_i-(k+1)}^{k-1} $$故所有满足限制的合法多重集个数即为上述结论。证毕。&emsp;总结一下：从上面的应用也可以发现，使用容斥原理时常常使用补集转换思想，先求出题目所要求的补集，它往往是很多子集的并集，可以用容斥原理轻松解决。在这个过程中，“至少”，“有”，“存在”等字眼应相当重视，往往涉及到思路是否清晰。 计算错排的方案数 递推法:设n个元素$a_1, a_2, …, a_n$，错排数目为$D_n$。任取其中一个元素，错排产生有两种情况：情况1：$a_i$与其它$n-1$个元素之一互换，其余$n-2$个元素错排。根据乘法原理，共产生$(n-1) D_{n-2}$个错排；情况2：$a_i$以外的$n-1$个元素先错排，然后$a——i$与其中每个元素互换。根据乘法原理，共产生$(n-1) D_{n-1}$个错排；使用加法原理综合上述情况，可得出递推式：$D_1=0；D_2=1；D_n=(n-1)(D_{n-2}+ D_{n-1})$，其中$n&gt;2$。注意：当$n$较大时，错排数可能会超过任何整数类型允许的范围。在这种情况下一般采用高精度运算，以避免数据溢出。 依旧一道水题练练手 UVA10497 Sweet Child Makes Trouble 错排裸题+高精，水题不解释，代码：123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;long long f[810][10010], n;int main() &#123; f[0][0] = 1; for(int i = 2; i &lt;= 800; i++) &#123; int x = 0; for(int j = 0; j &lt;= 10000; j++) f[i][j] += f[i-1][j] + f[i-2][j], f[i][j+1] += f[i][j] / 10000, f[i][j] %= 10000; for(int j = 0; j &lt;= 10000; j++) f[i][j] *= i - 1, f[i][j] += x, x = f[i][j] / 10000, f[i][j] %= 10000; &#125; while(scanf("%lld", &amp;n) == 1 &amp;&amp; n != -1) &#123; int i = 10000; while(!f[n][i] &amp;&amp; i) i--; printf("%lld", f[n][i--]); while(i &gt;= 0) printf("%04lld", f[n][i--]); printf("\n"); &#125; return 0;&#125; Ramsey定理 对于任何一个具有6个节点的简单图，要么它包含一个三角形，要么它的补图包含一个三角形。 证明：设6个节点的简单图为G。考察G中的任意一个节点a，那么，另外5个节点中的任何一个节点，要么在G中与a邻接，要么在G’（G的补图）中与a邻接。这样，就可以把5个节点分成两类：在G中与a邻接，或在G’中与a邻接。因此，根据鸽笼原理，必有一类至少含有3个节点，不妨假设其中的3个节点b, c, d与a邻接。如果b, c, d间有边相连，则命题成立；否则在补图中b, c, d任意两点间有边相连，命题成立。 Ramsey定理 6个人中至少存在3人相互认识或者相互不认识。 Ramsey数 对于正整数a和b，对应于一个整数r，使得r个人中或有a个人相互认识，或有b个人互不认识；或有a个人互不认识，或有b个人相互认识。这个数r的最小值用R(a, b)来表示。R(3, 3)=6。Ramsey数还有若干推论：R(3, 4)=9，R(4, 4)=18。 Ramsey数有如下性质。$R(a, b)= R(b, a)；R(a, 2)=2$。对任意的整数$a, b \ge 2$，$R(a, b)$存在。对任意的整数$a, b，R(a, b)\le R(a-1, b)+ R(a, b-1)$；如果$a, b \ge 2，且R(a-1, b)$和$R(a, b-1)$是偶数，则$$R(a, b)\le R(a-1, b)+ R(a, b-1)-1。R(a, b)\le C(a+b-2, a-1)。$$ 波利亚定理终于写到这了，首先要介绍群论： 定义们群的定义 一个群是一个集合G和一个在集合G上被称为G的群法则的操作，这一操作将任意两个元素a和b合成为一个新元素，标志为a * b或ab。(G, *)满足下述4个条件。[1] 封闭性；对于任意$a, b\in G，ab\in G$。[2] 结合律；对于任意$a, b, c\in G，(ab)c = a(bc)$。[3] 存在单位元素；在G中存在一个元素e，使得对于任意$a\in G，ea = ae = a$。[4] 存在逆元素；对于任意$a\in G$，在G中存在元素$b$，使得$ab = b*a = e$，其中$e$是单位元素。 置换的定义： 设集合A由n个不同元素$a_1, a_2, …, a_n$组成。A中的元素之间的一个置换是$a_1$被A中的某个元素$b_1$所取代，$a_2$被A中的某个元素$b_2$所取代，…，$a_n$ 被A中的某个元素$b_n$；并且$b_1, b_2, …, b_n$互不相同。 置换群： 一个置换群是一个群(G, *)，其元素是${a_1, a_2, ……, a_n}$的置换，而*是置换的合成。也就是说，置换群的元素是置换，操作是置换的合成。Pólya计数公式基于置换群。 例如，{1, 2, 3, 4}的所有置换$S_4＝{(1)(2)(3)(4), (12), (13), (14), (23), (24), (34),$$ (123), (124), (132), (134), (142), (143), (234), (243), $$(1234), (1243), (1324), (1342), (1423), (1432), $$(12)(34), (13)(24), (14)(23)}$。 在$S_4$中，具有相同格式的置换所示如下：$(1)^0(2)^2(3)^0(4)^0$，也就是$(2)^2$，有3个置换：$(12)(34)，(13)(24)$和$(14)(23)$；$(1)^1(3)^1$有8个置换：$(123)，(124)，(132)，(134)，(142)，(143)，(234)$和$(243)$；$(1)^2(2)^1$有6个置换：$(12)，(13)，(14)，(23)，(24)$和$(34)$；$(1)^4$只有1个置换：$(1)(2)(3)(4)$；$(4)^1$有6个置换：$(1234)，(1243)，(1324)，(1342)，(1423)$和$(1432)$。 共轭类以及其计算定理： K不动置换类： 设$K$是${1, 2, …, n}$中的一个数。$G$中使$K$保持不变的置换全体，记为$Z_K$，叫做$G$中使$K$不动的置换类，或简称K不动置换类。 例如，$G={e, (1 2), (3 4), (1 2)(3 4)}。Z_1={e, (3 4)}；Z_2={e, (3 4)}；Z_3={e, (1 2)}；Z_4＝{e, (1 2)}。e$是单位元。显然，$Z_K$是$G$的子群，$K$是${1, 2, 3, 4}$中的一个数。对于$G$，在这一置换下，1可以置换为2，2可以置换为1；3可以置换为4，4可以置换为3。但1或2不可能置换为3或4，而且3或4也不可能置换为1或2。所以，1和2在一个等价类中，3和4在另一个等价类中。 等价类： 设G是${1, 2, …, n}$的置换群，K是${1, 2, …, n}$中的一个数。在这一置换下，${1, 2, …, n}$可以被划分为若干等价类，K所属的等价类记为$E_K$。 例如，$G={e, (1 2), (3 4), (1 2)(3 4)}$。1和2在一个等价类中，3和4在另一个等价类中。$E_1=E_2={1, 2}，E_3=E_4={3, 4}$。因此，对于数$K，1\le K\le 4$，置换群G有对应的等价类$E_K$和不动置换类$Z_K$。 长舒一口气，终于介绍完定义了。下面，最关键部分来了。 Bornside引理一个小结论，但很重要： 设G是${1, 2, …, n}$的置换群，K是${1, 2, …, n}$中的一个数，则$|E_K|*|Z_K| = |G|$。 例如，$G={e, (1 2), (3 4), (1 2) (3 4)}$；$E_1=E_2={1, 2}，E_3=E_4={3, 4}$;$|E_1|=|E_2|=|E_3|=|E_4|=2$；$Z_1＝Z_2＝{e, (3 4)}，Z_3＝Z_4＝{e, (1 2)}$；$ |Z_1|=|Z_2|=|Z_3|=|Z_4|=2$。则$|E_1|* |Z_1|=|E_2|* |Z_2|=|E_3|* |Z_3|=|E_4|*|Z_4|=4=|G|$ 设$G={\alpha_1, \alpha_2, …, \alpha_m}$是一个在${1, 2, …, n}$上的置换群，其中$\alpha_1=e$；$\alpha_k$可以被记为一个若干循环节的乘积，$c_1(\alpha_k)$是置换$\alpha_k$中1阶循环节的个数，$k=1, 2, …, m$。 要到一个小高潮了 可以利用上面的结论进行证明：不妨设$ N={ 1, 2, …n } $中共有$L$个等价类，$ N=E_1+E_2+…+E_n $$$\sum_{k=1}^n|Z_k| = \sum_{i=1}^L\sum_{k\in E_i}|Z_k| = \sum_{i=1}^L|E_i|\cdot |Z_i| = L\cdot |G|$$L就是我们要求的等价类数，于是，$$L = \frac{1}{|G|}\sum_{k=1}^n|Z_k| = \frac{1}{|G|}\sum_{j=1}^s|C(\alpha_j)|$$ 下面，最主要的部分，波利亚定理，闪亮登场 波利亚定理 可以做题了 POJ 1286 Necklace of Beads code:12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;long long ans[30], n;int gcd(int x, int y) &#123; if(!y) return x; return gcd(y, x % y);&#125;long long pow(int x, int y) &#123; long long res = 1; for(int i = 1; i &lt;= y; i++) res *= x; return res;&#125;int main() &#123; for(n = 1; n &lt;= 25; n++) &#123; for(int i = 1; i &lt;= n; i++) ans[n] += pow(3, gcd(i, n)); if(n % 2 == 1) ans[n] += pow(3, n / 2 + 1) * n; else ans[n] += pow(3, n / 2) * n / 2 + pow(3, n / 2 + 1) * n / 2; ans[n] /= 2 * n; &#125; while(scanf("%lld", &amp;n) == 1 &amp;&amp; n != -1) printf("%d\n", ans[n]); return 0;&#125; 递推与生成函数k阶常系数线性齐次递推关系$ h_n-a_ih_{n-1}-a_2h_{n-2}-…-a_kh_{n-k} = 0 $ … …(1)求解形如$ q^n $的解，得q是下面方程的根（需要同时约去$ q^{n-k} $）$ x^b-a_1x^{k-1}-a_2x^{k-2}-…-a_{k-1}x-a_k = 0 $ … …(2)称(2)为(1)的特征方程（耳熟）称(2)的k个根为(1)的特征根 若$ p\not=q $是(1)的特征根，则$ c_1p^n+c_2q^n $是(1)的解若$q$是(2)的重根，则$ nq^n $是(1)的解 求解$ c_1, c_2 $时可以有已知的几项列方程组求解可以证明一定只要有k个不一样的根，方程(1)一定有解。(使用范德蒙矩阵)。 也就是说，最后一定会有k个特征根（可以相同），通项里就一定有k项（可以合并），分别为每个特征根的n次方。（这是我提炼出来的，意思差不多~） 举例：对于递推关系$ h_n - 5h_{n-1} + 6h_{n-2}，h_1 = 4, h_2 = 5 $，求通项。解：通项一定形如$ h_n = c_1\cdot 2^n + c_2\cdot 3^n $列方程求出$ c_1, c_2 $，做完了。 一般情况（跟我想的一样）：对于线性常系数齐次递推关系$ h_n + a_1h_{n-1} + a_2h_{n-2} + … + a_kh_{n-k} = 0$它的k个特征根为$ q_1, q_2, …, q_k $，它们的重数为$ r_1, r_2, …, r_k $，且$ r_1 + r_2 + .. + r_k = k $那么，通项为$ h_n = c_1r_1q_1^n + c_2r_2q_2^n + … + c_kr_kq_k^n $$ c_1, c_2, …, c_k $为常数，可以由已知的前几项解出来。完美。 叠加原理：设$ x_1, x_2, …, x_k $满足递推关系$ h_n + a_1h_{n-1} + … + a_kh_{n-k} = f(n) $$ y_1, y_2, …, y_k $满足递推关系$ h_n + a_1h_{n-1} + … + a_kh_{n-k} = g(n) $则$ x_1+y_1, x_2+y_2, …, x_k+y_k $满足递推关系$ h_n + a_1h_{n-1} + … + a_kh_{n-k} = f(n) + g(n) $一个重要的应用，有他可知(1)的通解 + (2)的特解 = (2)的通解这样可以求带有常数项的通项公式了，例如$h_n = 2h_{n-1} + 1$ （汉诺塔步数）$ h_n - 2h_{n-1} = 0 $ … …(1)$ h_n - 2h_{n-1} = 1 $ … …(2)(1)的通解可以轻松求出为$ h_n = 2^n $(2)有特解-1因此(2)通解为$ h_n = 2^n - 1 $ 特解求法定理:（未完）待定系数法吧 转移矩阵与递推关系有相同的特征多项式（转移矩阵就是矩阵优化里那个搭配快速幂的东西） 生成函数数列$ h_1, h_2, h_3, … $对应的生成函数定义为$ g(x) = h_0 + h_1x + h_2x^2 + h_3x^3 … $有限数列$ h_n $可补零变成无限 例：无限序列$ h_n = 1 $的生成函数是$ g(x) = 1 + x + x^2 + x^3 + … $在$ |x|&lt;1 $时，上式为$ g(x) = \frac{1}{1-x} $ $$ \frac{1}{1-x} = 1 + x + x^2 + x^3 + … \ \frac{1}{(1-x)^2} = 1 + 2x + 3x^2 + … \\frac{1}{(1-x)^k} = \sum_{n=0}^{+\infty}C_{k+n-1}^{k-1}x^n \e^x = 1 + \frac{x}{1!} + \frac{x^2}{2!} + \frac{x^2}{3!} $$ 多重集组合可以使用生成函数 例：2个1袋的苹果无限，5个1提的香蕉无限，4个散橘子，1个梨子，求从中组合出n个水果的方案数解：$ h_n = (\sum_{a=0}^{+\infty}x^{2a})\cdot (\sum_{b=0}^{+\infty}x^{5b})\cdot (\sum_{c=0}^4x^c)\cdot (\sum_{d=0}^1x^c) \ = (1 + x^2 + x^4 + …)(1 + x^5 + x^{10} + …)(1 + x + x^2 + x^3 + x^4)(1 + x) \ = \frac{1}{1-x^2}\cdot \frac{1}{1-x^5}\cdot (1+x+x^2+x^3+x^4)(1+x) \ = \frac{1}{(1-x)(1+x)}\cdot\frac{1}{(1+x+x^2+x^3+x^4)(1-x)}\cdot(1+x+x^2+x^3+x^4)\cdot(1+x)\ = \frac{1}{(1-x)^2} $的n次项系数答案为$ n + 1 $ 泰勒展开公式$ f(x) = f(0) + \frac{f’(0)}{1!}x + \frac{f’’(0)}{2!}x^2 + \frac{f’’’(0)}{3!}x^3 + … $哇喔 求卷积：求卷积利用生成函数具有天然的优势原数列生成函数的平方做多项式乘法，$x^n$前的系数，就是n的卷积]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>波利亚定理</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1001 狼抓兔子]]></title>
    <url>%2F2019%2F01%2F22%2FBZOJ1001-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ1001 Description现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：左上角点为(1,1),右下角点为(N,M)(上图中N=4,M=5).有以下三种类型的道路1:(x,y)&lt;\==&gt;(x+1,y)2:(x,y)&lt;\==&gt;(x,y+1)3:(x,y)&lt;\==&gt;(x+1,y+1)道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的. 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角(1,1)的窝里，现在它们要跑到右下解(N,M)的窝中去，狼王开始伏击这些兔子.当然为了保险起见，如果一条道路上最多通过的兔子数为K，狼王需要安排同样数量的K只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦. Input第一行为N,M.表示网格的大小，N,M均小于等于1000.接下来分三部分第一部分共N行，每行M-1个数，表示横向道路的权值.第二部分共N-1行，每行M个数，表示纵向道路的权值.第三部分共N-1行，每行M-1个数，表示斜向道路的权值.输入文件保证不超过10M Output输出一个整数，表示参与伏击的狼的最小数量. Sample Input3 45 6 44 3 17 5 35 6 7 88 7 6 55 5 56 6 6 Sample Output14 Solution解法一：网络流很容易想到题目让求的就是最小割，利用最小割最大流定理，就是一道求最大流的裸题。说几点Dinic的注意点： tot初始化为1 当发现一条路无法增光时，将d数组设为0，表示该点不可能继续增广，可以大大提速 路径是双向边，再加上反向边，总共是4条边 模板尽可能背的准一点吧，我默写的时候出来很多小问题 解法二：耦合图这个解法就巧妙多了。 Code解法一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010, inf = 0x3f3f3f3f;int n, m, head[N*N], ver[N*N*12], Next[N*N*12], edge[N*N*12], tot = 1, d[N*N], maxflow, f, s, t;queue&lt;int&gt; q;void add(int x, int y, int z) &#123; ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot; ver[++tot] = x, edge[tot] = z, Next[tot] = head[y], head[y] = tot;&#125;bool bfs() &#123; while(q.size()) q.pop(); memset(d, 0, sizeof(d)); d[s] = 1; q.push(s); while(q.size()) &#123; int x = q.front(); q.pop(); for(int i = head[x]; i; i = Next[i]) if(edge[i] &amp;&amp; !d[ver[i]]) &#123; d[ver[i]] = d[x] + 1; q.push(ver[i]); if(ver[i] == t) return true; &#125; &#125; return false;&#125;int dinic(int x, int flow) &#123; if(x == t) return flow; int k, rest = flow; for(int i = head[x]; i &amp;&amp; rest; i = Next[i]) if(edge[i] &amp;&amp; d[ver[i]] == d[x] + 1) &#123; k = dinic(ver[i], min(rest, edge[i])); if(!k) d[ver[i]] = 0; rest -= k; edge[i] -= k; edge[i ^ 1] += k; &#125; return flow - rest;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); int z; s = 1, t = n * m; for(int i = 0; i &lt; n; i++) for(int j = 1; j &lt; m; j++) scanf("%d", &amp;z), add(i*m+j, i*m+j+1, z), add(i*m+j+1, i*m+j, 0); for(int i = 0; i &lt; n - 1; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;z), add(i*m+j, i*m+m+j, z), add(i*m+m+j, i*m+j, 0); for(int i = 0; i &lt; n - 1; i++) for(int j = 1; j &lt; m; j++) scanf("%d", &amp;z), add(i*m+j, i*m+m+j+1, z), add(i*m+m+j+1, i*m+j, 0); while(bfs()) while(f = dinic(s, inf)) maxflow += f; cout &lt;&lt; maxflow &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流-最大流</tag>
        <tag>耦合图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2434 阿狸的打字机]]></title>
    <url>%2F2019%2F01%2F22%2FBZOJ2434-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ2434 Description 阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有28个按键，分别印有26个小写英文字母和’B’、’P’两个字母。经阿狸研究发现，这个打字机是这样工作的：输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。按一下印有’B’的按键，打字机凹槽中最后一个字母会消失。按一下印有’P’的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。例如，阿狸输入aPaPBbP，纸上被打印的字符如下：aaaab我们把纸上打印出来的字符串从1开始顺序编号，一直到n。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数(x,y)（其中1≤x,y≤n），打字机会显示第x个打印的字符串在第y个打印的字符串中出现了多少次。阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？ Input输入的第一行包含一个字符串，按阿狸的输入顺序给出所有阿狸输入的字符。第二行包含一个整数m，表示询问个数。接下来m行描述所有由小键盘输入的询问。其中第i行包含两个整数x, y，表示第i个询问为(x, y)。 Output 输出m行，其中第i行包含一个整数，表示第i个询问的答案。 Sample InputaPaPBbP31 21 32 3 Sample Output210 HINT对于100%的数据，n&lt;=100000,m&lt;=100000,第一行总长度&lt;=100000。 Solution40分做法第一想法，AC自动机，记录每个字符串以及它们在Trie上的哪个节点结束，直接匹配（好暴力啊）。事实上，这种做法，仅仅是记录所有的字符串都会超时超内存，都轮不到匹配的事。但可以作为一个模板题写写嘛。 100分做法这道题作为一道NOI题，非常巧妙地运用了AC自动机的一系列扩展性质。我们考虑构建自动机之后做了什么，无非是在fail数组上跳来跳去来寻找匹配。而每一个节点有唯一的fail节点，这让我们联想到一棵新的树，“fail树”，它以fail数组为边。于是，惊喜地发现，要想出现字符串x，就要出现在x的尾节点在“fail树”上的子树中。要发现，若字符串x在字符串y中出现，则y所在Trie的节点会出现在x对应在“fail树”上的子树中，出现的次数即为匹配数因此，题目就转化为，搞出AC自动机，搞出“fail树”，求出x的子树，求出y在Trie上的链，回答他们有多少公共节点。但如果对于每个询问都这样求一边，依旧是40分，因此我们考虑一起计算。这里在代码实现上比较巧妙。子树可以用dfs序变成区间问题，而对于链，我们可以只用一遍dfs，进入一个节点时把他+1，出来时-1， Code40分代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;char str[N];int n, m, ch[N][30], pos[N], nxt[N], tot = 1, s[N], tail;vector&lt;int&gt; dic[N];void insert() &#123; int cur = 1; for(int i = 1; i &lt;= tail; i++) &#123; if(!ch[cur][s[i]]) ch[cur][s[i]] = ++tot; cur = ch[cur][s[i]]; &#125; pos[++n] = cur; for(int i = 1; i &lt;= tail; i++) dic[n].push_back(s[i]);&#125;void bfs() &#123; for(int i = 1; i &lt;= 26; i++) ch[0][i] = 1; queue&lt;int&gt; q; q.push(1); nxt[1] = 0; while(q.size()) &#123; int x = q.front(); q.pop(); for(int i = 1; i &lt;= 26; i++) &#123; if(!ch[x][i]) ch[x][i] = ch[nxt[x]][i]; else q.push(ch[x][i]), nxt[ch[x][i]] = ch[nxt[x]][i]; &#125; &#125;&#125;int find(int pa, int son) &#123; int cur = 1, res = 0; for(int i = 0; i &lt; dic[pa].size(); i++) &#123; int c = dic[pa][i], k = ch[cur][c]; while(k &gt; 1) &#123; res += pos[son] == k; k = nxt[k]; &#125; cur = ch[cur][c]; &#125; return res;&#125;int main()&#123; scanf("%s", str); int len = strlen(str); for(int i = 0; i &lt; len; i++) &#123; if(str[i] == 'P') insert(); else if(str[i] == 'B' &amp;&amp; tail) tail--; else s[++tail] = str[i] - 'a' + 1; &#125; bfs(); scanf("%d", &amp;m); while(m--)&#123; int x, y; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", find(y, x)); &#125; return 0;&#125; 100分代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010;char str[N];int n, m, ch[N][30], fa[N], nxt[N], tot = 1, ans[N], ch1[N][30];int pos[N], bel[N];vector&lt;int&gt; dic[N];int head[N], ver[N+N], Next[N+N], edgetot;int fir[N], sec[N], nod[N+N], pool;void add(int x, int y) &#123; ver[++edgetot] = y, Next[edgetot] = head[x], head[x] = edgetot;&#125;struct Q&#123; int i, x, y; &#125;q[N];int ql[N], qr[N];bool cmp(Q a, Q b) &#123; return a.y &lt; b.y; &#125;int c[N+N];void pplus(int p, int x) &#123; for(; p &lt;= pool; p += p&amp;-p) c[p] += x;&#125;int query(int p) &#123; int res = 0; for(; p; p -= p&amp;-p) res += c[p]; return res;&#125;void bfs() &#123; for(int i = 1; i &lt;= 26; i++) ch[0][i] = 1; queue&lt;int&gt; q; q.push(1); nxt[1] = 0; while(q.size()) &#123; int x = q.front(); q.pop(); for(int i = 1; i &lt;= 26; i++) &#123; if(!ch[x][i]) ch[x][i] = ch[nxt[x]][i]; else &#123; q.push(ch[x][i]); nxt[ch[x][i]] = ch[nxt[x]][i]; add(ch[x][i], ch[nxt[x]][i]); add(ch[nxt[x]][i], ch[x][i]); &#125; &#125; &#125;&#125;void getdfn(int x, int f) &#123; fir[x] = ++pool; nod[pool] = x; for(int i = head[x]; i; i = Next[i]) if(ver[i] != f) getdfn(ver[i], x); sec[x] = ++pool; nod[pool] = x;&#125;void dfs(int x) &#123; pplus(fir[x], 1); if(bel[x] &amp;&amp; ql[bel[x]]) &#123; for(int i = ql[bel[x]]; i &lt;= qr[bel[x]]; i++) ans[q[i].i] = query(sec[pos[q[i].x]]) - query(fir[pos[q[i].x]] - 1); &#125; for(int i = 1; i &lt;= 26; i++) if(ch1[x][i]) dfs(ch1[x][i]); pplus(fir[x], -1);&#125;int main()&#123; scanf("%s", str); int len = strlen(str); for(int i = 0, u = 1; i &lt; len; i++) &#123; if(str[i] == 'P') bel[u] = ++n, pos[n] = u; else if(str[i] == 'B') u = fa[u]; else &#123; int c = str[i] - 'a' + 1; if(ch[u][c]) u = ch[u][c]; else ch[u][c] = ++tot, fa[ch[u][c]] = u, u = tot; &#125; &#125; memcpy(ch1, ch, sizeof(ch)); bfs(); getdfn(1, 0); scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++) scanf("%d%d", &amp;q[i].x, &amp;q[i].y), q[i].i = i; sort(q + 1, q + 1 + m, cmp); for(int i = 1, pos = 1; i &lt;= m; i = pos) &#123; ql[q[i].y] = i; while(q[i].y == q[pos].y) pos++; qr[q[i].y] = pos - 1; &#125; dfs(1); for(int i = 1; i &lt;= m; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1926 粟粟的书架]]></title>
    <url>%2F2019%2F01%2F22%2FBZOJ1926-%E7%B2%9F%E7%B2%9F%E7%9A%84%E4%B9%A6%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ1926 Description幸福幼儿园B29班的粟粟是一个聪明机灵、乖巧可爱的小朋友，她的爱好是画画和读书，尤其喜欢Thomas H. Cormen的文章。粟粟家中有一个R行C列的巨型书架，书架的每一个位置都摆有一本书，上数第i行、左数第j列摆放的书有Pi,j页厚。 粟粟每天除了读书之外，还有一件必不可少的工作就是摘苹果，她每天必须摘取一个指定的苹果。粟粟家果树上的苹果有的高、有的低，但无论如何凭粟粟自己的个头都难以摘到。不过她发现，如果在脚下放上几本书，就可以够着苹果；她同时注意到，对于第i天指定的那个苹果，只要她脚下放置书的总页数之和不低于Hi，就一定能够摘到。 由于书架内的书过多，父母担心粟粟一天内就把所有书看完而耽误了上幼儿园，于是每天只允许粟粟在一个特定区域内拿书。这个区域是一个矩形，第i天给定区域的左上角是上数第x1i行的左数第y1i本书，右下角是上数第x2i行的左数第y2i本书。换句话说，粟粟在这一天，只能在这﹙x2i－x1i＋1﹚×﹙y2i－y1i＋1﹚本书中挑选若干本垫在脚下，摘取苹果。 粟粟每次取书时都能及时放回原位，并且她的书架不会再撤下书目或换上新书，摘苹果的任务会一直持续M天。给出每本书籍的页数和每天的区域限制及采摘要求，请你告诉粟粟，她每天至少拿取多少本书，就可以摘到当天指定的苹果。 Input第一行是三个正整数R，C，M。接下来是一个R行C列的矩阵，从上到下、从左向右依次给出了每本书的页数Pi，j。接下来M行，第i行给出正整数x1i，y1i，x2i，y2i，Hi，表示第i天的指定区域是﹙x1i，y1i﹚与﹙x2i，y2i﹚间的矩形，总页数之和要求不低于Hi。保证1≤x1i≤x2i≤R，1≤y1i≤y2i≤C。 Output有M行，第i 行回答粟粟在第 i 天时为摘到苹果至少需要 拿取多少本书。如果即使取走所有书都无法摘到苹果，则在该行输出“Poor QLW” （不含引号）。 Sample Input5 5 714 15 9 26 5358 9 7 9 3238 46 26 43 3832 7 9 50 288 41 9 7 171 2 5 3 1393 1 5 5 3993 3 4 5 914 1 4 1 331 3 5 4 1853 3 4 3 233 1 3 3 108 Sample Output6152Poor QLW913 HINT对于 10%的数据，满足 R, C≤10；对于 20%的数据，满足 R, C≤40；对于 50%的数据，满足 R, C≤200，M≤200,000；另有 50%的数据，满足 R＝1，C≤500,000，M≤20,000；对于 100%的数据，满足 1≤Pi,j≤1,000，1≤Hi≤2,000,000,000 Solution前50%的数据注意到P不大于1000，因此可以预处理出与P有关的数组。val[i][j][k]表示(i, j)左上方的子矩阵中大于等于k的数的总和num[i][j][k]表示(i, j)左上方的子矩阵中大于等于k的数的个数然后就可以二分答案了，二分k，求矩阵前缀和，判定一下OK。 后50%的数据沿用前面的二分思路，但预处理时间和空间都会爆。这里可以用比较暴力的方法乱搞，但我们要追求高效嘛。 因此想到前缀和就要想到主席树，可以大大节省时间空间。具体来说，对每个前缀维护一个线段树，节点(l, r)维护两个信息：P处于l、r之间的数的总和…(1)P处于l、r之间的数的个数…(2)(就和上面的前缀和意义一样)。对这个线段树可持久化，得到一棵主席树。查询时，在要求的区间的线段树上用(1)判断左走还是右走，用(2)计算答案。 注意点： 一个区间可能有很多相同的数，只要取其中的一部分，计算得到要取多少，具体看代码。 前缀和左端点-1 递归到头后控制返回 为了防止混淆，我在代码中把两种解法放在不同的命名空间里。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int P = 1010;int r, c, m;namespace easy &#123; const int N = 210; int p[N][N], num[N][N][P], x1, x2, y1, y2; long long val[N][N][P], h; long long calc(int k)&#123; return val[x2][y2][k] - val[x1-1][y2][k] - val[x2][y1-1][k] + val[x1-1][y1-1][k]; &#125; void work() &#123; for(int i = 1; i &lt;= r; i++) for(int j = 1; j &lt;= c; j++) &#123; scanf("%d", &amp;p[i][j]); for(int k = 0; k &lt;= 1000; k++) &#123; val[i][j][k] = val[i-1][j][k] + val[i][j-1][k] - val[i-1][j-1][k]; num[i][j][k] = num[i-1][j][k] + num[i][j-1][k] - num[i-1][j-1][k]; if(k &lt;= p[i][j]) val[i][j][k] += p[i][j], num[i][j][k]++; &#125; &#125; while(m--)&#123; scanf("%d%d%d%d%lld", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;h); int l = 0, r = 1000; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(calc(mid) &gt;= h) l = mid; else r = mid - 1; &#125; if(l == 0) printf("Poor QLW\n"); else printf("%d\n", num[x2][y2][l+1] - num[x1-1][y2][l+1] - num[x2][y1-1][l+1] + num[x1-1][y1-1][l+1] + (h - calc(l+1) + l - 1) / l); //此处要考虑重复的部分到底选几个，肯定是达到要求的前提下选的越少越好 &#125; &#125;&#125;namespace hard &#123; const int N = 500010; int lc[N*32], rc[N*32], num[N*32], p[N], rt[N], tot; long long val[N*32], h; int build(int pre, int l, int r, int x) &#123; int p = ++tot; lc[p] = lc[pre], rc[p] = rc[pre], val[p] = val[pre] + x, num[p] = num[pre] + 1; if(l == r) return p; int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) lc[p] = build(lc[pre], l, mid, x); else rc[p] = build(rc[pre], mid + 1, r, x); return p; &#125; int query(int lp, int rp, int l, int r, int x) &#123; if(l == r) &#123; return (x + l - 1) / l; //这里跟上面一样，要考虑相同的部分。 &#125; int mid = (l + r) &gt;&gt; 1, y = val[rc[rp]] - val[rc[lp]]; if(y &gt;= x) return query(rc[lp], rc[rp], mid + 1, r, x); else return query(lc[lp], lc[rp], l, mid, x - y) + num[rc[rp]] - num[rc[lp]]; &#125; void work() &#123; for(int i = 1; i &lt;= c; i++) scanf("%d", &amp;p[i]), rt[i] = build(rt[i-1], 1, 1000, p[i]); while(m--)&#123; int l, r, t1, t2; scanf("%d%d%d%d%lld", &amp;t1, &amp;l, &amp;t2, &amp;r, &amp;h); int ans = query(rt[l-1], rt[r], 1, 1000, h); if(ans &gt; r - l + 1) printf("Poor QLW\n"); else printf("%d\n", ans); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;r, &amp;c, &amp;m); if(r == 1) hard::work(); else easy::work(); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1070 修车]]></title>
    <url>%2F2019%2F01%2F17%2FBZOJ1070-%E4%BF%AE%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ1070 Description 同一时刻有N位车主带着他们的爱车来到了汽车维修中心。维修中心共有M位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这M位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。 说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。 Input 第一行有两个m,n，表示技术人员数与顾客数。 接下来n行，每行m个整数。第i+1行第j个数表示第j位技术人员维修第i辆车需要用的时间T。 Output 最小平均等待时间，答案精确到小数点后2位。 Sample Input2 23 21 4 Sample Output1.50 HINT数据范围: (2&lt;=M&lt;=9,1&lt;=N&lt;=60), (1&lt;=T&lt;=1000) Solution对于像这样的对应匹配的问题，一般可以使用网络流求解，即构建二分图，大部分时候求最大匹配（当然也不仅是匹配）。本题中一次维修要消耗一定的时间，因此需要使用最小费用最大流。 最原始的思路是，左部工人，右部客户的二部图，但本题的特殊之处在于排在后面的人会有更长的等待时间。我们仍需保持这是一个二分图，因此需要对点或边进行一些调整。 首先，要使用一个重要的思想，考虑每辆车对总等待时间的贡献，即不计算每个顾客等多久，而计算他让别人等了多久 每一个工人一个车一个车的修，每修一辆车会让后面的人多等一会儿。 此时就可以想到拆点。把每一个工人节点k拆成个N点，等同于正在修他将要修的倒数第i辆车，向另外一部j点连边即代表他这个修的是j号车， 费用为$a[j][k]*i$，乘以i是因为后面的i辆车都要等待这个时间。 事实上本题的构图体现了一个阶段化拆点的思想，一个点拆成它的不同阶段，相互独立。 至于二部图的网络流构图法就不累述了，这里说几个注意点： 边编号要从2开始计 不要忘记建反向边，容量0，费用-w 清空数组神马的别忘了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int V = 1010, E = 200010, inf = 0x3f3f3f3f;int n, m, tot = 1, head[V], ver[E], Next[E], cap[E], cost[E], a[20][100];int s, t, pe[V], pv[V], maxflow, mincost, d[V], v[V];void add(int x, int y, int c, int w)&#123; ver[++tot] = y, cap[tot] = c, cost[tot] = w; Next[tot] = head[x], head[x] = tot;&#125;void solve() &#123; queue&lt;int&gt; q; while(1) &#123; memset(v, 0, sizeof(v)); memset(d, 0x3f, sizeof(d)); while(q.size()) q.pop(); q.push(s); d[s] = 0; v[s] = 1; while(q.size()) &#123; int x = q.front(); q.pop(); v[x] = 0; for(int i = head[x]; i; i = Next[i]) if(cap[i]) &#123; int y = ver[i]; if(d[y] &gt; d[x] + cost[i]) &#123; d[y] = d[x] + cost[i]; pv[y] = x; pe[y] = i; if(!v[y]) v[y] = 1, q.push(y); &#125; &#125; &#125; if(d[t] == inf) break; int flow = inf; for(int i = t; i != s; i = pv[i]) flow = min(flow, cap[pe[i]]); maxflow += flow; mincost += flow * d[t]; for(int i = t; i != s; i = pv[i]) cap[pe[i]] -= flow, cap[pe[i] ^ 1] += flow; &#125;&#125;int main() &#123; scanf("%d%d", &amp;m, &amp;n); s = n * m + n + 1, t = s + 1; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;a[j][i]); for(int i = 0; i &lt; m; i++) for(int j = 1; j &lt;= n; j++) for(int k = 1; k &lt;= n; k++) add(i * n + j, m * n + k, 1, a[i+1][k] * j), add(n * m + k, i * n + j, 0, -a[i+1][k] * j); for(int i = 1; i &lt;= n * m; i++) add(s, i, 1, 0), add(i, s, 0, 0); for(int i = n * m + 1; i &lt;= n * m + n; i++) add(i, t, 1, 0), add(t, i, 0, 0); solve(); printf("%.2lf", (double)mincost / n); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流-费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3994 约数个数和]]></title>
    <url>%2F2019%2F01%2F13%2FBZOJ3994-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目链接： BZOJ3994 Description 设d(x)为x的约数个数，给定N、M，求$\sum_{i=1}^N\sum_{j=1}^Md(ij)$ Input输入文件包含多组测试数据。 第一行，一个整数T，表示测试数据的组数。接下来的T行，每行两个整数N、M。 Output T行，每行一个整数，表示你所求的答案。 Sample Input27 45 6 Sample Output110121 HINT1&lt;=N, M&lt;=500001&lt;=T&lt;=50000 Solution首先，要先介绍一个可爱的结论：$$ d(ij) = \sum_{x|i}\sum_{y|j}[gcd(x, y) = 1] $$简单证明一下：当$(i, j)=1$时，结果显然为i的约数个数乘j的约数个数。否则，会有一部分重复，因为i*j的某一个因数可以有不同方式得到。怎样得到另一种方式呢？比如现在有$x|i,\ y|j,\ xy|ij,\ d|x$此时让x除以d，y乘以d，得到新的$xy|ij$，而这样做合法的前提是d同时是i和j的因数，或者说$gcd(x, yd)\ne 1$，当有这样的一对约数时，把结果减1，就可以得到这个式子。 结合其他几道题目，可以发现反演似乎非常青睐gcd，所有的数论函数都要尽量往最大公约数上面靠，然后再开始套路。 之后就是一道比较经典的反演题目了，总之就是推式子吧。求$$ \sum_{i=1}^N\sum_{j=1}^M\sum_{x|i}\sum_{y|j}[gcd(x, y) = 1] $$相同的x, y枚举了很多次，因此先枚举x, y，贡献可以直接计算得到，原式即$$\sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[gcd(i, j) = 1]$$我们令$$ f(n) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[gcd(i, j) = n] $$$$ F(d) = \sum_{d|n}f(n) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[d\ |\ gcd(i, j)] $$此处可以开心得去掉gcd，用漂亮的除法代替，枚举i和j分别是d的多少倍，得到$$ F(x) = \sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\lfloor\frac{N}{id}\rfloor\lfloor\frac{M}{jd}\rfloor$$这时就可以使用莫比乌斯反演了，因为可以看到我们已经消去了gcd，也就是说式子里不存在数论函数了，于是$$ f(d) = \sum_{d|n}\mu(\frac{n}{d})F(n) $$得到答案为$$ ans = f(1) = \sum_{d=1}^{min(N, M)}\mu(d)F(d) =\sum_{d=1}^{min(N, M)}\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\mu(d)\lfloor\frac{N}{id}\rfloor\lfloor\frac{M}{jd}\rfloor $$现在讨论代码实现，暴力需要三层循环，因此需要用线性筛预处理，对于每一个x，处理出$s[x] = \sum_{i=1}^x\lfloor\frac{x}{i}\rfloor$，未来查询$s[\frac{N}{d}]$，因此只需要枚举d这一个变量。再利用整除分块，$\lfloor\frac{N}{d}\rfloor$且$\lfloor\frac{M}{d}\rfloor$相同的部分只计算一次，就可以在$O(\sqrt{n})$的时间完成一次询问，总复杂度$O(T\sqrt{n})$ 关于$\mu$的计算最好作为一个模板记下啦。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 50010;int miu[N], smiu[N], v[N];long long s[N];void init(int n)&#123; for(int i = 1; i &lt;= n; i++) miu[i] = 1, v[i] = 0; for(int i = 2; i &lt;= n; i++)&#123; if(v[i]) continue; miu[i] = -1; for(int j = i + i; j &lt;= n; j += i)&#123; v[j] = 1; if((j / i) % i == 0) miu[j] = 0; else miu[j] *= -1; &#125; &#125; for(int i = 1; i &lt;= n; i++) smiu[i] = smiu[i-1] + miu[i]; for(int i = 1; i &lt;= n; i++) &#123; for(int l = 1, r; l &lt;= i; l = r + 1) &#123; r = i / (i / l); s[i] += 1ll * (r - l + 1) * (i / l); &#125; &#125;&#125;int main()&#123; init(50000); int T; scanf("%d", &amp;T); while(T--)&#123; int n, m; scanf("%d%d", &amp;n, &amp;m); if(n &gt; m) swap(n, m); long long ans = 0; for(int i = 1, j; i &lt;= n; i = j + 1)&#123; j = min(n / (n / i), m / (m / i)); ans += 1ll * (smiu[j] - smiu[i - 1]) * s[n / i] * s[m / i]; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[施工结束]]></title>
    <url>%2F2019%2F01%2F13%2F%E7%BA%AA%E5%BF%B5%E6%97%A5%2F</url>
    <content type="text"><![CDATA[博客建成日2019年1月13日，该博客基本搭建搭建完成。话说步入OI也有将近一年的时间了，之前从来没有写过博客。曾经搜题解时看到别人的博客常常是一番羡慕，但不知什么原因，或许是太懒了，一直没有为自己搭建一个blog。从昨晚起，忙碌（玩）了几个小时，心里还是非常有成就感的。从今天起，我应该会养成写题解、发博客的习惯，这应当是有深远意义的。这篇博客主要是为了一个纪念，就像古代人建了一座房子还要写一篇序一样，我如今也是有blog的人了，不仅一番激动。但愿未来这个博客会充实起来，像很多大佬一样有几十篇来自各个OJ的题解。博客界面开不是很满意，未来会慢慢润色的。]]></content>
      <categories>
        <category>纪念日</category>
      </categories>
  </entry>
</search>
