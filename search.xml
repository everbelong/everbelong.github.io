<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ1098 [POI2007]办公楼biu]]></title>
    <url>%2F2019%2F09%2F09%2FBZOJ1098-POI2007-%E5%8A%9E%E5%85%AC%E6%A5%BCbiu%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ1098 Solution题意：将一个图的点分成尽可能多的集合，任意两个属于不同集合的点都有边相连 换句话说，求补图的联通块数 然而补图的边数是$ O(n^2) $的，连边都连不了，并查集不行啊我们回归到原始，考虑bfs或dfs时需要做什么其实就是在每个点的时候，快速找到所有与他相连的未标记的点。 对于一个点，可以$O(n)$找到所有与他相连的点（废话） 如果使用bfs的话，每个点只需要被这样找到一次（不是废话） 因为一个点被找到之后，就可以入队然后找他的连边的点了，之后就算他再一次被找到，他们也已经被标记在同一个联通块里了，所以再一次找到他一次就没有必要了因此在找到一个点后，入队之余把他删除掉就好了，这个用一个链表就解决了 实质上相当于把每个连通块简化成了一个bfs树，所有其他边都是没有必要的，边数就是$O(n)$的，然后就很好搞了 Code123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010, maxm = 4000010;int head[maxn], ver[maxm], Next[maxm], tot, n, m, v[maxn], nxt[maxn], pre[maxn], col[maxn], tim, dd[maxn], sz[maxn];void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;void del(int x) &#123; nxt[pre[x]] = nxt[x]; pre[nxt[x]] = pre[x]; dd[x] = 1;&#125;void bfs(int s) &#123; queue&lt;int&gt; q; q.push(s); col[s] = tim; del(s); while(q.size()) &#123; int x = q.front(); q.pop(); for(int i = nxt[0]; i; i = nxt[i]) v[i] = 0; for(int i = head[x]; i; i = Next[i]) if(!dd[ver[i]]) v[ver[i]] = 1; for(int i = nxt[0]; i; i = nxt[i]) if(!v[i] &amp;&amp; !dd[i]) col[i] = tim, del(i), q.push(i); &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); int x, y; for(int i = 1; i &lt;= m; i++) scanf("%d%d", &amp;x, &amp;y), add(x, y), add(y, x); for(int i = 0; i &lt; n; i++) nxt[i] = i + 1; for(int i = 1; i &lt;= n; i++) pre[i] = i - 1; for(int i = 1; i &lt;= n; i++) if(!col[i]) tim++, bfs(i); printf("%d\n", tim); for(int i = 1; i &lt;= n; i++) sz[col[i]]++; sort(sz + 1, sz + 1 + tim); for(int i = 1; i &lt;= tim; i++) printf("%d ", sz[i]); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>补图</category>
      </categories>
      <tags>
        <tag>搞</tag>
        <tag>bfs</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1065 [NOI2008]奥运物流]]></title>
    <url>%2F2019%2F08%2F31%2FBZOJ1065-NOI2008-%E5%A5%A5%E8%BF%90%E7%89%A9%E6%B5%81%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ1065 Solution有一颗有根树，根节点还有一个父亲，每个点的可靠性与儿子们相关。 考虑如果是一棵纯正的树，那么答案应为$$\sum_{i=1}^nk^{dep[i]}C_i$$当出现环后，也就出现了一个方程，解这个方程即可，设1号点的后继为t$$ans = \sum_{i=1}^nk^{dep[i]}C_i + ans\times k^{dep[x]} \\ans = \frac{\sum_{i=1}^nk^{dep[i]}C_i}{1 - k^{dep[x]}}$$容易发现每个修改后继的点，后继一定修改成了1号节点，这样最优枚举1号点的后继的深度，分母也就确定了，就可以不用考虑环了 于是就是在树上dp，用$f[i][j]$表示以i为根的子树中，j个点接到1的下面，最大的稳定度但问题是转移时稳定度需要用深度来算啊，这样的状态无法转移因此再加一维记录深度，用$f[i][j][k]$表示以i为根的子树中，i的深度为k，有j个点接到1的下面，最大的稳定度这样转移时每个点u可以考虑是否接到1的下面 如果u后继改为1，那么儿子的深度要么是1（也改了），要么是2（没改）转移如下（设v是u的儿子）$$f[u][i][j] = C_u\times k + max(f[v][k][1], f[v][k][2])$$有限制条件，$\sum k = i - 1$，所以后面一项要用背包dp来做 如果u后继不改，那么儿子深度为$j + 1$或1可以同理得到这样的转移$$f[u][i][j] = C_u \times k^j + max(f[v][k][1], f[v][k][j + 1])$$限制相同，用同样的背包dp做 代码中背包dp部分的$g[i][j]$表示的是考虑前i个儿子，j个点后继改为1的最大值，实际上就是套路的背包dp 关于上面说的枚举1后继的深度，实际上可以在1的后继到1号点这条链上枚举每一个点，将他的后继改为1，dp更新答案之后再改回去，这样比较容易实现 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 70;int v[maxn], F, s[maxn], dep[maxn], sz[maxn];int n, m;double k, c[maxn], pk[maxn], f[maxn][maxn][maxn], g[maxn][maxn], ans;void init() &#123; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= n; j++) for(int k = 0; k &lt;= n; k++) f[i][j][k] = -1e18;&#125;void dpbag(int x, int d) &#123; for(int i = 0; i &lt;= sz[x]; i++) for(int j = 0; j &lt;= n; j++) g[i][j] = -1e18; g[0][0] = 0; for(int y = 2, i = 0; y &lt;= n; y++) if(s[y] == x) &#123; for(int j = 0; j &lt;= m; j++) for(int k = 0; k &lt;= j; k++) g[i+1][j] = max(g[i+1][j], g[i][k] + f[y][j-k][d]); i++; &#125;&#125;void dfs(int x) &#123; sz[x] = 0; for(int i = 2; i &lt;= n; i++) if(s[i] == x) sz[x]++, dep[i] = dep[x] + 1, dfs(i); dpbag(x, 2); for(int i = 0; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) f[x][j][i] = c[x] * k + g[sz[x]][j-1]; for(int i = 0; i &lt;= n; i++) &#123; dpbag(x, i + 1); for(int j = 0; j &lt;= m; j++) f[x][j][i] = max(f[x][j][i], g[sz[x]][j] + c[x] * pk[i]); &#125;&#125;int main() &#123; freopen("trans.in", "r", stdin); freopen("trans.out", "w", stdout); int x; scanf("%d%d%lf", &amp;n, &amp;m, &amp;k); m = min(m, n - 1); scanf("%d", &amp;F); s[1] = F; pk[0] = 1.0; for(int i = 1; i &lt;= n + 1; i++) pk[i] = pk[i-1] * k; for(int i = 2; i &lt;= n; i++) scanf("%d", &amp;x), s[i] = x; for(int i = 1; i &lt;= n; i++) scanf("%lf", &amp;c[i]); for(int i = s[1]; i != 1; i = s[i]) &#123; int tmp = s[i]; s[i] = 1; init(); dfs(1); ans = max(ans, f[1][m - (tmp == 1 ? 0 : 1)][0] / (1 - pk[dep[F] + 1])); s[i] = tmp; &#125; printf("%.2lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>树形dp</category>
        <category>背包dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1064 [Noi2008]假面舞会]]></title>
    <url>%2F2019%2F08%2F31%2FBZOJ1064-Noi2008-%E5%81%87%E9%9D%A2%E8%88%9E%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ1064 Solution对于每条信息连一条边权为1的正向边和一条边权为-1的反向边，然后染色问题，dfs一遍为每个点分配编号。若出现矛盾直接退出，否则得到这个连通块的最大可能数。对每个联通的结果求gcd，就得到了整体的最大可能数最小值就是最大值的第一个大于等于3的因数注意小于3为无解正确性显然，关键是正向反向的边权和染色 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010, maxm = 2000010;int n, m, head[maxn], ver[maxm], edge[maxm], Next[maxm], tot = 1;void add(int x, int y, int z) &#123; ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot; &#125;int col[maxn], cir[maxm], cnt, v[maxn], cmx = 1, cmn = 1, len = 0;void dfs(int x, int cur, int pa) &#123; col[x] = cur; v[x] = 1; cmn = min(cmn, col[x]), cmx = max(cmx, col[x]); // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; cur &lt;&lt; endl; for(int i = head[x]; i; i = Next[i]) if(i != pa) &#123; if(v[ver[i]]) cir[++cnt] = abs(col[ver[i]] - (cur + edge[i])); else dfs(ver[i], cur + edge[i], i ^ 1); &#125;&#125;int gcd(int x, int y) &#123; return y ? gcd(y, x % y) : x; &#125;int main() &#123; // freopen("2.in", "r", stdin); int x, y; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) scanf("%d%d", &amp;x, &amp;y), add(x, y, 1), add(y, x, -1); for(int i = 1; i &lt;= n; i++) if(!v[i]) dfs(i, 1, 0), len += cmx - cmn + 1, cmx = cmn = 1; // for(int i = 1; i &lt;= cnt; i++) cout &lt;&lt; cir[i] &lt;&lt; ' '; cout &lt;&lt; endl; int mx = 0; for(int i = 1; i &lt;= cnt; i++) mx = gcd(mx, cir[i]); if(mx == 1 || mx == 2) &#123; printf("-1 -1\n"); return 0; &#125; if(mx == 0) &#123; if(len &lt; 3) printf("-1 -1\n"); else printf("%d %d\n", len, 3); return 0; &#125; int mn; for(mn = 3; mn &lt;= mx; mn++) if(mx % mn == 0) break; printf("%d %d\n", mx, mn); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>染色</category>
      </categories>
      <tags>
        <tag>染色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1063 [Noi2008]道路设计]]></title>
    <url>%2F2019%2F08%2F31%2FBZOJ1063-Noi2008-%E9%81%93%E8%B7%AF%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ1063 Solution题意：给定一棵有根树，可以将任意条路径上的边打上标记，每个点的“不便利度”为其到根的路径上未标记边的条数，要求最小化所有点不便利度的最大值，并求方案数 树形dp，用$ f[i][0/1] $表示以i为根的子树中，i连向父亲的边是否标记，最小的不便利度考试时，我直接二分f值，实际上也可以递推，方法类似下面要说的g 这里有一个非常有用的性质考虑树链剖分时的轻重链的划分，可以发现不便利度也就是轻边个数，因此有方法使不便利度最大不会超过$ log_2n $，这样就可以进一步设计状态了 用$ g[i][0/1/2][j] $表示以i为根的子树中，i连向子树的边标记了0或1或2条，不便利度为j的方案数然后背包dp转移即可至于为什么这里开了3个，f只开了2个，因为算f时由贪心策略，每个点连出去的边一定有一条标记，但算方案数时就不一定了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long long ll;int read() &#123; int res = 0, f = 1; char c = getchar(); while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar(); if(c == '-') f = -1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + c - '0', c = getchar(); return f * res;&#125;int n, m, mod, head[maxn], ver[maxn * 2], Next[maxn * 2], tot, N;void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;int f[maxn][2], q[maxn];ll g[maxn][3][21];bool valid(int x, int pa, int mid, int lim) &#123; int cnt = 0; for(int i = head[x]; i; i = Next[i]) if(ver[i] != pa) &#123; if(f[ver[i]][0] + 1 &lt;= mid) continue; if(f[ver[i]][1] &gt; mid) return false; cnt++; &#125; if(cnt &gt; lim) return false; return true;&#125;void dp(int x, int pa) &#123; for(int i = head[x]; i; i = Next[i]) if(ver[i] != pa) dp(ver[i], x); int l = 0, r = n - 1; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(valid(x, pa, mid, 1)) r = mid; else l = mid + 1; &#125; f[x][1] = l; l = 0, r = n - 1; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(valid(x, pa, mid, 2)) r = mid; else l = mid + 1; &#125; f[x][0] = l;// cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; f[x][0] &lt;&lt; ' ' &lt;&lt; f[x][1] &lt;&lt; endl;&#125;void dfs(int x, int pa) &#123; for(int i = head[x]; i; i = Next[i]) if(ver[i] != pa) dfs(ver[i], x); for(int j = 0; j &lt;= N; j++) &#123; g[x][0][j] = 1; for(int i = head[x]; i; i = Next[i]) if(ver[i] != pa) &#123; int y = ver[i]; g[x][2][j] = (g[x][1][j] * g[y][1][j] % mod + (j ? g[x][2][j] * g[y][2][j-1] % mod : 0)) % mod; g[x][1][j] = (g[x][0][j] * g[y][1][j] % mod + (j ? g[x][1][j] * g[y][2][j-1] % mod : 0)) % mod; if(j) (g[x][0][j] *= g[y][2][j-1] % mod) %= mod; else if(Next[head[x]]) g[x][0][j] = 0; &#125; (g[x][1][j] += g[x][0][j]) %= mod; (g[x][2][j] += g[x][1][j]) %= mod; &#125; // cout &lt;&lt; x &lt;&lt; endl;// for(int i = 0; i &lt;= N; i++) cout &lt;&lt; g[x][2][i] &lt;&lt; ' '; cout &lt;&lt; endl;// for(int i = 0; i &lt;= N; i++) cout &lt;&lt; g[x][1][i] &lt;&lt; ' '; cout &lt;&lt; endl;// for(int i = 0; i &lt;= N; i++) cout &lt;&lt; g[x][0][i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125;int main() &#123;// freopen("design.in", "r", stdin);// freopen("design.out", "w", stdout); int x, y; scanf("%d%d%d", &amp;n, &amp;m, &amp;mod); for(int i = 1; i &lt;= m; i++) scanf("%d%d", &amp;x, &amp;y), add(x, y), add(y, x); if(m &lt; n - 1) &#123; printf("-1\n-1\n"); return 0; &#125; dp(1, 0); N = f[1][0]; printf("%d\n", f[1][0]); dfs(1, 0); printf("%lld\n", (g[1][2][N]) % mod); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1062 [NOI2008]糖果雨]]></title>
    <url>%2F2019%2F08%2F31%2FBZOJ1062-NOI2008-%E7%B3%96%E6%9E%9C%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ1062 Solution题意：一些线段在左右飘，支持加入和删除线段，多次询问某个时刻某个区间接触的线段个数 我们把一条线段看成是平面坐标系中横坐标为左端点，纵坐标为线段长度的一个点．同时将横坐标复制一边，代表反方向，这样就变成了标准的循环． 考虑每个询问可以覆盖的范围，那么也就是求这个范围内的点数 如果时刻都为０的话，那么每个询问的范围是一个矩形切掉一个角形成的五边形，可以补成一个平行四边形．由于翻倍了，因此是两个 当时刻不为０时，这两个平行四边形会左右平移，要考虑到有重合部分的边界情况． 平行四边形不方便处理，可以坐标变换，新的纵坐标为原来的横纵坐标之和或差，对于两个平行四边形有不同的变换方式，要建两个坐标系 懒得画图了，贴一个写的很清楚的链接 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;int n, len, rev[1000010], X[maxn], Y[maxn], cnt;struct BIT&#123; int c[2020][4020]; void add(int x, int y, int z) &#123;// cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; x++; y++; for(int i = x; i &lt;= 2010; i += i&amp;-i) for(int j = y; j &lt;= 4010; j += j&amp;-j) c[i][j] += z; &#125; int query(int x, int y) &#123; if(x &lt; 0 || y &lt; 0) return 0; x++; y++; if(x &gt; 2 * len) x = 2 * len + 1; if(y &gt; 4 * len) y = 4 * len + 1; int res = 0;// cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' '; for(int i = x; i; i -= i&amp;-i) for(int j = y; j; j -= j&amp;-j) res += c[i][j];// cout &lt;&lt; res &lt;&lt; endl; return res; &#125; int sum(int x1, int y1, int x2, int y2) &#123;// cout &lt;&lt; x1 &lt;&lt; ' ' &lt;&lt; y1 &lt;&lt; ' ' &lt;&lt; x2 &lt;&lt; ' ' &lt;&lt; y2 &lt;&lt; endl; return query(x2, y2) - query(x1-1, y2) - query(x2, y1-1) + query(x1-1, y1-1); &#125;&#125;bit1, bit2;int main() &#123; freopen("candy.in", "r", stdin); freopen("candy.out", "w", stdout); int o, t, l, r, c, d; scanf("%d%d", &amp;n, &amp;len); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;o); if(o == 1) &#123; cnt++; scanf("%d%d%d%d%d", &amp;t, &amp;c, &amp;l, &amp;r, &amp;d); rev[c] = cnt; t = (t - d * l + len * 2) % (len * 2); r = r - l; bit1.add(t, r + t, 1); bit2.add(t, r - t + 2 * len, 1); X[cnt] = t; Y[cnt] = r; &#125; if(o == 2) &#123; scanf("%d%d%d", &amp;t, &amp;l, &amp;r); int d = (r == len); t %= (len * 2); int res = bit1.sum(t, t + l, t + r, 4 * len) + bit1.sum(0, t + l - 2 * len, t + r - 2 * len - d, 4 * len);// cout &lt;&lt; res &lt;&lt; endl; res += bit2.sum(t - r, l - t + 2 * len, t - 1, 4 * len) + bit2.sum(t - r + 2 * len + d, l - t, 2 * len, 4 * len); printf("%d\n", res); &#125; if(o == 3) &#123; scanf("%d%d", &amp;t, &amp;l); int i = rev[l]; bit1.add(X[i], Y[i] + X[i], -1); bit2.add(X[i], Y[i] - X[i] + 2 * len, -1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>数形转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1921 [Ctsc2010]珠宝商]]></title>
    <url>%2F2019%2F08%2F28%2FBZOJ1921-Ctsc2010-%E7%8F%A0%E5%AE%9D%E5%95%86%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ1921 Solution本题综合利用后缀自动机的呀 首先第一想法是怎么写暴力，从每个点为起点开始想下走，同时在SAM上走DAG，对于树上的每走到一个点，把答案加上其SAM对应节点的endpos大小即可，复杂度$ O(n^2) $ 然后看到这种统计路径的题，回想到点分和DSU，先试试点分，那么需要做的是统计以经过某个点x的路径的贡献，假设这条路径是$ u \to x \to v $点分的一般思路，如果可以单独算出$ u \to x $和$ x \to v $，那么拼在一起就好了但是如何拼在一起呢考虑可以在M串上统计，每个u到x在匹配的位置上加一个标记，那么最后的答案就是每个位置 向前匹配的标记和*向后匹配的标记和 之和发现上面说的两种路径其中一种可以变成反串上的另一种，因此只需考虑一种就可以 然后就要求后缀自动机理解透彻了网上的题解都说要在后缀树上统计$ u \to x $的路径贡献然后我就想，为什么还要搞后缀树，直接在DAG上统计$ x \to v $的贡献不就可以啦，每次在后面加一个字符，方法同第一种暴力一样啊然而在网上找不到这种做法，于是我就手画了好多后缀自动机和后缀树（因为画挂了很多次），然后找到了原因如果我们走DAG来计算贡献，那么走到一个点时，要计入的是以$ x…v $为前缀的串的个数，但在DAG上走到一个位置，这个节点代表的字串可以有在$x…v$前面加了几个字符，然后就不满足要求了，但我们同样会计入答案。也就是说这样会统计多但如果在后缀树上统计$ u \to x $，那么每次是在前面加一个字符，需要向儿子走，但可以保证之后走到的每一个点代表的所有串都是以$ u…x $为后缀的，就是当且仅当的意思，所以可以正确统计这个还是要搞张图看看啊 后缀自动机一个重要性质：自动机的par树即是其反串的后缀树（所以par树也叫前缀树，前缀树是反串的后缀树，多好）然后建后缀树时记录一下每个点到其儿子走的是哪个字符的转移边 这样点分的做法就完善了，由于在每个分治点都要在后缀树上将标记推到儿子并统计，复杂度是$ O(nlogn + nm) $，后面一部分成了瓶颈 前人想出了一个很神仙的操作，我们发现第一个解法（暴力）复杂度与m无关，因此可以考虑当分治的子树大小低于某个值时直接暴力统计即可当这个值设为$ \sqrt n $时最优，复杂度可以控制在$ O((n + m)\sqrt n) $ 写在最后后缀系列算法真的好神啊，后缀自动机和后缀树的坑好深啊主要是有各种各样的性质，互相转换又即为方便然后通过这道题我还练熟了手画自动机[滑稽] Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i(a), i##_ORZ(b); i &lt;= i##_ORZ; i++)#define drep(i, a, b) for(int i(a), i##_ORZ(b); i &gt;= i##_ORZ; i--)using namespace std;const int maxn = 200010;char tr[maxn], eg[maxn];int n, m, head[maxn], ver[maxn], Next[maxn], tot, totsz, mn, rt, sz[maxn], v[maxn], B;long long ans;void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;struct SAM&#123; int par[maxn], ch[maxn][30], val[maxn], cnt, las, rt; int sz[maxn], pos[maxn], nxt[maxn][30], c[maxn], A[maxn], nod[maxn], sum[maxn]; char S[maxn]; void extend(int x, int po) &#123; int p = las, np = ++cnt; nod[po] = np; val[np] = val[p] + 1; sz[np] = 1; pos[np] = po; while(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p]; if(!p) par[np] = rt; else &#123; int q = ch[p][x]; if(val[q] == val[p] + 1) par[np] = q; else &#123; int nq = ++cnt; val[nq] = val[p] + 1; memcpy(ch[nq], ch[q], sizeof(ch[nq])); par[nq] = par[q]; par[q] = par[np] = nq; while(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p]; &#125; &#125; las = np; &#125; void build() &#123; cnt = rt = las = 1; rep(i, 1, m) extend(S[i] - 'a', i); rep(i, 1, cnt) c[val[i]]++; rep(i, 1, m) c[i] += c[i-1]; rep(i, 1, cnt) A[c[val[i]]--] = i; drep(i, cnt, 1) &#123; int x = A[i]; sz[par[x]] += sz[x]; if(!pos[par[x]]) pos[par[x]] = pos[x]; nxt[par[x]][S[pos[x] - val[par[x]]] - 'a'] = x; &#125; &#125; void clear() &#123; rep(i, 1, cnt) sum[i] = 0; &#125; void pushdown() &#123; rep(i, 1, cnt) sum[A[i]] += sum[par[A[i]]]; &#125; void match(int x, int pa, int cur, int len) &#123; if(len == val[cur]) cur = nxt[cur][tr[x] - 'a']; else if(S[pos[cur] - len] != tr[x]) cur = 0; if(!cur) return; len++; sum[cur]++; for(int i = head[x]; i; i = Next[i]) if(ver[i] != pa &amp;&amp; !v[ver[i]]) match(ver[i], x, cur, len); &#125;&#125;sam[2];void getroot(int x, int pa) &#123; sz[x] = 1; int res = 0; for(int i = head[x]; i; i = Next[i]) if(ver[i] != pa &amp;&amp; !v[ver[i]]) &#123; getroot(ver[i], x); sz[x] += sz[ver[i]]; res = max(res, sz[ver[i]]); &#125; res = max(res, totsz - sz[x]); if(res &lt; mn) rt = x, mn = res;&#125;void calc(int x, int pa, int cur) &#123; cur = sam[0].ch[cur][tr[x] - 'a']; if(!cur) return; ans += sam[0].sz[cur]; for(int i = head[x]; i; i = Next[i]) if(ver[i] != pa &amp;&amp; !v[ver[i]]) calc(ver[i], x, cur);&#125;void brute(int x, int pa) &#123; calc(x, 0, 1); for(int i = head[x]; i; i = Next[i]) if(ver[i] != pa &amp;&amp; !v[ver[i]]) brute(ver[i], x);&#125;void Insert(int x) &#123; sam[0].clear(); sam[1].clear(); sam[0].match(x, 0, 1, 0); sam[0].pushdown(); sam[1].match(x, 0, 1, 0); sam[1].pushdown(); rep(i, 1, m) ans += 1ll * sam[0].sum[sam[0].nod[i]] * sam[1].sum[sam[1].nod[m - i + 1]];&#125;void Delete(int x, int pa) &#123; sam[0].clear(); sam[1].clear(); sam[0].match(x, 0, sam[0].ch[1][tr[pa] - 'a'], 1); sam[0].pushdown(); sam[1].match(x, 0, sam[1].ch[1][tr[pa] - 'a'], 1); sam[1].pushdown(); rep(i, 1, m) ans -= 1ll * sam[0].sum[sam[0].nod[i]] * sam[1].sum[sam[1].nod[m - i + 1]];&#125;void getsz(int x, int pa) &#123; sz[x] = 1; for(int i = head[x]; i; i = Next[i]) if(!v[ver[i]] &amp;&amp; ver[i] != pa) getsz(ver[i], x), sz[x] += sz[ver[i]];&#125;void DFS(int x) &#123; if(totsz &lt;= B) &#123; brute(x, 0); return; &#125; Insert(x); v[x] = 1; for(int i = head[x]; i; i = Next[i]) if(!v[ver[i]]) Delete(ver[i], x); for(int i = head[x]; i; i = Next[i]) if(!v[ver[i]]) &#123; getsz(ver[i], x); totsz = mn = sz[ver[i]]; getroot(ver[i], x); DFS(rt); &#125;&#125;int main() &#123; int x, y; scanf("%d%d", &amp;n, &amp;m); rep(i, 1, n - 1) scanf("%d%d", &amp;x, &amp;y), add(x, y), add(y, x); B = ceil(sqrt(n)); scanf("%s%s", tr + 1, eg + 1); m = strlen(eg + 1); rep(i, 1, m) sam[0].S[i] = eg[i], sam[1].S[m - i + 1] = eg[i]; sam[0].build(); sam[1].build(); totsz = mn = n; getroot(1, 0); DFS(rt); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>字符串</category>
        <category>后缀自动机</category>
        <category>后缀树</category>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>后缀树</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1920 [Ctsc2010]产品销售]]></title>
    <url>%2F2019%2F08%2F28%2FBZOJ1920-Ctsc2010-%E4%BA%A7%E5%93%81%E9%94%80%E5%94%AE%2F</url>
    <content type="text"><![CDATA[题目链接:BZOJ1920 Solution对于30分的部分分，就是建出图后跑最小费用最大流对于100分，就是模拟费用流的过程，中间用数据结构（线段树）维护 建图方式如下$ s \to i $ 容量为U，费用为P$ i \to i+1$ 容量为$ \infty$，费用为M$ i+1 \to i$ 容量为$ \infty$，费用为C$ i \to t$ 容量为D，费用为0还有他们的反向边 考虑如何模拟费用流，首先得性质是，源点和汇点都是满流的，并且他们可以不退流，因此可以考虑枚举每个点i，分配他到汇点的流量使之满流可以发现源点到i的流有两种：$ s \to k \to k+1 \to … \to i-1 \to i ……(1)$$ s \to k \to k-1 \to … \to i+1 \to i ……(2)$我们每次选两种决策中费用较少的进行扩流，直到$D[i]$流满为止也就是过程分为三步，一、计算两种决策的代价二、取较优的方式扩流，维护信息，更新答案，直到流满三、从i移动到i+1，维护信息 决策（2）由于i是递增枚举的，所以从右到左的流只可能走C的正向边，可以不考虑M的反响边，代价为$ P[k] + sumC[k-1] - sumC[i] $，前面只与k有关，可以先排好序，每次跳过非法的（$k \le i || U[k]==0$）的k就可以直接询问 扩流的话，流量为$flow = min(U[k], D[i])$，将$[i, k-1]$的区间流量加上$flow$即可 决策（1）M的正向边有无限容量，但代价大，C的反向边代价小（为负），但有容量限制，为路径上所有正向边流量的最小值，因此前面每条边的代价有两种情况，$-C $或$ +M$如果可以对C的流量进行维护的话，那么就可以维护正确的代价，进而求最小值这个维护，需要在流量从0边成非0时设置代价为$-C$，在其又退回0后将代价加上$C+M$，可以发现每条边最多在右边时变大，在左边时变小，因此只有这两个过程就够了 扩流同上 考虑这个0的维护，如果最开始初值设为0的话，那么很难区分0到底是初值还是后来减回来的，所以一个比较好的办法是初值设为inf在没有用到它的时候默认inf就是初值的0然后会面临在决策（2）的时候，流量被区间加，这时需要先把所有inf设为0，再区间加，可以发现每个inf最多被设为0一次，可以用并查集优化，每次跳到下一个inf的位置即可然后面临在决策（1）时区间减，会出现减到0的情况这标志着要修改代价了，只有在这个时候会真正出现0。修改完代价后我们立刻把0再变回inf，代表它已经没有流量了。之所以他可以改成inf而不会继续对区间的容量有所限制，是因为我们已经修改过费用了，新的容量正好对应着新的费用。这样就完美解决了最棘手的问题。 维护的信息需要维护C的流量flow，支持区间加减，查询最小值及其位置，以及获得每个0的位置，单点置为某值。还要维护i之前每个点到i的代价（费用）cost，支持区间加减，查询最小值及其位置，单点置为某值实际上操作是类似的，可以写成一个结构体的两个对象 具体怎么维护 在$cost[1…i-1] $中查询最小值和位置k，作为决策（1）从排序好的那个序列首取出合法位置k，作为决策（2）判断用那个决策，对于（1）在$ flow[k…i-1] $中查询最小值，和U和D取min，得到流量，将$ flow[k…i-1] $区间减这个流量。在$flow$同样的区间递归找到每个为0的位置j，在$cost[1…j]$中区间加$ C[j]+M[j] $对于（2），取U和D的min作为流量，$flow$区间加流量，加之前跳并查集将inf改为0直到D[i]为0将$cost[1…i]$区间加P[i]（前提是U[i]不为0）将$cost[1…i]$区间加M[i]或-C[i]，取决于C[i]是否有流量，这是i对于前面每个点贡献的费用 然后终于结束了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i(a), i##_END(b); i &lt;= i##_END; i++)#define drep(i, a, b) for(int i(a), i##_END(b); i &gt;= i##_END; i--);using namespace std;const int maxn = 100010;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;int n, D[maxn], U[maxn], P[maxn], M[maxn], C[maxn], fa[maxn], sumC[maxn];pii rcs[maxn];ll ans;int get(int x) &#123; return fa[x] == x ? x : fa[x] = get(fa[x]); &#125; struct SegmentTree&#123; int mn[maxn * 4], pos[maxn * 4], tag[maxn * 4]; void build(int p, int l, int r, int x) &#123; if(l == r) &#123; mn[p] = x; pos[p] = l; tag[p] = 0; return; &#125; int mid = (l + r) &gt;&gt; 1; build(p*2, l, mid, x); build(p*2+1, mid + 1, r, x); mn[p] = min(mn[p*2], mn[p*2+1]); if(mn[p] == mn[p*2]) pos[p] = pos[p*2]; else pos[p] = pos[p*2+1]; &#125; void pushdown(int p) &#123; if(!tag[p]) return; mn[p*2] += tag[p]; mn[p*2+1] += tag[p]; tag[p*2] += tag[p]; tag[p*2+1] += tag[p]; tag[p] = 0; &#125; void change(int p, int l, int r, int L, int R, int x) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; mn[p] += x; tag[p] += x; return; &#125; pushdown(p); int mid = (l + r) &gt;&gt; 1; if(L &lt;= mid) change(p*2, l, mid, L, R, x); if(R &gt; mid) change(p*2+1, mid + 1, r, L, R, x); mn[p] = min(mn[p*2], mn[p*2+1]); if(mn[p] == mn[p*2]) pos[p] = pos[p*2]; else pos[p] = pos[p*2+1]; &#125; void change(int p, int l, int r, int u, int x) &#123; if(l == r) &#123; mn[p] = x; return; &#125; pushdown(p); int mid = (l + r) &gt;&gt; 1; if(u &lt;= mid) change(p*2, l, mid, u, x); else change(p*2+1, mid + 1, r, u, x); mn[p] = min(mn[p*2], mn[p*2+1]); if(mn[p] == mn[p*2]) pos[p] = pos[p*2]; else pos[p] = pos[p*2+1]; &#125; pii query(int p, int l, int r, int L, int R) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return make_pair(mn[p], pos[p]); pushdown(p); int mid = (l + r) &gt;&gt; 1; pii res(inf, 0); if(L &lt;= mid) res = min(res, query(p*2, l, mid, L, R)); if(R &gt; mid) res = min(res, query(p*2+1, mid + 1, r, L, R)); return res; &#125; void reset(int p, int l, int r, int L, int R, SegmentTree &amp;tar) &#123; if(l == r) &#123; tar.change(1, 1, n, 1, l, C[l] + M[l]); mn[p] = inf; return; &#125; pushdown(p); int mid = (l + r) &gt;&gt; 1; if(L &lt;= mid &amp;&amp; mn[p*2] == 0) reset(p*2, l, mid, L, R, tar); if(R &gt; mid &amp;&amp; mn[p*2+1] == 0) reset(p*2+1, mid + 1, r, L, R, tar); mn[p] = min(mn[p*2], mn[p*2+1]); if(mn[p] == mn[p*2]) pos[p] = pos[p*2]; else pos[p] = pos[p*2+1]; &#125;&#125;flow, cost;int main() &#123; freopen("product.in", "r", stdin); freopen("product.out", "w", stdout); scanf("%d", &amp;n); rep(i, 1, n) scanf("%d", &amp;D[i]); rep(i, 1, n) scanf("%d", &amp;U[i]); rep(i, 1, n) scanf("%d", &amp;P[i]); rep(i, 1, n - 1) scanf("%d", &amp;M[i]); rep(i, 1, n - 1) scanf("%d", &amp;C[i]); rep(i, 1, n) fa[i] = i, sumC[i] = sumC[i-1] + C[i], rcs[i] = make_pair(P[i] + sumC[i - 1], i); sort(rcs + 1, rcs + 1 + n); int rpos = 1; flow.build(1, 1, n, inf); cost.build(1, 1, n, 0); rep(i, 1, n) &#123;// cout &lt;&lt; i &lt;&lt; endl; while(D[i]) &#123; pii lcost = (i &gt; 1 ? cost.query(1, 1, n, 1, i - 1) : make_pair(inf, 0)), rcost; while(rpos &lt;= n &amp;&amp; (rcs[rpos].second &lt; i || !U[rcs[rpos].second])) ++rpos; if(rpos &lt;= n) rcost = rcs[rpos], rcost.first -= sumC[i - 1]; else rcost = make_pair(inf, 0);// cout &lt;&lt; lcost.second &lt;&lt; ' ' &lt;&lt; rcost.second &lt;&lt; endl; if(lcost &lt;= rcost) &#123; int k = lcost.second; pii flowleft = flow.query(1, 1, n, k, i - 1); int nflow = min(flowleft.first, min(U[k], D[i])); flow.change(1, 1, n, k, i - 1, -nflow); D[i] -= nflow; U[k] -= nflow; ans += 1ll * nflow * lcost.first; if(!U[k]) cost.change(1, 1, n, k, inf); flow.reset(1, 1, n, k, i - 1, cost); &#125; else &#123; int k = rcost.second; int nflow = min(U[k], D[i]); D[i] -= nflow; U[k] -= nflow; ans += 1ll * nflow * rcost.first; int j = get(i); while(j &lt;= k - 1) &#123; int fy = get(j + 1); flow.change(1, 1, n, j, 0); fa[j] = fy; j = get(j); &#125; if(k &gt; i) flow.change(1, 1, n, i, k - 1, nflow); &#125; &#125; if(i == n) break; cost.change(1, 1, n, i, U[i] ? P[i] : inf); cost.change(1, 1, n, 1, i, fa[i] == i ? M[i] : -C[i]); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>数据结构</category>
        <category>网络流</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>费用流</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1919 [Ctsc2010]性能优化]]></title>
    <url>%2F2019%2F08%2F28%2FBZOJ1919-Ctsc2010-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ1919 Solution据说是循环卷积板子题 需要对FFT有深刻的理解（不能只会敲模板） FFT本身就是支持循环卷积的，只要把长度定为n就可以令$ A,B,C $分别是点值表示的数组, $ a,b,c $为原数组$$A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\B(\omega_n^k) = \sum_{i=0}^{n-1}b_i\omega_n^{ik} \\C(\omega_n^k) = A(\omega_n^k) \times B(\omega_n^k)= \sum_{i=0}^{n-1}a_i\omega_n^{ik}\sum_{i=0}^{n-1}b_i\omega_n^{ik}$$由于$ \omega_n^{k}=\omega_n^{k+n} $, 所以将其展开可得$$C(\omega_n^k) = \sum_{s=0}^{n-1}T_s\omega_n^{is}\\T_s = \sum_{(i+j)mod(n+1)=s}a_i\cdot b_j$$我们要求的循环卷积$c$也就是$T$所以实际上$C$就是$c$的卷积, 直接逆卷积回去就可以了. 证毕 然后要解决的问题是如何求任意长度FFT, 因为无法将其补成2的幂, 所以原来的板子行不通了考虑n可以分解成P=2、3、5、7的幂，因此每次分治可以考虑分成P段，而不是单一的2段，但式子要重新搞。下面以3为例推一边，然后给出一个一般式子$$A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\=(a_0\omega_n^k+a_3\omega_n^{3k}+a_6\omega_n^{6k}+…) \\+(a_1\omega_n^k+a_4\omega_n^{3k}+a_7\omega_n^{6k}+…) \\+(a_2\omega_n^k+a_5\omega_n^{3k}+a_8\omega_n^{6k}+…) \\= A_0(\omega_n^{3k}) + \omega_n^kA_1(\omega_n^{3k}) + \omega_n^{2k}A_2(\omega_n^{3k})$$这里按照3的同余系进行分组，$A_i$代表将a按照膜3的余数分组后递归求出的点值，同理可得$$A(\omega_n^{k+\frac{n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{2k}{3}}A_2(\omega_n^{3k}) \\A(\omega_n^{k+\frac{2n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{2n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{4n}{3}}A_2(\omega_n^{3k}) \\$$然后这三个数就可以一起算了，方法类似FFT对于其他的P，同理有如下式子$$A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_n^{Pk})$$或者写成如下形式更能看出来如何递归子问题$$A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_{\frac{n}{P}}^{k})$$也就是n的规模缩小了$\frac{1}{P}$，递归后每一个对应位置都枚举i，j求一下，需要一个临时数组来备份上一层的结果也可以写非递归的，好像要预处理一下每个位置最后会移到哪里，但是递归也能A，我就没写迭代的（其实是懒） 最后的问题是FFT复数运算会存在极大精度问题，因为本题要快速幂算C次方，值域极大。所以改成NTT，题目保证n+1是质数，又已经说了n最多4个质因数，因此求一下原根就好，这里在提一下原根求法（这里的n是题目中的n，求的是n+1的原根）从2到n-1枚举g，验证g是原根的条件是：任意p是n的质因数，有$$g^{\frac{n}{p}} \neq 1\quad mod\ (n+1)$$ 为了做这题不得不复习一遍FFT的推导，本来只会敲板子的ε=(´ο｀*))) Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i(a), i##_AWSL(b); i &lt;= i##_AWSL; i++)#define drep(i, a, b) for(int i(a), i##_AWSL(b); i &gt;= i##_AWSL; i--)using namespace std;const int maxn = 500010;typedef long long ll;int n, C, mod, g, pr[10], cnt;ll a[maxn], b[maxn], tmp[maxn];ll Power(ll x, ll p) &#123; ll res = 1; for(; p; p &gt;&gt;= 1, x = x * x % mod) if(p &amp; 1) res = res * x % mod; return res;&#125;void getg() &#123; if(n % 2 == 0) pr[++cnt] = 2; if(n % 3 == 0) pr[++cnt] = 3; if(n % 5 == 0) pr[++cnt] = 5; if(n % 7 == 0) pr[++cnt] = 7; for(g = 2; g &lt;= n; g++) &#123; int tag = 0; rep(i, 1, cnt) if(Power(g, n / pr[i]) % mod == 1) tag = 1; if(!tag) break; &#125;&#125;void ntt(ll *p, int l, int r, int inv) &#123; if(l == r) return; int len = r - l + 1, P = 2; rep(i, 1, cnt) if(len % pr[i] == 0) P = pr[i]; int lp = len / P; rep(i, 0, len - 1) tmp[(i % P) * lp + i / P] = p[l + i]; rep(i, 0, len - 1) p[l + i] = tmp[i]; for(int i = l; i &lt;= r; i += lp) ntt(p, i, i + lp - 1, inv); ll omega = Power(g, n / len), w = 1; if(inv &lt; 0) omega = Power(omega, mod - 2); for(int i = l; i &lt;= l + lp - 1; i++, w = w * omega % mod) &#123; for(int j = i; j &lt;= r; j += lp) tmp[j] = p[j]; ll x = w, delta = Power(g, n / P); if(inv &lt; 0) delta = Power(delta, mod - 2); for(int j = i; j &lt;= r; j += lp, x = x * delta % mod) &#123; ll tim = 1; p[j] = 0; for(int k = i; k &lt;= r; k += lp, tim = tim * x % mod) p[j] = (p[j] + tmp[k] * tim % mod) % mod; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;C); mod = n + 1; rep(i, 0, n - 1) scanf("%lld", &amp;a[i]); rep(i, 0, n - 1) scanf("%lld", &amp;b[i]); getg(); ntt(a, 0, n - 1, 1); ntt(b, 0, n - 1, 1); rep(i, 0, n - 1) a[i] = a[i] * Power(b[i], C) % mod; ntt(a, 0, n - 1, -1); ll tmp = Power(n, mod - 2); rep(i, 0, n - 1) a[i] = a[i] * tmp % mod; rep(i, 0, n - 1) printf("%lld\n", a[i]); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>NTT</tag>
        <tag>任意长度FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3672 [Noi2014]购票]]></title>
    <url>%2F2019%2F07%2F18%2FBZOJ3672-Noi2014-%E8%B4%AD%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ3672 Solution$O(n^2)$的暴力dp很好想$$f[i] = min(f[j] + (dis[i] - dis[j])\times p_i + q_i),\quad dis[i] - dis[j] &lt;= l_i$$如果在一个序列上的话，这应该是一个经典的斜率优化，对于任意$ a &lt; b $，若要求对于i来说决策a比b更优，则$$p_i &lt; \frac{f[b] - f[a]}{dis[b] - dis[a]}$$由于p不具有单调性，因此不能从队头删除元素，而应在队列中二分查找最优的决策再加上对于决策的位置有l的限制，因此还需要用线段树 那么对于本题，在树上进行转移，就需要树链剖分了剖分后的线段树上每个节点开一个vector，维护这个节点的决策集合，一个原树上的点最多出现在log个vector中，因此空间复杂度是对的一遍dfs进行转移，维护一个根到当前节点的栈，转移时通过跳top将所有满足小于等于$l_x$的点分割成线段树上的区间，在线段树的各个vector上二分查找最优决策，取最小值，得到当前dp值，再在线段树上进行修改，最多修改log个节点，每个节点把队尾不优的决策弹出，再压如新决策网上的题解都把这个方法叫树剖线段树维护凸包 下面的代码洛谷上可过，BZOJ上会RE Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef long long ll;const ll inf = 0x3f3f3f3f3f3f3f3f;int head[maxn], ver[maxn * 2], Next[maxn * 2], tot, n, fa[maxn];ll edge[maxn * 2], P[maxn], q[maxn], L[maxn], dis[maxn], f[maxn];int son[maxn], top[maxn], seg[maxn], rev[maxn], sz[maxn], cnt, sta[maxn], Tp;vector&lt;int&gt; vec[maxn * 4];void add(int x, int y, ll z) &#123; ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;&#125;double slope(int x, int y) &#123; return 1.0 * (f[y] - f[x]) / (dis[y] - dis[x]); &#125;void dfs1(int x) &#123; sz[x] = 1; for(int i = head[x]; i; i = Next[i]) if(ver[i] != fa[x]) &#123; dis[ver[i]] = dis[x] + edge[i]; dfs1(ver[i]); if(sz[ver[i]] &gt; sz[son[x]]) son[x] = ver[i]; sz[x] += sz[ver[i]]; &#125;&#125;void dfs2(int x) &#123; seg[x] = ++cnt; rev[cnt] = x; if(son[x]) top[son[x]] = top[x], dfs2(son[x]); for(int i = head[x]; i; i = Next[i]) if(ver[i] != fa[x] &amp;&amp; ver[i] != son[x]) &#123; top[ver[i]] = ver[i]; dfs2(ver[i]); &#125;&#125;void change(int p, int l, int r, int pos) &#123; int tail = vec[p].size(); while(tail &gt; 1 &amp;&amp; slope(rev[pos], vec[p][tail-1]) &lt; slope(vec[p][tail-1], vec[p][tail-2])) tail--, vec[p].pop_back(); vec[p].push_back(rev[pos]); if(l == r) return; int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) change(p*2, l, mid, pos); else change(p*2+1, mid + 1, r, pos);&#125;ll calc(int p, int i) &#123; int l = 1, r = vec[p].size() - 1, res = 0; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(slope(vec[p][mid], vec[p][mid - 1]) &lt; (double)P[i]) res = mid, l = mid + 1; else r = mid - 1; &#125; int v = vec[p][res]; return f[v] + (dis[i] - dis[v]) * P[i] + q[i];&#125;ll query(int p, int l, int r, int L, int R, int i) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return calc(p, i); int mid = (l + r) &gt;&gt; 1; ll res = inf; if(L &lt;= mid) res = min(res, query(p*2, l, mid, L, R, i)); if(R &gt; mid) res = min(res, query(p*2+1, mid + 1, r, L, R, i)); return res;&#125;void Fly(int x, int des) &#123; int X = x; x = fa[x]; while(top[x] != top[des]) &#123; f[X] = min(f[X], query(1, 1, n, seg[top[x]], seg[x], X)); x = fa[top[x]]; &#125; f[X] = min(f[X], query(1, 1, n, seg[des], seg[x], X));&#125;void DFS(int x) &#123; sta[++Tp] = x; int l = 1, r = Tp; if(x != 1) &#123; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(dis[x] - dis[mid] &gt; L[x]) l = mid + 1; else r = mid; &#125; Fly(x, l); &#125; change(1, 1, n, seg[x]); for(int i = head[x]; i; i = Next[i]) if(ver[i] != fa[x]) DFS(ver[i]); Tp--;&#125;int main() &#123; int z; scanf("%d%d", &amp;n, &amp;z); for(int i = 2; i &lt;= n; i++) &#123; scanf("%d%d%lld%lld%lld", &amp;fa[i], &amp;z, &amp;P[i], &amp;q[i], &amp;L[i]); add(i, fa[i], z), add(fa[i], i, z); &#125; top[1] = 1; dfs1(1); dfs2(1); memset(f, 0x3f, sizeof(f)); f[1] = 0; DFS(1); for(int i = 2; i &lt;= n; i++) printf("%lld\n", f[i]); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>动态规划</category>
        <category>树链剖分</category>
        <category>斜率优化</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4543 [POI2014]Hotel加强版]]></title>
    <url>%2F2019%2F07%2F17%2FBZOJ4543-POI2014-Hotel%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ4543 Solution长链剖分第一题考虑答案只可能后两种情况 一个点往下三个分支 一个点往下两个分支，其中一个再往下有两个分支 考虑都在最上方的LCA处统计，鉴于第二种比较特殊，我们定义两个dp数组 令$f[i][j]$表示i的子树中与i距离为j的点数令$g[i][j]$表示i的子树中，两个点到其lca距离均为d，且lca到i的距离为$d - j$的点对数 这样就可以在最上方的LCA由f和g拼接出两种情况，转移方程如下：(v是u的儿子)$$f[u][j] += f[v][j-1]$$$$g[u][j] += g[v][j+1]$$$$ans += f[u][j-1] \times g[v][j] + f[v][j] \times g[u][j+1]$$$$ans += g[u][0]$$这样的做法是$O(n^2)$的可以使用长链剖分优化到$ O(nlogn) $每个点的f和g数组可以由重儿子继承来，再讲请儿子合并进去巧妙的地方在于，合并轻儿子时并不需要枚举满的第二维，只要枚举轻儿子的链长，因为轻儿子向下的最长长度就是链长。因此总共枚举的第二维实际上是$ O(n) $的正是这一点巧妙地保证了时间复杂度。从重儿子继承只是其中必要的一环，优化的关键在于转移是可以与深度有关的。不仅仅是状态与深度有关，转移也要与深度有关 还有关于如何从重儿子继承的问题，可以直接复制指针，但数组指针无法修改，单单是一个指针的话没有内存是无法下标访问的，因此事先为所有点声明好空间（也是$O(n)$)的。代码中的id变量的作用就是为每个指针预留下足够的空间。具体可以研究代码，是一个新技巧。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;int n, head[maxn], ver[maxn * 2], Next[maxn * 2], tot;void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;int son[maxn], mx[maxn], *f[maxn], *g[maxn], fa[maxn], tmp[maxn * 6], *id = tmp;long long ans;void dfs(int x, int pa) &#123; fa[x] = pa; mx[x] = 1; for(int i = head[x]; i; i = Next[i]) if(ver[i] != pa) &#123; dfs(ver[i], x); if(mx[ver[i]] + 1 &gt; mx[x]) son[x] = ver[i], mx[x] = mx[ver[i]] + 1; &#125;&#125;void Give(int x) &#123; f[x] = id; id += mx[x] + 1; id += mx[x] + 1; g[x] = id; id += mx[x] + 1; &#125;void dp(int x) &#123; if(son[x]) f[son[x]] = f[x] + 1, g[son[x]] = g[x] - 1, dp(son[x]); f[x][0] = 1; ans += g[x][0]; for(int i = head[x]; i; i = Next[i]) if(ver[i] != fa[x] &amp;&amp; ver[i] != son[x])&#123; Give(ver[i]); dp(ver[i]); for(int j = 0; j &lt; mx[ver[i]]; j++) &#123; if(j) ans += f[x][j-1] * g[ver[i]][j]; ans += g[x][j+1] * f[ver[i]][j]; &#125; for(int j = 0; j &lt; mx[ver[i]]; j++) &#123; g[x][j+1] += f[x][j+1] * f[ver[i]][j]; if(j) g[x][j-1] += g[ver[i]][j]; f[x][j+1] += f[ver[i]][j]; &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;n); int x, y; for(int i = 1; i &lt; n; i++) scanf("%d%d", &amp;x, &amp;y), add(x, y), add(y, x); dfs(1, 0); Give(1); dp(1); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>动态规划</category>
        <category>树形dp</category>
        <category>长链剖分</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1488 [HNOI2009]图的同构]]></title>
    <url>%2F2019%2F07%2F15%2FBZOJ1488-HNOI2009-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ1488 Solution题意求N个点不同构图的个数显然要用Burnside引理思路就是求出每个置换的循环个数，求2的幂的平均值需要注意求的是点置换下的边循环分情况讨论： 一个长度为$x$的点的循环内部有$\lfloor\frac{x}{2}\rfloor$个边的循环。 两个长度分别为$x$和$y$的点的循环之间有$gcd(x,y)$个边的循环 这个画画图就能明白，对于第一点，实际上是不同“长度”的边，对于第二点，每个循环节的长度一定是lcm，因此个数就是gcd 但是置换共有$n!$个，无法枚举事实上我们只需要知道每个循环的大小，求出来后乘以方案数即可。因此考虑枚举n的拆分，求出每种拆分的方案数。设共k个循环，长度分别为$a[i]$，每种长度有$c[i]$个，则方案数为：$$\frac{n!}{\Pi a[i]\Pi c[i]！}$$因为长度相同的要除以排列数，每一个循环里会有$a[i]$个是循环相同的，也要除掉 最后，本题卡常，gcd和逆元都要预处理，少了一个都会TLE（亲身实践） Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 65, mod = 997;int n, a[maxn], cnt, fac[maxn], c[maxn], ans, rev[maxn], rfac[maxn], g[maxn][maxn];int Power(int x, int p) &#123; int res = 1; for(; p; p &gt;&gt;= 1, x = x * x % mod) if(p &amp; 1) res = res * x % mod; return res; &#125;int gcd(int x, int y) &#123; if(!x) return y; return gcd(y % x, x); &#125;void calc() &#123; int tmp = fac[n], cnt = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= c[i]; j++) a[++cnt] = i; for(int i = 1; i &lt;= cnt; i++) tmp = tmp * rev[a[i]] % mod; for(int i = 1; i &lt;= n; i++) if(c[i]) tmp = tmp * rfac[c[i]] % mod; int num = 0; for(int i = 1; i &lt;= cnt; i++) num += a[i] / 2; for(int i = 1; i &lt;= cnt; i++) for(int j = i + 1; j &lt;= cnt; j++) num += g[a[i]][a[j]]; ans = (ans + tmp * Power(2, num) % mod) % mod;&#125;void dfs(int x, int s) &#123; if(x == 1) &#123; c[1] = n - s; calc(); return; &#125; for(int i = 0; s + i * x &lt;= n; i++) c[x] = i, dfs(x - 1, s + i * x), c[x] = 0;&#125;int main() &#123; scanf("%d", &amp;n); fac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i-1] * i % mod, rfac[i] = Power(fac[i], mod - 2); rev[1] = 1; for(int i = 2; i &lt;= n; i++) rev[i] = (mod - mod / i) % mod * rev[mod % i] % mod; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt;= n; j++) g[i][j] = gcd(i, j); dfs(n, 0); printf("%lld\n", ans * Power(fac[n], mod - 2) % mod); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合</category>
        <category>Burnside引理</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>Burnside引理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2655 calc]]></title>
    <url>%2F2019%2F07%2F15%2FBZOJ2655-calc%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ2655 Solution我真是见识到了插值这个东西的好处第一步的想法是直接退出一个式子，这样最好，如果没有两两不同的限制，那么式子很简单就是$[\frac{A(A+1)}{2}]^n$多了不同这个限制，那么容斥就好了，总方案$-$一对相同$+$两对相同$-…$这样写出式子看看$$(\sum_{i=1}^Ai)^n-C_{n-1}^1(\sum_{i=1}^Ai)^{n-2}(\sum_{i=1}^Ai^2)+…$$但是第三项开始就不好写了，因为可能是三连等，也可能有两对分别相同然而我们可以发现不管怎么写，这个式子始终是一个关于A的$2n$次多项式。每一项都是这个次数。然后用插值就好了，根本不用考虑什么烦人的容斥，反正插出来都一样这样A再大都可以被降到2n的级别，考虑暴力做法算$0…2n$的函数值就可以了实在是太神了，感觉什么都没做，就解决了容斥的问题！暴力的部分用dp就可以了，令$f[i][j]$表示j个小于等于i的正整数的所有序列的值得和，则$$f[i][j] = f[i-1][j-1] \times i \times j + f[i-1][j]$$意思是，如果j个数中有i，共有j种情况，每种的值都会乘以i，从f[i-1][j-1]转移，否则和f[i-1][j]相同 感觉如果发现某题的式子是个多项式，那么这题就可以转化为暴力题了 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 510;typedef long long ll;ll mod, A, n, f[maxn*2][maxn], ans;ll Power(ll x, ll p) &#123; ll res = 1; for(; p; p &gt;&gt;= 1, x = x * x % mod) if(p &amp; 1) res = res * x % mod; return res;&#125;int main() &#123; scanf("%lld%lld%lld", &amp;A, &amp;n, &amp;mod); for(int i = 0; i &lt;= n * 2; i++) f[i][0] = 1; for(int i = 1; i &lt;= n * 2; i++) for(int j = 1; j &lt;= n; j++) f[i][j] = (f[i-1][j-1] * i % mod * j % mod + f[i-1][j]) % mod; if(A &lt;= n * 2) &#123; printf("%lld\n", f[A][n]); return 0; &#125; for(int i = 0; i &lt;= n * 2; i++) &#123; ll s1 = 1, s2 = 1; for(int j = 0; j &lt;= n * 2; j++) if(i != j) s1 = (A - j + mod) % mod * s1 % mod, s2 = (i - j + mod) % mod * s2 % mod; ans = (ans + s1 * f[i][n] % mod * Power(s2, mod - 2) % mod) % mod; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>动态规划</category>
        <category>拉格朗日插值</category>
        <category>计数dp</category>
      </categories>
      <tags>
        <tag>计数dp</tag>
        <tag>拉格朗日插值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5339 [TJOI2018]教科书般的亵渎]]></title>
    <url>%2F2019%2F07%2F14%2FBZOJ5339-TJOI2018-%E6%95%99%E7%A7%91%E4%B9%A6%E8%88%AC%E7%9A%84%E4%BA%B5%E6%B8%8E%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ5339 Solution题面好难理解啊不过多看几遍，再算算样例，也就懂了可以转化为求$ \sum_{i=1}^ni^m $（n，m不是题面中的）经典的自然数幂和问题，有五种经典算法 伯努利数 递推 差分序列 我使用了另外两种方法 拉格朗日插值$m$次自然数幂和是一个$m+1$次多项式，可以举$m=1$的例子，容易发现这一点这样将$x=0…m+1$带进去，得到$m+2$个点，然后插值即可暴力做法$O(m^2)$，但由于取的是等间隔的x，因此可以优化到$O(m)$ 第二类斯特林数下文中加点表示降阶函数，也就是下划线第二类斯特林数有生成函数$$x^n=\sum_{i=0}^n\begin{Bmatrix}n \\i \\\end{Bmatrix}x^{i.}$$因此原式可以这样展开$$\sum_{i=0}^ni^m = \sum_{i=0}^n\sum_{j=0}^m\begin{Bmatrix}m \\j \\\end{Bmatrix}i^{j.}$$$$=\sum_{j=0}^m\begin{Bmatrix}m \\j \\\end{Bmatrix}j!\sum_{i=0}^n\begin{pmatrix}i \\j \\\end{pmatrix}$$$$= \sum_{j=0}^m\begin{Bmatrix}m \\j \\\end{Bmatrix}j!\begin{pmatrix}n + 1 \\j + 1 \\\end{pmatrix}$$$$=\sum_{j=1}^m\begin{Bmatrix}m \\j \\\end{Bmatrix}\frac{(n+1)^{(j+1).}}{j+1}$$然后就可以$O(n^2)$算了 Code拉格朗日插值123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 60, mod = 1e9+7;typedef long long ll;ll a[maxn], pre[maxn], suf[maxn], y[maxn], fac[maxn];ll Power(ll x, ll p) &#123; ll res = 1; for(; p; p &gt;&gt;= 1, x = x * x % mod) if(p &amp; 1) res = res * x % mod; return res;&#125;ll S(ll n, ll m) &#123; y[0] = 0; for(int i = 0; i &lt;= m + 1; i++) y[i] = (y[i-1] + Power(i, m)) % mod; if(n &lt;= m + 1) return y[n]; pre[0] = n; suf[m + 1] = n - m - 1; fac[0] = 1; suf[m + 2] = 1; for(int i = 1; i &lt;= m + 1; i++) pre[i] = pre[i-1] * (n - i) % mod, fac[i] = fac[i-1] * Power(i, mod - 2) % mod; for(int i = m; i &gt;= 0; i--) suf[i] = suf[i+1] * (n - i) % mod; ll res = suf[1] * fac[m + 1] % mod * y[0] % mod; if((m + 1) &amp; 1) res = (mod - res) % mod; for(int i = 1; i &lt;= m + 1; i++) &#123; ll tmp = suf[i + 1] * pre[i - 1] % mod * fac[i] % mod * fac[m + 1 - i] % mod; if((m - i + 1) &amp; 1) tmp = (mod - tmp) % mod; res = (res + tmp * y[i] % mod) % mod; &#125; return res;&#125;int main() &#123; int T; scanf("%d", &amp;T); ll n, m; while(T--) &#123; scanf("%lld%lld", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) scanf("%lld", &amp;a[i]); ll ans = 0; sort(a + 1, a + 1 + m); a[m + 1] = n + 1; for(int i = 1; i &lt;= m + 1; i++) &#123; for(int j = i; j &lt;= m + 1; j++) &#123; ans = (ans + S(a[j] - a[i-1] - 1, m + 1)) % mod; ans = (ans + mod - S(a[j-1] - a[i-1], m + 1)) % mod; &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125; 第二类斯特林数12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 60, mod = 1e9+7;typedef long long ll;ll a[maxn], pre[maxn], suf[maxn], y[maxn], fac[maxn], s[maxn][maxn];ll Power(ll x, ll p) &#123; ll res = 1; for(; p; p &gt;&gt;= 1, x = x * x % mod) if(p &amp; 1) res = res * x % mod; return res;&#125;ll S(ll n, ll m) &#123; ll res = 0; if(n &lt;= m) &#123; for(int i = 1; i &lt;= n; i++) res = (res + Power(i, m)) % mod; return res; &#125; for(int i = 0; i &lt;= m; i++) &#123; ll tmp = s[m][i]; for(int j = n - i + 1; j &lt;= n + 1; j++) tmp = tmp * j % mod; tmp = tmp * Power(i + 1, mod - 2) % mod; res = (res + tmp) % mod; &#125; return res;&#125;int main() &#123; int T; scanf("%d", &amp;T); ll n, m; s[0][0] = 1; for(int i = 1; i &lt;= 55; i++) for(int j = 1; j &lt;= i; j++) s[i][j] = (s[i-1][j-1] + s[i-1][j] * j % mod) % mod; while(T--) &#123; scanf("%lld%lld", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) scanf("%lld", &amp;a[i]); ll ans = 0; sort(a + 1, a + 1 + m); a[m + 1] = n + 1; for(int i = 1; i &lt;= m + 1; i++) &#123; for(int j = i; j &lt;= m + 1; j++) &#123; ans = (ans + S(a[j] - a[i-1] - 1, m + 1)) % mod; ans = (ans + mod - S(a[j-1] - a[i-1], m + 1)) % mod; &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>拉格朗日插值</category>
        <category>斯特林数</category>
      </categories>
      <tags>
        <tag>拉格朗日插值</tag>
        <tag>自然数幂和</tag>
        <tag>第二类斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2806 [Ctsc2012]Cheat]]></title>
    <url>%2F2019%2F07%2F13%2FBZOJ2806-Ctsc2012-Cheat%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ2806 Solution容易发现，L具有单调性，因此可以二分答案考虑如何判定，分段，长度有限制，容易想到经典的1D1D动规，方程如下：$$f[i] = max(f[j] + i - j, f[i-1]),\ i - maxlen[i] \leq j \leq i - L$$其中maxlen表示以i为右端点能够匹配的最长子串这个方程明显可以用单调队列优化，由于左右都有限制，因此每次入队入的是很久之前算的那个位置我最开始的写法不知为何是错的，不知为何啊剩下的就是怎样算maxlen将所有的模板串建成广义后缀自动机，之后所有的maxlen可以用一个自动机上的指针一遍预处理出来，就是每次如果无法向下转移就跳父亲，直到可以走DAG为止，跳完父亲len要用val更新，走转移边就是len++，这样才能保证正确 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2200010;int ch[maxn][2], par[maxn], val[maxn], rt = 1, cnt = 1, las = 1;void extend(int x) &#123; int np = ++cnt, p = las; val[np] = val[p] + 1; while(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p]; if(!p) par[np] = rt; else &#123; int q = ch[p][x]; if(val[q] == val[p] + 1) par[np] = q; else &#123; int nq = ++cnt; val[nq] = val[p] + 1; ch[nq][0] = ch[q][0]; ch[nq][1] = ch[q][1]; par[nq] = par[q]; par[q] = par[np] = nq; while(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p]; &#125; &#125; las = np;&#125;char str[maxn];int ml[maxn], f[maxn], q[maxn];int calc(int x) &#123; return f[x] - x; &#125;int check(int l, int n) &#123; f[0] = 0; int head = 1, tail = 0; for(int i = 0; i &lt; l; i++) f[i] = 0; for(int i = l; i &lt;= n; i++) &#123; f[i] = f[i-1]; while(head &lt;= tail &amp;&amp; calc(q[tail]) &lt; calc(i - l)) tail--; q[++tail] = i - l; while(head &lt;= tail &amp;&amp; q[head] &lt; i - ml[i]) head++; if(head &lt;= tail) f[i] = max(f[i], calc(q[head]) + i); &#125; return f[n] * 10 &gt;= n * 9;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf("%s", str); for(int j = 0; j &lt; strlen(str); j++) extend(str[j] - '0'); las = rt; &#125; while(n--) &#123; scanf("%s", str + 1); m = strlen(str + 1); int cur = rt, len = 0; for(int j = 1; j &lt;= m; j++) &#123; int u = str[j] - '0'; while(cur &amp;&amp; !ch[cur][u]) cur = par[cur], len = val[cur]; if(!cur) &#123; ml[j] = 0; cur = rt; len = 0; continue; &#125; cur = ch[cur][u]; len++; ml[j] = len; &#125; int l = 0, r = m; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(check(mid, m)) l = mid; else r = mid - 1; &#125; printf("%d\n", l); &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>字符串</category>
        <category>后缀自动机</category>
        <category>单调队列优化</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3926 [Zjoi2015]诸神眷顾的幻想乡]]></title>
    <url>%2F2019%2F07%2F12%2FBZOJ3926-Zjoi2015-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ3926 Solution20min 1A庆祝一下国家队论文写过一个trie上SAM的科技其实可以类比广义后缀自动机加入多个串，trie树上无非是每个点插入前将las移到其父亲对应的节点本题由于叶子不超过20个，以每个叶子为根，分别遍历一遍trie，全部加入一个广义自动机中，累计每个节点的max-min+1即可由于所有有向路径都可以看成以一个叶子为根的一个直的路径（也就是trie上的“子串”），因此正确性可以保证 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;int n, C, col[maxn], head[maxn], ver[maxn * 2], Next[maxn * 2], tot;int du[maxn], cnt = 1, rt = 1, ch[maxn * 40][10], par[maxn * 40], val[maxn * 40], pos[maxn];void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot;&#125;int extend(int x, int p) &#123; int np = ++cnt; val[np] = val[p] + 1; while(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p]; if(!p) par[np] = rt; else &#123; int q = ch[p][x]; if(val[q] == val[p] + 1) par[np] = q; else &#123; int nq = ++cnt; val[nq] = val[p] + 1; memcpy(ch[nq], ch[q], sizeof(ch[nq])); par[nq] = par[q]; par[q] = par[np] = nq; while(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p]; &#125; &#125; return np;&#125;void dfs(int x, int fa) &#123; pos[x] = extend(col[x], pos[fa]); for(int i = head[x]; i; i = Next[i]) if(ver[i] != fa) dfs(ver[i], x);&#125;int main() &#123; int x, y; scanf("%d%d", &amp;n, &amp;C); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;col[i]); for(int i = 1; i &lt; n; i++) scanf("%d%d", &amp;x, &amp;y), add(x, y), add(y, x), du[x]++, du[y]++; pos[0] = 1; for(int i = 1; i &lt;= n; i++) if(du[i] == 1) dfs(i, 0); long long ans = 0; for(int i = 1; i &lt;= cnt; i++) ans += val[i] - val[par[i]]; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>后缀自动机</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3669 [Noi2014]魔法森林]]></title>
    <url>%2F2019%2F07%2F10%2FBZOJ3669-Noi2014-%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ3669 Solution第一想法是二分然而不能二分a+b，更不能二分a或b因此把a和b分开考虑将所有边按照a排序，把b看成边权，一条一条加进去，维护1到n的最大边权最小的路径，随时更新答案容易证明这条路径一定在最小生成树上因此要在加边的过程中维护最小生成树需要支持询问两点路径上的最大边权，以及最大边权所在的是那条边加边时若构成环，则查询路径上的最大边，若大于当前边，则cut掉，然后加入当前边，否则跳过若不构成环，就直接加入当前边使用LCT维护，每个点记录子树最大权值及取到的位置，由于LCT只能维护点权，因此为每条边新建一个点，连到边的两个端点上本题一遍过！！！ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50010, maxm = 100010, inf = 0x3f3f3f3f;int n, m, val[maxn + maxm], fa[maxn + maxm], ch[maxn + maxm][2];int pos[maxn + maxm], sta[maxn + maxm], mx[maxn + maxm], rev[maxn + maxm];int ans = inf;struct Edg &#123; int x, y, a, b; &#125;edge[maxm];bool cmp(Edg x, Edg y) &#123; return x.a &lt; y.a; &#125;int isroot(int x) &#123; return ch[fa[x]][1] != x &amp;&amp; ch[fa[x]][0] != x; &#125;int get(int x) &#123; return ch[fa[x]][1] == x; &#125;void debug() &#123; for(int i = 1; i &lt;= n + m; i++) printf("%d %d %d %d %d %d\n", i, fa[i], ch[i][0], ch[i][1], mx[i], rev[i]);&#125;void pushup(int x) &#123; mx[x] = max(val[x], max(mx[ch[x][0]], mx[ch[x][1]])); if(mx[x] == val[x]) pos[x] = x; else if(mx[x] == mx[ch[x][0]]) pos[x] = pos[ch[x][0]]; else pos[x] = pos[ch[x][1]];&#125;void pushdown(int x) &#123; if(!rev[x]) return; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; rev[ch[x][0]] ^= 1; rev[ch[x][1]] ^= 1;&#125;void rotate(int x) &#123; int y = fa[x], d = get(x); ch[y][d] = ch[x][d ^ 1]; fa[ch[y][d]] = y; if(!isroot(y)) ch[fa[y]][get(y)] = x; fa[x] = fa[y]; ch[x][d ^ 1] = y; fa[y] = x; pushup(y); pushup(x);&#125;void splay(int x) &#123; int top = 0; sta[++top] = x; for(int i = x; !isroot(i); i = fa[i]) sta[++top] = fa[i]; for(int i = top; i; i--) pushdown(sta[i]); for(int pa = fa[x]; !isroot(x); pa = fa[x]) &#123; if(!isroot(pa)) rotate(get(x) == get(pa) ? pa : x); rotate(x); &#125;&#125;void access(int x) &#123; for(int t = 0; x; t = x, x = fa[x]) splay(x), ch[x][1] = t, pushup(x);&#125;void makeroot(int x) &#123; access(x); splay(x); rev[x] ^= 1; &#125;int findroot(int x) &#123; access(x); splay(x); while(ch[x][0]) pushdown(x), x = ch[x][0]; return x; &#125;void split(int x, int y) &#123; makeroot(x); access(y); splay(y); &#125;void cut(int x, int y) &#123; split(x, y); ch[y][0] = fa[x] = 0; pushup(y); &#125;void link(int x, int y) &#123; makeroot(x); fa[x] = y; &#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) scanf("%d%d%d%d", &amp;edge[i].x, &amp;edge[i].y, &amp;edge[i].a, &amp;edge[i].b); sort(edge + 1, edge + 1 + m, cmp); for(int i = 1; i &lt;= n; i++) val[i] = 0; for(int i = 1; i &lt;= m; i++) val[i + n] = mx[i + n] = edge[i].b; for(int i = 1; i &lt;= m; i++) &#123; int x = edge[i].x, y = edge[i].y; if(findroot(x) == findroot(y)) &#123; makeroot(x); access(y); splay(y); if(mx[y] &gt; edge[i].b) &#123; int tmp = pos[y]; int lc = edge[tmp - n].x, rc = edge[tmp - n].y; cut(tmp, lc); cut(tmp, rc); link(x, i + n); link(y, i + n); &#125; &#125; else link(x, i + n), link(y, i + n); // debug(); cout &lt;&lt; endl; if(findroot(1) != findroot(n)) continue; split(1, n); ans = min(ans, edge[i].a + mx[n]); // cout &lt;&lt; ans &lt;&lt; endl; &#125; if(ans == inf) ans = -1; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>LCT</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2049 [Sdoi2008]Cave 洞穴勘测]]></title>
    <url>%2F2019%2F07%2F08%2FBZOJ2049-Sdoi2008-Cave-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ2049 Solution不能再裸的LCT裸题好久没写了，写道题复习一下，再练难的 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10010, maxm = 200010;int fa[maxn], ch[maxn][2], rev[maxn];int get(int x) &#123; return ch[fa[x]][1] == x; &#125;int isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125;int sta[maxn];void pushdown(int x) &#123; if(!rev[x]) return; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; rev[ch[x][0]] ^= 1; rev[ch[x][1]] ^= 1;&#125;void rotate(int x) &#123; int y = fa[x], z = get(x); ch[y][z] = ch[x][z ^ 1]; fa[ch[y][z]] = y; if(!isroot(y)) ch[fa[y]][get(y)] = x; fa[x] = fa[y]; ch[x][z ^ 1] = y; fa[y] = x;&#125;void splay(int x) &#123; int top = 0; sta[++top] = x; for(int i = x; !isroot(i); i = fa[i]) sta[++top] = fa[i]; while(top) pushdown(sta[top--]); for(int pa = fa[x]; !isroot(x); pa = fa[x]) &#123; if(!isroot(pa)) rotate(get(x) == get(pa) ? pa : x); rotate(x); &#125;&#125;void access(int x) &#123; for(int t = 0; x; t = x, x = fa[x]) splay(x), ch[x][1] = t;&#125; void makeroot(int x) &#123; access(x); splay(x); rev[x] ^= 1; &#125;int findroot(int x) &#123; access(x); splay(x); while(ch[x][0]) pushdown(x), x = ch[x][0]; return x; &#125;void cut(int x, int y) &#123; makeroot(x); access(y); splay(y); fa[x] = ch[y][0] = 0; &#125;void link(int x, int y) &#123; makeroot(x); fa[x] = y; &#125;char o[20];int n, m;int main() &#123; scanf("%d%d", &amp;n, &amp;m); while(m--) &#123; int x, y; scanf("%s%d%d", o, &amp;x, &amp;y); if(o[0] == 'C') link(x, y); if(o[0] == 'D') cut(x, y); if(o[0] == 'Q') printf(findroot(x) == findroot(y) ? "Yes\n" : "No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>LCT</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2729 [HNOI2012]排队]]></title>
    <url>%2F2019%2F07%2F08%2FBZOJ2729-HNOI2012-%E6%8E%92%E9%98%9F%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ2729 Solution插板法以男生为基准，先插老师，再插女生若老师之间有男生，就是n插2，再插m若老师之间无男生，则之间只有一个女生，看成一个男生，n+1插m-1答案为$$n!A_{n+1}^2A_{n+3}^m + 2m(n+1)!A_{n+2}^{m-1}$$ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2010;struct bigint&#123; int len, a[maxn * 1000];&#125;ans, ans1, ans2;void operator += (bigint &amp;x, bigint &amp;y) &#123; int t = 0; x.len = max(x.len, y.len); for(int i = 1; i &lt;= x.len; i++) x.a[i] += y.a[i] + t, t = x.a[i] / 10, x.a[i] %= 10; while(t) x.a[++x.len] = t % 10, t /= 10;&#125;void operator *= (bigint &amp;x, int y) &#123; int t = 0; for(int i = 1; i &lt;= x.len; i++) x.a[i] *= y, x.a[i] += t, t = x.a[i] / 10, x.a[i] %= 10; while(t) x.a[++x.len] = t % 10, t /= 10;&#125;void print(bigint &amp;x) &#123; for(int i = x.len; i; i--) printf("%d", x.a[i]); printf("\n");&#125;int n, m;int main() &#123; scanf("%d%d", &amp;n, &amp;m); ans1.len = 1; ans1.a[1] = 1; ans2 = ans1; ans1 *= n + 1; ans1 *= n; for(int i = 1; i &lt;= m; i++) ans1 *= n + 4 - i; for(int i = 1; i &lt;= n; i++) ans1 *= i; ans2 *= 2 * m; for(int i = 1; i &lt; m; i++) ans2 *= n + 3 - i; for(int i = 1; i &lt;= n + 1; i++) ans2 *= i; ans1 += ans2; print(ans1); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2212 [Poi2011]Tree Rotations]]></title>
    <url>%2F2019%2F07%2F07%2FBZOJ2212-Poi2011-Tree-Rotations%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ2212 Solution每个节点翻转所影响的逆序对是它的两棵子树之间的逆序对个数，其他的和子树内的都不影响在读入的过程中就是一个dfs，在这个过程中考虑每个点是否翻转，也就是右节点中小于左节点的数对数可以用线段树合并完成，每个点维护一个权值线段树和区间和用子节点合并得到父节点，在合并时顺便统计一下前边所说的数对的个数，判断是否翻转，并累计答案 好了，正经话说完了，下面吐槽我自认为代码写的很精炼，经过一番调试后在洛谷拿到了95分，剩下的一个点是MLE最开始线段树节点数开的是maxn*50，所以调成40，然后MLE所以调成30，然后MLE所以调成20，然后RE看到人们很多写5000000，改成这个，然后MLE这个点就对不了了吗[○･｀Д´･ ○]去loj看看，然后发现了55个测试点，然后后面十几个点要么RE，要么TLE网上的人说洛谷数据水，loj强，线段树合并过不去最后去了BZOJ碰碰运气，结果RE于是我下载了LOJ上一个大数据，开无线栈开始跑，打开任务管理器看占用内存只见内存的那一个数据从9Mb，一路稳步上升，几分钟后达到了156Mb对，几分钟后这个程序还在跑然后突然156Mb降到了9Mb，程序异常退出。。。不MLE+TLE+RE才怪算了，我不纠结这个玄学的线段树合并了它的复杂度到底会到多少啊。。。下面贴上满是锅的代码 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200010;typedef long long ll;int n, rt[maxn * 8], num, sum[maxn * 30], lc[maxn * 30], rc[maxn * 30], cnt;long long ans;ll merge(int &amp;p, int lp, int rp) &#123; if(!lp || !rp) &#123; p = lp + rp; return 0; &#125; p = ++cnt; ll res = sum[lc[rp]] * sum[rc[lp]]; sum[p] = sum[lp] + sum[rp]; res += merge(lc[p], lc[lp], lc[rp]); res += merge(rc[p], rc[lp], rc[rp]); return res;&#125;void build(int &amp;p, int l, int r, int x) &#123; p = ++cnt; sum[p] = 1; if(l == r) return; int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) build(lc[p], l, mid, x); else build(rc[p], mid + 1, r, x);&#125;int fuck() &#123; int x; scanf("%d", &amp;x); if(!x) &#123; int L = fuck(), R = fuck(); ll res = merge(rt[++num], rt[L], rt[R]); ans += min(res, sum[rt[L]] * sum[rt[R]] - res); &#125; else build(rt[++num], 1, n, x); return num;&#125;int main() &#123; scanf("%d", &amp;n); fuck(); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3653 谈笑风生]]></title>
    <url>%2F2019%2F07%2F07%2FBZOJ3653-%E8%B0%88%E7%AC%91%E9%A3%8E%E7%94%9F%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ3653和洛谷P3899 Solution由题意，b和a一定是祖先关系若b是a的祖先，c在a的子树内，直接乘法累计即可若a是b的祖先，题意转换为以a为根的子树内，与a距离$\leq k$的点的sz之和可以使用主席树或线段树合并主席树：构造欧拉序列，以dfn为时间轴建立以dep为下标的权值线段树一个节点的子树在欧拉序列上是一个区间，查分询问即可线段树合并：每个点建一颗以dep为下表的权值线段树，父节点由子节点得来，考虑空间会炸，所以父节点由子节点线段树合并来代码为主席树，注意long long Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010, maxm = 600010;int head[maxn], ver[maxm], Next[maxm], tot;void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot;&#125;int n, sz[maxn], d[maxn], dfn[maxn], num;int rt[maxn * 4], cnt, lc[maxn * 40], rc[maxn * 40];long long sum[maxn * 40];int update(int las, int l, int r, int pos, int x) &#123; int p = ++cnt; sum[p] = sum[las] + x; if(l == r) return p; lc[p] = lc[las]; rc[p] = rc[las]; int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) lc[p] = update(lc[las], l, mid, pos, x); else rc[p] = update(rc[las], mid + 1, r, pos, x); return p;&#125;void dfs(int x, int fa) &#123; d[x] = d[fa] + 1; sz[x] = 1; for(int i = head[x]; i; i = Next[i]) if(ver[i] != fa) dfs(ver[i], x), sz[x] += sz[ver[i]];&#125;void build(int x, int fa) &#123; dfn[x] = ++num; rt[num] = update(rt[num - 1], 1, n, d[x], sz[x] - 1); for(int i = head[x]; i; i = Next[i]) if(ver[i] != fa) build(ver[i], x);&#125;long long query(int rp, int lp, int l, int r, int L, int R) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return sum[rp] - sum[lp]; int mid = (l + r) &gt;&gt; 1; long long res = 0; if(L &lt;= mid) res += query(lc[rp], lc[lp], l, mid, L, R); if(R &gt; mid) res += query(rc[rp], rc[lp], mid + 1, r, L, R); return res;&#125;int main() &#123; int x, y, Q, a, k; scanf("%d%d", &amp;n, &amp;Q); for(int i = 1; i &lt; n; i++) scanf("%d%d", &amp;x, &amp;y), add(x, y), add(y, x); dfs(1, 0); build(1, 0); while(Q--) &#123; scanf("%d%d", &amp;a, &amp;k); long long ans = min(d[a] - 1, k) * ((long long)sz[a] - 1); ans += query(rt[dfn[a] + sz[a] - 1], rt[dfn[a] - 1], 1, n, d[a] + 1, d[a] + k); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019扬中Day2]]></title>
    <url>%2F2019%2F07%2F05%2F2019%E6%89%AC%E4%B8%ADDay2%2F</url>
    <content type="text"><![CDATA[这场比赛前两题我用自己的非正解算法水到了188分真是好水的数据题目出的很模拟赛题目在这里 纸牌游戏（cards）我的算法就很奇怪了，$f[i][j]$只任选i个，gcd为j的方案数，然后第一问转化成组合数问题一通推式子得到$$ ans=\sum_{i=1}^{n/2}\frac{f[2i][1]}{C_{n}^{i}}-\frac{f[2i-1][1]}{C_{n}^{i-1}} $$然后第二问不好做 其实正解很巧妙，难点就在于如何记录状态，要记录gcd，还要记录那些选了，但又不能状压注意到如果当前gcd为x，那么之前选的所有数都是x的倍数，而所有x的倍数在此时应给是地位相等的，都再也不会更新gcd。这样就方便记录哪些数已经选过了用$ f[i][j] $表示选了i个，gcd为j的概率，注意此时选的i个都是x的倍数，那么有$$f[i+1][j] += f[i][j]\times \frac{sum[j]-i}{n} \\f[i+1][gcd(a[k], j)] += f[i][j]\times \frac{1}{n}$$其中$sum[j]$表示j的倍数的个数转移方程很巧妙啊，本应枚举所有未选的数，但这不现实，因此枚举所有一定不可能被选过的数，剩下哪些不确定的只要知道个数就可以了 如果第一问的状态方程这样写，那么第二问用类似的方法配合SG函数方法就可以了，具体参见标程，用记忆化搜索，把乘法换成必胜必败的判定即可 my第一问12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 310, maxm = 1010;int read() &#123; int res = 0, f = 1; char c = getchar(); while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar(); if(c == '-') f = -1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + c - '0', c = getchar(); return f * res;&#125;template&lt;typename T&gt; void chmin(T &amp;a, T b) &#123; return a = min(a, b); &#125;template&lt;typename T&gt; void chmax(T &amp;a, T b) &#123; return a = max(a, b); &#125;int a[maxn], mx, n;double f[maxn][maxm], c[maxn][maxn], ans;int gcd(int a, int b) &#123; if(!a) return b; return gcd(b % a, a);&#125;int main() &#123; freopen("cards.in", "r", stdin); freopen("cards.out", "w", stdout); n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(), mx = max(mx, a[i]); for(int i = 0; i &lt;= n; i++) c[i][0] = 1.0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) c[i][j] = c[i-1][j] + c[i-1][j-1];// for(int i = 1; i &lt;= n; i++) cout &lt;&lt; c[n][i] &lt;&lt; ' '; cout &lt;&lt; endl; f[0][0] = 1.0; f[1][a[1]] = 1.0; for(int i = 1; i &lt; n; i++) &#123; for(int j = i; j &gt;= 0; j--) &#123; for(int k = 0; k &lt;= mx; k++) &#123; if(f[j][k]) f[j + 1][gcd(k, a[i + 1])] += f[j][k]; &#125; &#125; &#125;// for(int i = 0; i &lt;= n; i++) &#123;// for(int j = 0; j &lt;= mx; j++) cout &lt;&lt; f[i][j] &lt;&lt; ' ';// cout &lt;&lt; endl;// &#125; for(int i = 2; i &lt;= n; i += 2) ans += f[i][1] / c[n][i] - f[i-1][1] / c[n][i-1]; printf("%.9lf\n", ans); printf("1\n"); return 0;&#125; std满分做法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define N 1010#define eps 1e-10using namespace std;double f[N][N];int mx,a[N],g[N][N],sum[N],visit[N][N],zy[N][N],n;int gcd(int a, int b)&#123; if (a==0) return b; if (b==0) return a; int y=a%b; while (y) &#123; a=b; b=y; y=a%b; &#125; return b;&#125;int calc(int i, int j)&#123; if (visit[i][j]) return g[i][j]; visit[i][j]=1; if (j==1) return g[i][j]=1; if (i&gt;n) return g[i][j]=0; if (i&lt;=sum[j] &amp;&amp; calc(i+1,j)==0) return g[i][j]=1; for (int k=1;k&lt;=n;k++) if ((j==0 || a[k]%j) &amp;&amp; calc(i+1,zy[j][k])==0) return g[i][j]=1; return g[i][j]=0;&#125;int main()&#123; freopen("cards.in","r",stdin); freopen("cards.out","w",stdout); int cur=0; scanf("%d",&amp;n); for (int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); cur=gcd(cur,a[i]); mx=max(mx,a[i]); f[1][a[i]]+=(double)1/n; &#125; for (int i=2;i&lt;=mx;i++) for (int j=1;j&lt;=n;j++) if (a[j]%i==0) sum[i]++; for (int i=0;i&lt;=mx;i++) for (int j=1;j&lt;=n;j++) zy[i][j]=gcd(i,a[j]); if (cur!=1) &#123; if (n%2==0) printf("%.10lf %.10lf\n",0.0,0.0); else printf("%.10lf %.10lf\n",1.0,1.0); return 0; &#125; for (int i=1;i&lt;=n-1;i++) for (int j=2;j&lt;=mx;j++) &#123; if (fabs(f[i][j])&lt;=eps || i&gt;sum[j]) continue; for (int k=1;k&lt;=n;k++) if (a[k]%j) f[i+1][zy[j][k]]+=f[i][j]*1/(n-i); f[i+1][j]+=f[i][j]*(sum[j]-i)/(n-i); &#125; double ans=0; for (int i=2;i&lt;=n;i+=2) ans+=f[i][1]; printf("%.10lf ",ans); calc(1,0); if (g[1][0]) printf("%.10lf\n",1.0); else printf("%.10lf\n",0.0); return 0;&#125; 秀秀的森林（forest）本题我的做法按道理说是会被卡掉的但看起来数据很随机，因此跑得飞起，直接AC先讲我的做法考虑dp求直径的做法，砍掉一条边后下面的子树的dp值都不会改变，只要更新砍掉的边到根的节点的dp值就可以因为这样dp值减小，不方便更新，所以时间倒流把砍边改成加边，先dfs预处理每个点的父亲和dp值，加边时暴力向上跳更新复杂度最坏应该会高达$O(n^2)$，然而数据太水 下面是正解仍然时间倒流，加上一条边后新树的直径只可能是以之前两棵树的直径端点为端点这样就好做了连边时4个端点两两组合用LCA求路径最大值，维护答案就可以了 之前好像见过这题。。。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010, mod = 1e9 + 7;int read() &#123; int res = 0, f = 1; char c = getchar(); while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar(); if(c == '-') f = -1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + c - '0', c = getchar(); return f * res;&#125;template&lt;typename T&gt; void chmin(T &amp;a, T b) &#123; return a = min(a, b); &#125;template&lt;typename T&gt; void chmax(T &amp;a, T b) &#123; return a = max(a, b); &#125;int head[maxn], ver[maxn * 2], Next[maxn * 2], tot, ena[maxn];void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot;&#125;int X[maxn], Y[maxn], n, a[maxn], fa[maxn], d[maxn], rt[maxn], q[maxn];int get(int x) &#123; if(rt[x] == x) return x; return rt[x] = get(rt[x]);&#125;long long ans[maxn], res = 1, lans[maxn], f[maxn];void update(int x) &#123; ans[x] = f[x] = a[x]; for(int i = head[x]; i; i = Next[i]) if(ver[i] != fa[x] &amp;&amp; ena[ver[i]]) &#123; ans[x] = max(ans[x], ans[ver[i]]); ans[x] = max(ans[x], f[x] + f[ver[i]]); f[x] = max(f[x], f[ver[i]] + a[x]); &#125;&#125;void dfs(int x, int pa) &#123; fa[x] = pa; d[x] = d[pa] + 1; for(int i = head[x]; i; i = Next[i]) if(ver[i] != pa) dfs(ver[i], x);&#125;long long Power(long long x, long long p) &#123; long long lres = 1; for(; p; p &gt;&gt;= 1, x = x * x % mod) if(p &amp; 1) lres = lres * x % mod; return lres;&#125;int main() &#123; freopen("forest.in", "r", stdin); freopen("forest.out", "w", stdout); n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); for(int i = 1; i &lt; n; i++) X[i] = read(), Y[i] = read(), add(X[i], Y[i]), add(Y[i], X[i]); for(int i = 1; i &lt;= n; i++) rt[i] = i, f[i] = a[i], ans[i] = a[i], res = res * ans[i] % mod; dfs(1, 0); lans[n] = res; for(int Q = 1; Q &lt; n; Q++) &#123; q[Q] = read(); if(d[X[q[Q]]] &gt; d[Y[q[Q]]]) swap(X[q[Q]], Y[q[Q]]); &#125; for(int i = n - 1; i; i--) &#123; int rx = get(X[q[i]]), ry = get(Y[q[i]]); ena[ry] = 1; res = res * Power(ans[rx], mod - 2) % mod * Power(ans[ry], mod - 2) % mod; rt[ry] = rx; for(int j = ry; j != rx; j = fa[j]) update(fa[j]); res = res * ans[rx] % mod; lans[i] = res; &#125; for(int i = 1; i &lt;= n; i++) printf("%lld\n", lans[i]); return 0;&#125; 秀秀的照片（photo） “组合数问题都是好题” 组合数推出公式就可以了显然的性质是最左边和最右边一列不同颜色个数应当相同中间m-2列的颜色是最两边两列颜色集合的交集的子集枚举中间部分颜色个数，在枚举两端的独特的颜色个数，用C求出选颜色的方案，还要乘以用恰好那么多颜色涂那么多格子的方案数，这个用第二类stirling数求，$S[i][j]$表示i个球放到j个盒子中，每个盒子都有球的方案数，这里球对应格子，盒子对应颜色，有$$S[i][j]=S[i-1][j-1]+S[i-1][j]\times j$$由于考虑排列，所以乘以阶乘，最后的结果为$$\sum_{i=0}^{min(n, k)}C_k^i \times i^{n\times(m-2)}\sum_{j=0}^{min(n-i, (k-i)/2)}C_{k-i}^j \times C_{k-i-j}^j\times S_{n}^{i+j}\times (i+j)!$$按照组合数学常见套路，能预处理的都预处理1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9+7, maxn = 4000000;typedef long long ll;ll fac[maxn + 10], infac[maxn + 10], ans, S[4010][4010];ll Power(ll x, ll p) &#123; ll res = 1; for(; p; p &gt;&gt;= 1, x = x * x % mod) if(p &amp; 1) res = res * x % mod; return res;&#125;ll C(ll x, ll y) &#123; return fac[x] * infac[y] % mod * infac[x - y] % mod;&#125;int main() &#123; freopen("photo.in", "r", stdin); freopen("photo.out", "w", stdout); int n, m, k; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); infac[0] = fac[0] = 1; for(int i = 1; i &lt;= maxn; i++) fac[i] = fac[i-1] * i % mod; infac[maxn] = Power(fac[maxn], mod - 2); for(int i = maxn - 1; i; i--) infac[i] = infac[i+1] * (i + 1) % mod; S[0][0] = 1; for(int i = 1; i &lt;= n + n; i++) for(int j = 1; j &lt;= i; j++) S[i][j] = (S[i-1][j-1] + S[i-1][j] * j % mod) % mod; for(int i = 0; i &lt;= min(n, k); i++) &#123; ll tmp = C(k, i) * Power(i, n *(m - 2)) % mod; ll sum = 0; for(int j = 0; j + i + j &lt;= k, i + j &lt;= n; j++) &#123; ll tt = C(k - i, j) * C(k - i - j, j) % mod; ll t2 = S[n][i + j] * fac[i + j] % mod; t2 = t2 * t2 % mod; sum = (sum + tt * t2 % mod) % mod; &#125; ans = (ans + tmp * sum % mod) % mod; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>集训</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>博弈论</tag>
        <tag>树上动规</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4945 [Noi2017]游戏]]></title>
    <url>%2F2019%2F07%2F04%2FBZOJ4945-Noi2017-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ4945 Solution本题标记着本人练习2-sat达到一个高潮如果没有x，那就是一个裸的2-sat然而x的个数很小，可以暴力枚举，所以实际上还是裸的2-sat每个x枚举1.不能选A，那么就是B、C二选一2.不能选B，那么就是A、C二选一这样就已经包含了ABC三种情况，所以暴力枚举的复杂度为$2^d$ 下面说一说裸的2-sat怎么做用tarjan算法求出所有的强连通分量如果某个对偶的两点位于同一分量，则无解否则有解，那么问题就是如何输出任意一解对于缩点后的反图，按拓扑序，选当前节点，把她得姐妹节点删除事实上不用拓扑排序，节点scc编号的大小就是反图拓扑序的大小，因此姐妹点选scc小的即可 tarjan比dfs快，我终于明白了，dfs是$O(nm)$的 这里还有一些要注意的地方，如果一个限制中提到了一定不会出现赛车，设此限制为$(x\to y)$，若x不可能选，则直接continue，若y不可能选，则x连向他的姐妹节点，巧妙地表达了x不可能选 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 150010, maxm = 400010;int head[maxn], ver[maxm], Next[maxm], tot;void add(int x, int y) &#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot;&#125;char str[maxn], qx[maxm], qy[maxm], car[3][2] = &#123;&#123;'B', 'C'&#125;, &#123;'A', 'C'&#125;, &#123;'A', 'B'&#125;&#125;;int n, d, m, xpos[10], xcnt, X[maxm], Y[maxm];int dfn[maxn], low[maxn], num, scc, ins[maxn], sta[maxn], top, bel[maxn];const int rnk[3][3] = &#123;&#123;-1, 0, 1&#125;, &#123;0, -1, 1&#125;, &#123;0, 1, -1&#125;&#125;; void tarjan(int x) &#123; ins[x] = 1; sta[++top] = x; dfn[x] = low[x] = ++num; for(int i = head[x]; i; i = Next[i]) &#123; if(!dfn[ver[i]]) tarjan(ver[i]), low[x] = min(low[x], low[ver[i]]); else if(ins[ver[i]] == 1) low[x] = min(low[x], dfn[ver[i]]); &#125; if(dfn[x] == low[x]) &#123; int z = 0; scc++; while(z != x) &#123; z = sta[top--]; ins[z] = 2; bel[z] = scc; &#125; &#125;&#125;bool solve() &#123; //cout &lt;&lt; str + 1 &lt;&lt; endl; memset(dfn, 0, sizeof(dfn)); memset(head, 0, sizeof(head)); memset(ins, 0, sizeof(ins)); memset(low, 0, sizeof(low)); num = scc = top = tot = 0; for(int i = 1; i &lt;= m; i++) &#123; if(str[X[i]] - 'a' == qx[i] - 'A') continue; int x = rnk[str[X[i]] - 'a'][qx[i] - 'A']; int y = rnk[str[Y[i]] - 'a'][qy[i] - 'A']; if(str[Y[i]] - 'a' == qy[i] - 'A') &#123; add(X[i] + x * n, X[i] + n * (1 - x)); continue; &#125; //cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; add(x * n + X[i], y * n + Y[i]); add((1 - y) * n + Y[i], (1 - x) * n + X[i]); &#125; for(int i = 1; i &lt;= n * 2; i++) if(!dfn[i]) tarjan(i); for(int i = 1; i &lt;= n; i++) if(bel[i] == bel[i + n]) return false; for(int i = 1; i &lt;= n; i++) if(bel[i] &lt; bel[i + n]) printf("%c", car[str[i] - 'a'][0]); else printf("%c", car[str[i] - 'a'][1]); printf("\n"); return true;&#125;bool dfs(int x) &#123; if(x &gt; xcnt) return solve(); str[xpos[x]] = 'a'; if(dfs(x + 1)) return true; str[xpos[x]] = 'b'; if(dfs(x + 1)) return true; return false;&#125;int main() &#123; //freopen("input", "r", stdin); //freopen("user_out", "w", stdout); scanf("%d%d", &amp;n, &amp;d); scanf("%s%d", str + 1, &amp;m); for(int i = 1; i &lt;= n; i++) if(str[i] == 'x') xpos[++xcnt] = i; for(int i = 1; i &lt;= m; i++) scanf("%d %c%d %c", &amp;X[i], &amp;qx[i], &amp;Y[i], &amp;qy[i]); if(!dfs(1)) printf("-1\n"); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>2-sat</category>
      </categories>
      <tags>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3160 万径人踪灭]]></title>
    <url>%2F2019%2F07%2F03%2FBZOJ3160-%E4%B8%87%E5%BE%84%E4%BA%BA%E8%B8%AA%E7%81%AD%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ3160 Solution题意在题面里已经说过了对于第三点限制，只要算出所有满足1、2点的子序列，再减去回文子串的个数就可以回文子串个数直接裸的马拉车考虑如何求满足的子序列个数枚举对称轴x，由于位置对称，我们只要知道有多少对是相等的就可以（这里的一对指的是位置为$i$和$2x-i$的一对位置这个形式很像多项式卷积，因此用fft实现a和b分开处理，处理a时把a的位置置为1，与自己卷积，得到的多项式中只有对称才会产生贡献，只要询问第$2x$位就可以 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 800010, mod = 1e9+7;const double pi = acos(-1);typedef complex&lt;double&gt; cp;typedef long long ll;char str[maxn], nstr[maxn];int n, r[maxn], x[maxn], y[maxn], f[maxn]; ll ans;cp a[maxn], b[maxn];ll Power(ll x, ll p) &#123; ll res = 1; for(; p; p &gt;&gt;= 1, x = x * x % mod) if(p &amp; 1) res = res * x % mod; return res;&#125;void fft(cp *p, int N, int inv) &#123; for(int i = 0; i &lt;= N; i++) if(i &lt; r[i]) swap(p[i], p[r[i]]); for(int mid = 1; mid &lt; N; mid &lt;&lt;= 1) &#123; cp omega(cos(pi / mid), inv * sin(pi / mid)); for(int i = 0; i &lt; N; i += mid &lt;&lt; 1) &#123; cp w(1, 0); for(int j = 0; j &lt; mid; j++, w *= omega) &#123; cp x = p[i + j], y = w * p[i + j + mid]; p[i + j] = x + y, p[i + j + mid] = x - y; &#125; &#125; &#125;&#125;void manacher() &#123; int nn = 0, mx = 1, pos = 1; nstr[0] = '$'; nstr[++nn] = '#'; for(int i = 1; i &lt;= n; i++) nstr[++nn] = str[i], nstr[++nn] = '#'; nstr[++nn] = '\0'; for(int i = 1; i &lt;= nn; i++) &#123; f[i] = min(f[2 * pos - i], mx - i); if(f[i] &lt; 1) f[i] = 1; while(nstr[i + f[i]] == nstr[i - f[i]]) f[i]++; if(i + f[i] &gt; mx) mx = f[i] + i, pos = i; &#125; for(int i = 1; i &lt;= nn; i++) ans = (ans - f[i] / 2 + mod) % mod;&#125;int main() &#123; scanf("%s", str + 1); n = strlen(str + 1); for(int i = 1; i &lt;= n; i++) if(str[i] == 'a') a[i] = cp(1, 0); else b[i] = cp(1, 0); int N = 1, wei = 0; while(N &lt;= 2 * n) N &lt;&lt;= 1, wei++; for(int i = 0; i &lt;= N; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (wei - 1)); fft(a, N, 1); fft(b, N, 1); for(int i = 0; i &lt;= N; i++) a[i] *= a[i], b[i] *= b[i]; fft(a, N, -1); fft(b, N, -1); for(int i = 0; i &lt;= N; i++) x[i] = (int)(a[i].real() / N + 0.5), y[i] = (int)(b[i].real() / N + 0.5); for(int i = 2; i &lt;= 2 * n; i++) &#123; int tmp = x[i] + y[i]; if(i % 2 == 0) tmp++; tmp /= 2; //cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; x[i] &lt;&lt; ' ' &lt;&lt; y[i] &lt;&lt; ' ' &lt;&lt; tmp &lt;&lt; endl; ans += (Power(2, tmp) - 1 + mod) % mod; &#125; //cout &lt;&lt; ans &lt;&lt; endl; manacher(); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
        <category>字符串</category>
        <category>manachar</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>manachar</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3527 [Zjoi2014]力]]></title>
    <url>%2F2019%2F07%2F02%2FBZOJ3527-Zjoi2014-%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ3527 Solution我们要快速的求出$$\sum_{j=1}^i\frac{q_j}{(i-j)^2} \\\sum_{j=i}^n\frac{q_j}{(i-j)^2}$$可以看成是分子*分母的倒数，分母递增或递减构建两个个数组$$b_i = \frac{1}{i^2} \\c_i = \frac{1}{(n+1-i)^2}$$分别与q卷积，得到的新b数组的第$i$项是前部分的结果新c数组的第$i+n+1$项是后半部分怎么得出来的可以画图看看 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 400010;const double pi = acos(-1);typedef complex&lt;double&gt; cp;double q[maxn];cp a[maxn], b[maxn], c[maxn];int n, r[maxn];double sq(double x) &#123; return x * x; &#125;void fft(cp *p, int N, int inv) &#123; for(int i = 0; i &lt;= N; i++) if(i &lt; r[i]) swap(p[i], p[r[i]]); for(int mid = 1; mid &lt; N; mid &lt;&lt;= 1) &#123; cp omega(cos(pi / mid), inv * sin(pi / mid)); for(int i = 0; i &lt; N; i += mid &lt;&lt; 1) &#123; cp w(1, 0); for(int j = 0; j &lt; mid; j++, w *= omega) &#123; cp x = p[i + j], y = w * p[i + j + mid]; p[i + j] = x + y, p[i + j + mid] = x - y; &#125; &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%lf", &amp;q[i]); for(int i = 1; i &lt;= n; i++) a[i] = cp(q[i], 0), b[i] = cp(1.0 / sq(i), 0), c[i] = cp(1.0 / sq(n - i + 1), 0); int N = 1, wei = 0; while(N &lt; 2 * n) N &lt;&lt;= 1, wei++; for(int i = 0; i &lt;= N; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (wei - 1)); fft(a, N, 1); fft(b, N, 1); fft(c, N, 1); for(int i = 0; i &lt;= N; i++) b[i] *= a[i], c[i] *= a[i]; fft(b, N, -1), fft(c, N, -1); for(int i = 1; i &lt;= n; i++) printf("%lf\n", b[i].real() / N - c[i + n + 1].real() / N); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4827 [Hnoi2017]礼物]]></title>
    <url>%2F2019%2F07%2F01%2FBZOJ4827-Hnoi2017-%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ4827 Solution题意求$$min{\sum_{i=1}^n(x_i - y_{i+k} + C)}$$C是每个增加的亮度，k是旋转的位数把他拆开可以写成$$\sum_{i=1}^n(x_i^2+y_i^2) +\sum_{i=1}^n2C(x_i-y_i)+nC^2-2\sum_{i=1}^nx_iy_{i+k}$$难点是求最后一项$\sum_{i=1}^nx_iy_{i+k}$的最大值这种形式经常使用多项式卷积把x数组倒序，y后面再连一个y，得到的两个新数组卷积最后上面的式子就是$x^{n+1+k}$的系数，从$x^{n+1}$到$x^{n+n}$取最大值就可以了之后C可以在m的值域内枚举，也可以直接得到，利用二次函数最值，可知$C=\frac{\sum_{i=1}^ny_i-\sum_{i=1}^nx_i}{n} $ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50010;typedef complex&lt;double&gt; cp;typedef long long ll;const double pi = acos(-1);int x[maxn * 8], y[maxn * 8], m, n, r[maxn * 8], f[maxn * 8], ans;cp a[maxn * 8], b[maxn * 8];void fft(cp *p, int N, int inv) &#123; for(int i = 0; i &lt;= N; i++) if(i &lt; r[i]) swap(p[i], p[r[i]]); for(int mid = 1; mid &lt; N; mid &lt;&lt;= 1) &#123; cp omega = cp(cos(pi / mid), inv * sin(pi / mid)); for(int i = 0; i &lt; N; i += mid &lt;&lt; 1) &#123; cp w(1, 0); for(int j = 0; j &lt; mid; j++, w *= omega) &#123; cp x = p[i + j], y = w * p[i + j + mid]; p[i + j] = x + y; p[i + j + mid] = x - y; &#125; &#125; &#125;&#125;int main() &#123; //freopen("gift9.in", "r", stdin); scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;x[i]); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;y[i]); for(int i = 1; i &lt;= n; i++) a[i] = cp(x[n + 1 - i], 0), b[i] = b[i + n] = cp(y[i], 0); //for(int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; ' ' &lt;&lt; b[i] &lt;&lt; endl; int N = 1, wei = 0; while(N &lt; 3 * n) N &lt;&lt;= 1, wei++; for(int i = 0; i &lt;= N; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (wei - 1)); fft(a, N, 1); fft(b, N, 1); for(int i = 0; i &lt;= N; i++) a[i] *= b[i]; fft(a, N, -1); for(int i = 0; i &lt;= N; i++) f[i] = (int)(a[i].real() / N + 0.5); double c = 0; for(int i = 1; i &lt;= n; i++) ans += x[i] * x[i] + y[i] * y[i], c += y[i] - x[i]; c = round(c / n); int tmp = 0; for(int i = n + 1; i &lt;= n + n; i++) tmp = max(tmp, f[i]); for(int i = 1; i &lt;= n; i++) ans += 2 * c * (x[i] - y[i]); ans += n * c * c - 2 * tmp; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
        <tag>二次函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3930 [CQOI2015]选数]]></title>
    <url>%2F2019%2F06%2F30%2FBZOJ3930-CQOI2015-%E9%80%89%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ3930 Solution整体除以gcd，相当于在一个区间内选gcd=1的方案数$$f(d) = \sum [gcd(a_i)=d] \\F(d) = \sum [d|gcd(a_i)] = \sum_{d|n}f(n)$$$$f(1) = \sum_{i=1}^{R}\mu(i)(\frac{R}{i}-\frac{L-1}{i})^k$$难点在$\mu$的计算上，因为左右端点都可能很大所以使用杜教筛，很裸地计算$\mu$的前缀和在这道题里记一下杜教筛记$S(n)=\sum_{i=1}^nf(i)$，有$h=f*g$$$\sum_{i=1}^Nh(i) = \sum_{i=1}^N\sum_{d|i}g(d)f(\frac{i}{d}) \\= \sum_{d=1}^N\sum_{i=1}^{\frac{N}{d}}g(d)f(i) \\= \sum_{d=1}^Ng(d)\sum_{i=1}^{\frac{N}{d}}f(i) \\= \sum_{d=1}^Ng(d)S(\frac{N}{d})$$关键的一步，提取后面的第一项$$\sum_{i=1}^Nh(i) = g(1)S(N) + \sum_{d=2}^Ng(d)S(\frac{N}{d})$$$$g(1)S(N) = \sum_{i=1}^Nh(i) - \sum_{d=2}^Ng(d)S(\frac{N}{d})$$要求前面h的前缀和好求，后面可以整除分块此乃杜教筛也 对于现在要求的mu，就是这样$$S(N) = 1 - \sum_{d=2}^NS(\frac{N}{d})$$就做完了 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010, mod = 1e9+7;typedef long long ll;int v[maxn], prim[maxn], cnt;ll sum[maxn], n, k, L, R, ans;map&lt;int, ll&gt; miu;ll Power(ll x, ll p) &#123; ll res = 1; for(; p; p &gt;&gt;= 1, x = x * x % mod) if(p &amp; 1) res = res * x % mod; return res;&#125;void init(int N) &#123; v[0] = v[1] = 1; sum[1] = 1; for(int i = 2; i &lt;= N; i++) &#123; if(!v[i]) &#123; prim[++cnt] = i; sum[i] = -1; &#125; for(int j = 1; j &lt;= cnt &amp;&amp; i * prim[j] &lt;= N; j++) &#123; v[i * prim[j]] = 1; if(i % prim[j]) sum[i * prim[j]] = -sum[i]; else &#123; sum[i * prim[j]] = 0; break; &#125; &#125; &#125; for(int i = 2; i &lt;= N; i++) sum[i] = (sum[i] + sum[i-1] + mod) % mod;&#125;ll calc(int x) &#123; if(x &lt;= 100000) return sum[x]; if(miu[x]) return miu[x]; ll res = 0; for(int l = 2, r; l &lt;= x; l = r + 1) &#123; r = x / (x / l); res = (res + calc(x / l) * (r - l + 1) % mod) % mod; &#125; return miu[x] = (1ll + mod - res) % mod;&#125;int main() &#123; scanf("%lld%lld%lld%lld", &amp;n, &amp;k, &amp;L, &amp;R); init(100000); L = (L - 1) / k; R = R / k; for(ll l = 1, r; l &lt;= R; l = r + 1) &#123; r = R / (R / l); if(l &lt;= L) r = min(r, L / (L / l)); ans = (ans + (calc(r) - calc(l - 1) + mod) % mod * Power(R / l - L / l, n) % mod) % mod; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>莫比乌斯反演</category>
        <category>杜教筛</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2154 Crash的数字表格]]></title>
    <url>%2F2019%2F06%2F29%2FBZOJ2154-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ2154 Solution题意求$$\sum_{i=1}^n\sum_{j=1}^mlcm(i, j)$$$$ = \sum_{i=1}^n\sum_{j=1}^m\frac{ij}{gcd(i,i)}$$$$ = \sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^m[gcd(i, j)=d]\frac{ij}{d}$$套路地提取d$$ = \sum_{d=1}^nd\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i, j) = 1]ij$$先处理后面一部分令$$f(d) = \sum_{i=1}^x\sum_{j=1}^{y}[gcd(i, j)=d]ij \\F(d) = \sum_{i=1}^x\sum_{j=1}^{y}[d|gcd(i, j)]ij \\ = \sum_{d|n}f(n) = d^2S(\frac{x}{d})S(\frac{y}{d})$$其中$S(n)$表示从1加到n，也就是$\frac{n(n+1)}{2}$利用莫比乌斯反演$$f(d) = \sum_{d|k}\mu(\frac{k}{d})F(k)$$$$ans = \sum_{d=1}^{n}df(1) = \sum_{d=1}^nd\sum_{i=1}^n\mu(i)i^2S(\frac{n}{id})S(\frac{m}{id})$$为了减少复杂度，从$O(n)$降到$O(\sqrt{n})$，令$T=id$，改为枚举T$$ans = \sum_{T=1}^nS(\frac{n}{T})S(\frac{m}{T})\sum_{d|T}dT\mu(d)$$至此，考虑如何实现前面整除分块不用多说，讲讲后面的$\sum_{d|T}dT\mu(d)$，这是个积性函数，可以线性筛预处理出来，具体如下：如果当前质因数p次数不为1那么前面的所有因数要么包含一个p，要么不含p，否则贡献为零，不用考虑前者会产生0和包含一个p的因数，后者会产生包含一个或不包含的因此最终与没有p时相同，再乘上T的变化也就是p即可如果p的次数唯一，则互质，由积性算即可 Code12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 20101009, maxn = 10000010, r2 = (mod + 1) / 2;typedef long long ll;ll n, m, prim[maxn], cnt, s[maxn], v[maxn], ans;void init(int N) &#123; v[1] = v[0] = 1; s[1] = 1; for(int i = 2; i &lt;= N; i++) &#123; if(!v[i]) &#123; prim[++cnt] = i; s[i] = (i - 1ll * i * i % mod + mod) % mod; &#125; for(int j = 1; j &lt;= cnt &amp;&amp; i * prim[j] &lt;= N; j++) &#123; v[i * prim[j]] = 1; if(i % prim[j] == 0) &#123; s[i * prim[j]] = s[i] * prim[j] % mod; break; &#125; else s[i * prim[j]] = s[i] * s[prim[j]] % mod; &#125; &#125; //for(int i = 1; i &lt;= N; i++) cout &lt;&lt; s[i] &lt;&lt; ' ';cout &lt;&lt; endl; //for(int i = 1; i &lt;= N; i++) cout &lt;&lt; s[i] &lt;&lt; ' ';cout &lt;&lt; endl; for(int i = 1; i &lt;= N; i++) s[i] = (s[i] + s[i-1]) % mod;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); init(max(n, m)); for(int l = 1, r; l &lt;= n &amp;&amp; l &lt;= m; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ll s1 = (n / l + 1) * (n / l) % mod * r2 % mod; ll s2 = (m / l + 1) * (m / l) % mod * r2 % mod; ans = (ans + (s[r] - s[l - 1] + mod) % mod * s1 % mod * s2 % mod) % mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3676 [Apio2014]回文串]]></title>
    <url>%2F2019%2F06%2F29%2FBZOJ3676-Apio2014-%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ3676 Solution1.找出回文串2.查询他出现次数，更新答案第一步使用马拉车，需要注意，只有更新mx是会产生新的回文串，数量是$O(n)$的，也就是只有$O(n)$次询问询问使用后缀自动机，从右端对应的节点开始树上倍增，由于祖先上全都是其后缀，所以定位到长度合适的节点。更新答案即可。比较水，基本方法，基本性质 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 600005;char strr[maxn], str[maxn];int ch[maxn][26], val[maxn], par[maxn], n, nn, cnt = 1, p[maxn], rt = 1, las = 1;int epos[maxn], sz[maxn], f[maxn][21], c[maxn], a[maxn];long long ans;void extend(int x) &#123; int p = las, np = ++cnt; val[np] = val[p] + 1; sz[np] = 1; while(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p]; if(!p) par[np] = rt; else &#123; int q = ch[p][x]; if(val[q] == val[p] + 1) par[np] = q; else &#123; int nq = ++cnt; val[nq] = val[p] + 1; memcpy(ch[nq], ch[q], sizeof(ch[q])); par[nq] = par[q]; par[q] = par[np] = nq; while(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p]; &#125; &#125; las = np;&#125;void check(int l, int r) &#123; if(l &lt; 1 || r &lt; 1) return; //cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; int len = r - l + 1; int x = epos[r]; for(int i = 20; i &gt;= 0; i--) &#123; if(f[x][i] &amp;&amp; val[f[x][i]] &gt;= len) x = f[x][i]; &#125; ans = max(ans, (long long)len * sz[x]);&#125;void manachar() &#123; for(int i = 1; i &lt;= nn; i++) str[++n] = '#', str[++n] = strr[i]; str[++n] = '\n'; int mx = 0, pos = 0; for(int i = 1; i &lt;= n; i++) &#123; if(i &lt; mx) p[i] = min(mx - i, p[pos * 2 - i]); while(str[i + p[i]] == str[i - p[i]]) &#123; if(i + p[i] &gt;= mx) check((i - p[i] + 1) / 2, (i + p[i]) / 2); p[i]++; &#125; if(mx &lt; i + p[i]) mx = i + p[i], pos = i; &#125;&#125;int main() &#123; //freopen("testdata.in", "r", stdin); //freopen("testdata.my", "w", stdout); scanf("%s", strr + 1); nn = strlen(strr + 1); for(int i = 1; i &lt;= nn; i++) extend(strr[i] - 'a'), epos[i] = las; for(int i = 1; i &lt;= cnt; i++) c[val[i]]++; for(int i = 1; i &lt;= nn; i++) c[i] += c[i-1]; for(int i = 1; i &lt;= cnt; i++) a[c[val[i]]--] = i; for(int i = cnt; i; i--) sz[par[a[i]]] += sz[a[i]]; for(int i = 1; i &lt;= cnt; i++) &#123; int x = a[i]; f[x][0] = par[x]; for(int k = 1; k &lt;= 20; k++) f[x][k] = f[f[x][k-1]][k-1]; &#125; manachar(); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>后缀自动机</category>
        <category>manachar</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>manachar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串算法总结]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对于一些字符串算法的个人心得其实就是记一些性质，还有容易忘的东西，不然未来还要上网查(┬＿┬) AC自动机AC自动机是trie + KMP在trie上设置fail指针，匹配失败就往上跳 那么在跳的过程中经过的每个点其实都是当前字符串的后缀 匹配的过程就是从字符串对应trie的链上的每一个点向上跳fail 也就是相当于枚举了所有前缀的后缀 然而实际上并没有枚举那么多，因为后缀并未完全枚举，这就是复杂度稳定在$O(M+N)$的原因(N为模式串总长，M为母串长)关于时间复杂度，走trie共M次，跳fail次数不会大于走trie的次数，因此匹配是$O(M)$的 然后我们把fail指针想象成一棵树 一个点的子树是以他为后缀的所有串 所以 一个点对应的字符串x出现在另一个字符串y中，当且仅当 y对应的trie链 和 x对应的fail子树 有交集其中x和y都是AC自动机上的字符串 以上就是AC自动机的一些性质，以及本质的理解，其实和后缀自动机有点联系 扩展KMP求给定字符串S的所有后缀与另一字符串T的最长公共前缀也叫z-algorithm其实和KMP思路一样，就是先算nxt[]，再算extend[]，都用已经算好的nxt来算 extend：$S[i~N]$前缀与$T$前缀最长公共长度nxt：$T[i~M]$前缀与$T$前缀最长公共长度 对比一下KMP(T子串，S母串) f：$S[1~i]$后缀与$T[1~i]$前缀最长公共长度nxt：$T[1~i]$后缀与$T[1~i]$前缀最长公共长度 看起来这是字符串的常见套路啊 啥的（前缀/后缀）与啥的（前缀/后缀）的最长公共长度 而AC和后缀自动机也是在纠结前缀和后缀⊙﹏⊙ manachar只记一个东西 马拉车求出所有本质不同的回文串是$ O(n) $的，也就是每次更新mx的时候才会产生新的一个回文子串，否则就是前面算过了的 于是就可以有很多manachar + 的算法 后缀数组后缀数组主要是以下几个用法： $O(1)$求后缀的LCP，搭配其他算法和数据结构，比如调和级数法、倍增法（利用$f[][]$求匹配的区间，转化为区间问题） 二分长度，在height数组上划分成很多段，每一段进行判定，很多时候也可以用单调栈优化 直接在height上统计，比如相同子串个数、不同子串个数 height重叠之后就有循环节了，然后搞事情，关于循环节，经常使用调和级数法，然后处理不满一段的部分 处理很多串时可以连在一起，中间加入特殊字符，注意每一个特殊字符都不同 例题这篇博客总结的很好最后两题没有很想明白课件已经下载在本地了 后缀数组是在数组（sa，height）上搞事情，后缀自动机是在DAG和树上搞事情 后缀自动机陈立杰课件一个比较好的博客利用这个图比较好纠结 我们关心的并不是他是怎么想出自动机的，而是自动机能怎么用，因此通过性质理解即可： 每一个节点表示很多字符串，这些字符串按长度排序后每一个都是前一个加一个前缀字符，因此字符串长度是一个区间 所有这些字符串的结尾位置的集合就是end_pos 某个节点的end_pos是他的父节点的end_pos的子集 每个节点代表的不同子串个数是$ max - min + 1 $ 每个节点匹配位置个数是end_pos大小，可由bfs求sz数组，每个点的sz是其子树的sz和，若为原串前缀则+1 拓扑排序用基数排序 DAG按字典序走可按字典序遍历子串 一个点的祖先所有字符串是他自己所有字符串的后缀 end_pos中的所有元素都可以匹配该节点代表的每一个子串 因此实际上每个节点可以匹配的所有子串（不同位置算多个）个数为$ |end_pos| * (max - min + 1) $ 后缀自动机其实也就是那几个用法，先写这些，以后慢慢加 树上倍增可以$O(logn)$快速定位到一个子串的位置 按字典序遍历DAG，可以按字典序遍历所有子串，适合离线询问等操作 经常dfs一趟求出end_pos大小（若不同位置算多次则初始为$max - min + 1$，否则初始为1），之后定位后方便计数]]></content>
      <categories>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4650 [Noi2016]优秀的拆分]]></title>
    <url>%2F2019%2F06%2F01%2FBZOJ4650-Noi2016-%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ4650 Solution感觉这道题的方法在SA里还是很常见的考虑枚举AA和BB的分界点，对答案的贡献是以当前为结尾的XX的个数和以当前为结束的XX的个数因此实际上要计算以每个字符开头的XX（两个相同字符串）的个数，同理也要算以他结尾的枚举X字符串的长度$len$，每隔长度$len$设一个关键点那么每一个XX一定过两个相邻的关键点枚举每一对相邻的关键点，考虑其可能对那些位置产生贡献（所谓对某个位置产生贡献就是所这个位置开头的XX字符串个数+1）请看下图，我们求出两个位置的最长公共前缀和最长公共后缀此时两者没有交点，也就是长度之和$\le len$，不可能产生贡献（因为总会每截断）但是下面这种情况两者有了交点，就会产生贡献两条橙色线都是可以产生的XX，在两者之间的每一条同样长度的字符串也是因此紫色的那一段向后的XX会$+1$，棕色的那一段有向前的XX会$+1$区间加一可以直接差分至于LCP和LCS就是后缀数组的常见操作了，前后要构造两个 1.枚举 $len$ ，每隔 $len$ 设置关键点：这个的复杂度是调和级数 $O(n \log n)$2.求 后缀LCP，前缀LCS：使用后缀数组 + st 表 做到 $O(1)$ 查询3.区间加上 1 ： 差分维护就可以了。 记住这个方法，我叫他“调和级数法” Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300010;char s[maxn];int sa[2][maxn], t1[maxn], t2[maxn], h[2][maxn], rnk[2][maxn], c[maxn], f[2][maxn][30], lg2[maxn], n;int st[maxn], ed[maxn];void build(int m, int w) &#123; int *x = t1, *y = t2; for(int i = 0; i &lt;= m; i++) c[i] = 0; for(int i = 1; i &lt;= n; i++) c[x[i] = s[i]]++; for(int i = 1; i &lt;= m; i++) c[i] += c[i-1]; for(int i = n; i; i--) sa[w][c[x[i]]--] = i; for(int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for(int i = 0; i &lt;= m; i++) c[i] = 0; for(int i = n - k + 1; i &lt;= n; i++) y[++p] = i; for(int i = 1; i &lt;= n; i++) if(sa[w][i] &gt; k) y[++p] = sa[w][i] - k; for(int i = 1; i &lt;= n; i++) c[x[y[i]]]++; for(int i = 1; i &lt;= m; i++) c[i] += c[i-1]; for(int i = n; i; i--) sa[w][c[x[y[i]]]--] = y[i]; swap(x, y); p = 1; x[sa[w][1]] = 1; for(int i = 2; i &lt;= n; i++) x[sa[w][i]] = y[sa[w][i]] == y[sa[w][i-1]] &amp;&amp; y[sa[w][i] + k] == y[sa[w][i-1] + k] ? p : ++p; if(p &gt; n) break; m = p; &#125; for(int i = 1; i &lt;= n; i++) rnk[w][sa[w][i]] = i; for(int i = 1, k = 0; i &lt;= n; i++) &#123; if(k) k--; if(rnk[w][i] == 1) continue; int j = sa[w][rnk[w][i] - 1]; while(s[i + k] == s[j + k]) k++; h[w][rnk[w][i]] = k; &#125; for(int i = 1; i &lt;= n; i++) f[w][i][0] = h[w][i]; for(int k = 1; k &lt;= 20; k++) for(int i = 1; i + (1 &lt;&lt; k) - 1 &lt;= n; i++) f[w][i][k] = min(f[w][i][k-1], f[w][i + (1 &lt;&lt; (k-1))][k-1]);&#125;int calc(int w, int l, int r) &#123; l = rnk[w][l]; r = rnk[w][r]; if(l &gt; r) swap(l, r); //if(w == 0) cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; l++; int k = lg2[r - l + 1]; return min(f[w][l][k], f[w][r - (1 &lt;&lt; k) + 1][k]);&#125;int main() &#123; //freopen("testdata.in", "r", stdin); //freopen("testdata.ans", "w", stdout); int T; scanf("%d", &amp;T); lg2[2] = 1; for(int i = 3; i &lt;= 300000; i++) lg2[i] = lg2[i &gt;&gt; 1] + 1; while(T--) &#123; memset(sa, 0, sizeof(sa)); memset(h, 0, sizeof(h)); memset(f, 0, sizeof(f)); memset(st, 0, sizeof(st)); memset(ed, 0, sizeof(ed)); memset(t1, 0, sizeof(t1)); memset(t2, 0, sizeof(t2)); memset(rnk, 0, sizeof(rnk)); scanf("%s", s + 1); n = strlen(s + 1); build(128, 0); reverse(s + 1, s + 1 + n); build(128, 1); //for(int i = 1; i &lt;= n; i++) cout &lt;&lt; sa[0][i] &lt;&lt; ' '; cout &lt;&lt; endl; //for(int i = 1; i &lt;= n; i++) cout &lt;&lt; rnk[0][i] &lt;&lt; ' '; cout &lt;&lt; endl; for(int len = 1; len + len &lt;= n; len++) &#123; for(int i = 1; (i + 1) * len &lt;= n; i++) &#123; int x = i * len, y = x + len; int tail = calc(0, x, y), head = calc(1, n + 1 - x, n + 1 - y); if(head + tail - 1 &lt; len) continue; tail = min(tail, len); head = min(head, len); //printf("%d %d %d %d\n", x, y, head, tail); st[x - head + 1]++; st[x + tail - len + 1]--; ed[y - head + len]++; ed[y + tail]--; &#125; &#125; for(int i = 1; i &lt;= n; i++) st[i] += st[i-1], ed[i] += ed[i-1]; //for(int i = 1; i &lt;= n; i++) cout &lt;&lt; st[i] &lt;&lt; ' '; cout &lt;&lt; endl; //for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ed[i] &lt;&lt; ' '; cout &lt;&lt; endl; long long ans = 0; for(int i = 3; i &lt; n; i++) ans += st[i] * ed[i - 1]; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>后缀数组</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>调和级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1563 [Noi2009]诗人小G]]></title>
    <url>%2F2019%2F05%2F27%2FBZOJ1563-Noi2009-%E8%AF%97%E4%BA%BA%E5%B0%8FG%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ1563 Solutiondp转移方程$$f[i] = min_{j=0}^{i-1}{ f[j] + | s[i] - s[j] - 1 - L | ^ p }$$其中$ s[i] = i + \sum_{j=1}^{i}len[j] $采取了别人说的暴力打表法，发现确实具有决策单调性证明？我不会。因此以后见到这种1D1D的dp方程先写出来暴力，然后打表决策看有无单调性，没有的话一定是斜率优化了每一时刻，所有位置对应的决策形成的数列一定是单调不减的，就是下面的样子111111111111111111222222231111333344555这个数列在每次计算出新的位置后会更新，之后下一个位置的决策实际上就确定了，更新的时候仍会保持单调性具体实现可以使用单调队列配二分每一个决策是一个区间，新的可能出现的决策会把队尾的区间弹掉当队尾的区间无法弹掉后，使用二分确定在哪个位置之前是可以保留的，剩下的仍要更新最后把当前决策补到队尾下一轮的队首就是最终决策同时及时把队首无用的决策区间弹掉 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;typedef long double ld;ld f[maxn];int n, L, p, s[maxn], cho[maxn], las[maxn];char str[maxn][35];struct Inter&#123; int l, r, x; Inter(int l = 0, int r = 0, int x = 0) : l(l), r(r), x(x) &#123;&#125;&#125;q[maxn];ld Power(int x, int pp) &#123; ld res = 1; while(pp--) res *= x; return res;&#125;ld calc(int j, int i) &#123; return f[j] + Power(abs(s[i] - s[j] - 1 - L), p);&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d%d%d", &amp;n, &amp;L, &amp;p); memset(las, 0, sizeof(las)); memset(cho, 0, sizeof(cho)); for(int i = 1; i &lt;= n; i++) scanf("%s", str[i]), s[i] = strlen(str[i]); for(int i = 1; i &lt;= n; i++) s[i] += s[i-1] + 1; q[1] = Inter(1, n, 0); int head = 1, tail = 1; for(int i = 1; i &lt;= n; i++) &#123; las[i] = q[head].x; f[i] = calc(las[i], i); //cout &lt;&lt; head &lt;&lt; ' ' &lt;&lt; tail &lt;&lt; endl; //cout &lt;&lt; calc(q[tail].x, q[tail].l) &lt;&lt; ' ' &lt;&lt; calc(i, q[tail].l) &lt;&lt; endl; while(head &lt;= tail &amp;&amp; calc(q[tail].x, q[tail].l) &gt; calc(i, q[tail].l)) tail--; if(head &gt; tail) &#123; q[++tail] = Inter(i + 1, n, i); continue; &#125; int l = q[tail].l, r = q[tail].r + 1, x = q[tail].x; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(calc(x, mid) &gt; calc(i, mid)) r = mid; else l = mid + 1; &#125; l = q[tail].l; q[tail] = Inter(l, r - 1, x); if(r &lt;= n) q[++tail] = Inter(r, n, i); while(head &lt;= tail &amp;&amp; q[head].r &lt;= i) head++; //for(int i = head; i &lt;= tail; i++) cout &lt;&lt; q[i].l &lt;&lt; ' ' &lt;&lt; q[i].r &lt;&lt; ' ' &lt;&lt; q[i].x &lt;&lt; endl; &#125; for(int i = n; i; i = las[i]) cho[las[i]] = i; if(f[n] &gt; 1e18) printf("Too hard to arrange\n"); else &#123; printf("%.0LF\n", f[n]); for(int i = 0; i &lt; n; i = cho[i]) for(int j = i + 1; j &lt;= cho[i]; j++) printf("%s%c", str[j], j == cho[i] ? '\n' : ' '); &#125; printf("--------------------\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>决策单调性优化</category>
      </categories>
      <tags>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1002 轮状病毒]]></title>
    <url>%2F2019%2F02%2F03%2FBZOJ1002-%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ1002 Solution组合数学，要么递推，要么通项公式本题可以求出一个类递推式 用一个类似dp的方法。考虑分配周围这个圆的联通，就是一个线性dp了，过程中考虑和中间点的联通。令$f[i]$表示考虑了圆上的前i个的方案数$$f[i] = \sum_{j=1}^if[i-j]\times j$$但这相当于把环拆成了链，还要考虑1和n连接的情况。如果有j个周围的点连成一条，且跨越了1和n，我们将所有这样的情况累加到答案中去。考虑如果这样的点有j个，剩下的点肯定不与这j个点相连，所以连边方案数就是$f[i-j]​$，这j个点有$(j-1)​$种选法(跨越1和n)，与中心点连边的方案数是j。设这种情况为$g[i]$$$g[i] = \sum_{j=2}^if[i-j]\times j\times (j-1)$$ 剩下的就是高精了，建一个结构体，写一个加法和乘法。 但这道题让我感受到了常数的力量。 最开始我写了一个+=，写了一个*，乘法会返回一个大整数类型，加等于就直接穿引用修改。这样在洛谷上94ms过。但BZOJ上TLE了（时限1000ms）。。。 于是我不得不常数优化。把乘法改成乘等于，所有运算都是传引用，避免了频繁的复制操作。结果洛谷上76ms，看起来没差多少然而，BZOJ上108ms成功AC。。。 BZOJ是有毒吧，或者还是洛谷有毒？ 所以告诉我们写高精是注意能引用就引用，尽量不要复制，常数很大的。 还有就是乘法运算进位不能直接加上去，要用一个变量先存一下，这个调了很久。（太菜了） 其实这个做法可以用差分序列来优化，复杂度小一些，也不用写乘法了，但我最后卡常成功（暗笑，冷笑） Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std; struct bigint&#123; int n[10010], len; &#125;f[110], g[110], ans, tmp; void print(bigint &amp;a) &#123; for(int i = a.len - 1; i &gt;= 0; i--) printf("%d", a.n[i]); printf("\n");&#125; void operator += (bigint &amp;a, bigint &amp;b) &#123; a.len = max(a.len, b.len); for(int i = 0; i &lt; a.len; i++) a.n[i] += b.n[i], a.n[i+1] += a.n[i] / 10, a.n[i] %= 10; while(a.n[a.len]) a.len++;&#125; void operator *= (bigint &amp;a, int b) &#123; int x = 0; for(int i = 0; i &lt; a.len; i++) a.n[i] *= b, a.n[i] += x, x = a.n[i] / 10, a.n[i] %= 10; a.n[a.len] = x; while(a.n[a.len]) a.n[a.len + 1] += a.n[a.len] / 10, a.n[a.len] %= 10, a.len++;&#125; int main() &#123; int n; scanf("%d", &amp;n); f[0].n[0] = 1; f[0].len = 1; f[1].n[0] = 1; f[1].len = 1; for(int i = 2; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) tmp = f[i - j], tmp *= j, f[i] += tmp; //cout &lt;&lt; i &lt;&lt; ' '; print(f[i]); ans += f[n]; for(int j = 2; j &lt;= n; j++) tmp = f[n - j], tmp *= (j - 1) * j, ans += tmp; print(ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合</category>
      </categories>
      <tags>
        <tag>计数dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4698 Sandy的卡片]]></title>
    <url>%2F2019%2F02%2F02%2FBZOJ4698-Sandy%E7%9A%84%E5%8D%A1%E7%89%87%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ4698 Solution题目中说道相同的子串，也就提示我们用后缀数组了。（这是套路）把所有字符拼在一起，中间加一个不会出现的字符（这也是套路）两个子串差一个固定的数，我们可以使用差分，求出相邻两个字符串的差，就转化为很裸的字符串相等了。（这还是套路） 构建后缀数组和lcp，二分答案，假设当前判断x是否可行。从前向后扫描后缀数组，所有height大于等于x的后缀会把sa分成很多段。统计是否有一段出现了所有n个字符串。统计的过程中可以使用v数组加时间戳维护，先处理出每个字符属于n个字符串中的哪个，统计过程中每遇到一个新的段就tim++，v数组在每次check开始时清就可以了，这样可以保证时间复杂度为O(nlogn) 最后二分出来的相同长度+1就是答案，之所以要加一是因为前面差分时去掉了第一个。 注意点： 后缀数组的模板实在容易写错啊！！ 统计时开启新的一段要把当前位置的这个字符算在里面（包括cnt=1和维护v） 拼在一起时加的那个字符最好不一样，至于为什么我还没有搞清楚，但最开始我放一样的字符似乎总有问题 差分的时候为了防止负数出现，要一起加一个值，最好是所有字符的max值 总之就是一道很套路的题吧。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010, inf = 0x3f3f3f3f;int n, s[N], t1[N], t2[N], sa[N], height[N], rankk[N], len, c[N], v[N], bel[N];int a[1010][110], mm[1010], mx;void get_sa(int m) &#123; int *x = t1, *y = t2; for(int i = 0; i &lt; n; i++) c[x[i] = s[i]]++; for(int i = 1; i &lt;= m; i++) c[i] += c[i - 1]; for(int i = n - 1; i &gt;= 0; i--) sa[--c[x[i]]] = i; for(int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for(int i = n - k; i &lt; n; i++) y[p++] = i; for(int i = 0; i &lt; n; i++) if(sa[i] &gt;= k) y[p++] = sa[i] - k; for(int i = 0; i &lt;= m; i++) c[i] = 0; for(int i = 0; i &lt; n; i++) c[x[y[i]]]++; for(int i = 1; i &lt;= m; i++) c[i] += c[i - 1]; for(int i = n - 1; i &gt;= 0; i--) sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for(int i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i]] == y[sa[i-1]] &amp;&amp; y[sa[i] + k] == y[sa[i-1] + k] ? p - 1 : p++; if(p &gt;= n) break; m = p; &#125; &#125;void get_height()&#123; for(int i = 0; i &lt; n; i++) rankk[sa[i]] = i; int k = 0; for(int i = 0; i &lt; n; i++)&#123; if(!rankk[i]) continue; if(k) k--; int j = sa[rankk[i] - 1]; while(s[i + k] == s[j + k]) k++; height[rankk[i]] = k; &#125;&#125;bool check(int x) &#123; memset(v, 0, sizeof(v)); int tim = 1, cnt = 1; v[bel[sa[0]]] = 1; for(int i = 1; i &lt; n; i++) &#123; if(height[i] &lt; x) &#123; if(cnt &gt;= len) return true; tim++; cnt = 1; v[bel[sa[i]]] = tim; continue; &#125; if(s[sa[i]] &gt; mx + mx) continue; if(tim != v[bel[sa[i]]]) cnt++; v[bel[sa[i]]] = tim; &#125; return false;&#125;int main() &#123; int l = 0, r = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;mm[i]); r = max(r, mm[i]); for(int j = 1; j &lt;= mm[i]; j++) scanf("%d", &amp;a[i][j]), mx = max(mx, a[i][j]); &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 2; j &lt;= mm[i]; j++) bel[len] = i, s[len++] = a[i][j] - a[i][j-1] + mx; s[len++] = mx + i + mx; &#125; swap(n, len); get_sa(mx + len + mx + 2); get_height(); while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(check(mid)) l = mid; else r = mid - 1; &#125; cout &lt;&lt; l + 1 &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>后缀数组</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSOI冬令营D2 题]]></title>
    <url>%2F2019%2F01%2F28%2FJSOI%E5%86%AC%E4%BB%A4%E8%90%A5D2-%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这场比赛真是不难啊不难，但是我还是只会写暴力啊暴力~~~ T1 箱子 T2 准备 T3 回忆 T1 箱子考试时想了各种方法，什么dp、网络流、数据结构，总觉得昨天那么难，今天不可能只出一道贪心。结果谁知道，就是一道极水极水的小贪心。 $a \le b$ 的那部分显然按照a递增排序。 $a &gt; b$ 的部分按b递减排序。证明如下：假设$ b_x &gt; b_y $若x排在y的前面不合法，也就是$ sumV+b_x-a_x &lt; a_y $则易得$ sumV + b_y - a_y &lt; a_x $也就是说y排在x的前面也一定不合法。所以x排在前面一定不会更差。因此把b较大的x排在前面。 my代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;int read() &#123; int res = 0, f = 1; char c = getchar(); while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar(); if(c == '-') f = -1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + c - '0', c = getchar(); return f * res; &#125;int n;long long v;struct P&#123; int a, b; &#125;p[N];bool cmp(P x, P y) &#123; if(x.a &lt; x.b) if(y.a &lt; y.b) return x.a &lt; y.a; else return 1; else if(y.a &lt;= y.b) return 0; else return x.b &gt; y.b;&#125;int main() &#123; freopen("a.in", "r", stdin); freopen("a.out", "w", stdout); int T; T = read(); while(T--) &#123; n = read(); v = read(); int flag = 0; for(int i = 1; i &lt;= n; i++) p[i].a = read(), p[i].b = read(); sort(p + 1, p + 1 + n, cmp); for(int i = 1; i &lt;= n; i++) &#123; if(v - p[i].a &lt; 0) &#123; flag = 1; break; &#125; v -= p[i].a; v += p[i].b; &#125; if(flag) printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; T2 准备事实上这题我在考场上想到正解了，只是最后没有调出来而已。后来发现有一个地方写错了一个字母。唉~。 考虑用已经计算过的答案得到下一次的答案，也就是维护。容易看出，只要知道每一次有多少个负数就可以$ O(1) $转移了。 而每一次有多少个负数实际上是内定了的，也就是根据$ a[i] $可以预处理出来。考虑每个$ a[i] $对他的贡献，也就是这个a何时会变成负的。所有这样的时刻都是区间，可以用差分实现。 代码实现时要注意差分的位置，我第一也在这个地方晕了。其他没有什么难的。关键注意从不同角度思考问题吧。 my代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4000020, inf = 0x3f3f3f3f;typedef long long ll;ll read() &#123; ll res = 0, f = 1; char c = getchar(); while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar(); if(c == '-') f = -1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + c - '0', c = getchar(); return f * res; &#125;ll a[N+N], n, ans = 1e16;ll s[N+N], b[N+N], res;int main() &#123; freopen("b.in", "r", stdin); freopen("b.out", "w", stdout); n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); for(int i = 1; i &lt;= n; i++) if(a[i] &lt; i) s[1]++, s[i+1-a[i]]--; for(int i = 1; i &lt;= n; i++) s[i+1]++, s[i + n - a[i] + 1]--; for(int i = 1; i &lt;= n; i++) b[i] = b[i-1] + s[i];// for(int i = 1; i &lt;= n; i++) cout &lt;&lt; b[i] &lt;&lt; ' '; cout &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) res += abs(a[i] - i); ans = min(ans, res); for(int i = 2; i &lt;= n; i++) &#123; res -= b[i-1]; res += n - b[i-1]; res -= a[i-1]; res += abs(a[i-1] - n); ans = min(ans, res); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; T3 回忆其实我考试时也想到用线段树维护了，但但但，没有想到只要单点修改就可以。 我感觉这题就巧妙在这里，我们很容易想到用两个线段树分别维护$ l[i] - r[i] $和$ l[i] + r[i] $，但在哪些点上维护？有在哪个区间查询？ 我们按l从小到大处理每个区间，把每个已处理过的区间的右端点在线段树上单点更新。查询时，不包含情况是查询$ [l,r] $，包含的情况查询$ [r, +\infty] $，这真巧妙，非常棒地区分了两种情况，还十分简洁。以后要记住这种方法。 细节部分脑补一下就可以了，别忘了离散化。 my代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010, inf = 1e9;int read() &#123; int res = 0, f = 1; char c = getchar(); while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar(); if(c == '-') f = -1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + c - '0', c = getchar(); return f * res; &#125;int n, ans, refl[N+N], num;struct intv&#123; int l, r; &#125;p[N];bool cmp(intv x, intv y) &#123; return x.l == y.l ? x.r &gt; y.r : x.l &lt; y.l; &#125;int tr1[N*40], tr2[N*40];void build(int *tr, int p, int l, int r) &#123; tr[p] = inf; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(tr, p*2, l, mid); build(tr, p*2+1, mid + 1, r);&#125;void change(int *tr, int p, int l, int r, int pos, int x) &#123; tr[p] = min(tr[p], x); if(l == r) return; int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) change(tr, p*2, l, mid, pos, x); if(pos &gt; mid) change(tr, p*2+1, mid + 1, r, pos, x);&#125;int query(int *tr, int p, int l, int r, int L, int R) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return tr[p]; int mid = (l + r) &gt;&gt; 1, res = inf; if(L &lt;= mid) res = min(res, query(tr, p*2, l, mid, L, R)); if(R &gt; mid) res = min(res, query(tr, p*2+1, mid + 1, r, L, R)); return res;&#125;int main() &#123; freopen("c.in", "r", stdin); freopen("c.out", "w", stdout); n = read(); int tmp; for(int i = 1; i &lt;= n; i++) p[i].l = read(), p[i].r = read(), refl[++num] = p[i].l, refl[++num] = p[i].r; sort(p + 1, p + 1 + n, cmp); sort(refl + 1, refl + 1 + num); num = unique(refl + 1, refl + 1 + num) - refl - 1; for(int i = 1; i &lt;= n; i++) p[i].l = lower_bound(refl + 1, refl + 1 + num, p[i].l) - refl, p[i].r = lower_bound(refl + 1, refl + 1 + num, p[i].r) - refl; build(tr1, 1, 1, num); build(tr2, 1, 1, num); for(int i = 1; i &lt;= n; i++) &#123; tmp = query(tr1, 1, 1, num, p[i].l, p[i].r); ans = max(ans, refl[p[i].r] + refl[p[i].l] - tmp); tmp = query(tr2, 1, 1, num, p[i].r, num); ans = max(ans, refl[p[i].l] - refl[p[i].r] - tmp); change(tr1, 1, 1, num, p[i].r, refl[p[i].l] + refl[p[i].r]); change(tr2, 1, 1, num, p[i].r, refl[p[i].l] - refl[p[i].r]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 明天再接再厉，不信做不出来水题。]]></content>
      <categories>
        <category>集训</category>
      </categories>
      <tags>
        <tag>搞</tag>
        <tag>线段树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSOI冬令营D1 题]]></title>
    <url>%2F2019%2F01%2F28%2FJSOI%E5%86%AC%E4%BB%A4%E8%90%A5D1-%E9%A2%98%2F</url>
    <content type="text"><![CDATA[T1 小L的占卜 T2 小F的星术 T3 小X的咒语 T1 小L的占卜首先发现，T = 1时，问的就是区间异或和，因为偶数个数的异或和为0，剩下的只是奇数了。 当T = 2时，可以求出区间内所有出现过的数的异或和（每种数只算一次），然后异或掉区间异或和就可以了。那么考虑怎么每种数只算一次。考虑离线操作。把所有的操作按照左端点排序。先把每种数第一次出现的位置在树状数组上使能（也就是异或这个位置的数），然后从前往后扫描每一个询问，L向后推移，把L之前的数在树状数组上的贡献去掉，同时使能它下一次出现的位置。查询R的前缀异或和就可以了。 听说这是一个很套路的方法，但我真不会套路啊，学习了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;int read() &#123; int res = 0, f = 0; char c = getchar(); while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar(); if(c == '-') f = 1, c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + c - '0', c = getchar(); return f ? -res : res; &#125;int n, m, s[N], a[N], tmp[N], c[N], ans[N], p[N], num, na[N];int nxt[N], v[N];void add(int p) &#123; if(!p) return; for(int x = p; p &lt;= n; p += p&amp;-p) c[p] ^= a[x];&#125;int query(int p) &#123; int res = 0; for(; p; p -= p&amp;-p) res ^= c[p]; return res;&#125;struct Q&#123; int i, l, r, t; &#125;q[N];bool cmp(Q x, Q y) &#123; return x.l &lt; y.l; &#125;int main() &#123; freopen("augury.in", "r", stdin); freopen("augury.out", "w", stdout); int kase; kase = read(); n = read(), m = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(), p[++num] = a[i]; sort(p + 1, p + 1 + num); num = unique(p + 1, p + 1 + num) - p - 1; for(int i = 1; i &lt;= n; i++) na[i] = lower_bound(p + 1, p + 1 + num, a[i]) - p; for(int i = 1; i &lt;= n; i++) s[i] = s[i-1] ^ a[i]; for(int i = 1; i &lt;= m; i++) q[i].l = read(), q[i].r = read(), q[i].t = read(), q[i].i = i; sort(q + 1, q + 1 + m, cmp); for(int i = 1; i &lt;= n; i++) &#123; if(!v[na[i]]) add(i), v[na[i]] = i; else nxt[v[na[i]]] = i, v[na[i]] = i; &#125; int ll = 1; for(int i = 1; i &lt;= m; i++) &#123; while(ll &lt; q[i].l) add(ll), add(nxt[ll]), ll++; ans[q[i].i] = s[q[i].r] ^ s[q[i].l - 1]; if(q[i].t == 1) ans[q[i].i] ^= query(q[i].r); &#125; for(int i = 1; i &lt;= m; i++) printf("%d\n", ans[i]); return 0;&#125; T2 小F的星术数学期望 + 树形dp，我们都知道，但怎么做呢，我连链的情况都没写出来~。 要先想到$$E(x) = P(x\ge 1) + P(x\ge 2) + P(x\ge 3) + …$$其中x为正整数。 也就是说，我们只要求出找到K条不相交路径的方案数，把他们加起来，在乘以$ \frac{n(n+1)}2 $的逆元就可以了。 这个和第二天讲的一道树形dp题一样。用$ dp[i][j][0/1/2] $表示以i为根的子树，j条路径，i不取、i取且路径未结束、i取且路径无法向上延伸的方案数。 然后考虑状态转移，假设我们当前处于pos节点的儿子x处，dp[pos]记录的是x之前的信息，我们要把x的信息也合并进去。分类讨论。 这里情况比较繁琐，我看了很久才看懂标程，就不重新写一遍了，直接贴标程如下，转移写的很清楚:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 5005;const int P = 998244353;typedef long long ll;typedef long double ld;typedef unsigned long long ull;template &lt;typename T&gt; void chkmax(T &amp;x, T y) &#123;x = max(x, y); &#125;template &lt;typename T&gt; void chkmin(T &amp;x, T y) &#123;x = min(x, y); &#125; template &lt;typename T&gt; void read(T &amp;x) &#123; x = 0; int f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = -f; for (; isdigit(c); c = getchar()) x = x * 10 + c - '0'; x *= f;&#125;template &lt;typename T&gt; void write(T x) &#123; if (x &lt; 0) x = -x, putchar('-'); if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;template &lt;typename T&gt; void writeln(T x) &#123; write(x); puts("");&#125;int n, sz[MAXN], dp[MAXN][MAXN][3];vector &lt;int&gt; a[MAXN];void update(int &amp;x, int y) &#123; x += y; if (x &gt;= P) x -= P;&#125;void work(int pos, int fa) &#123; sz[pos] = 1; dp[pos][1][0] = dp[pos][0][2] = 1; for (auto x : a[pos]) if (x != fa) &#123; work(x, pos); static int res[MAXN][3]; for (int i = 1; i &lt;= sz[pos] + sz[x]; i++) res[i][0] = res[i][1] = res[i][2] = 0; for (int i = 0; i &lt;= sz[pos]; i++) for (int j = 0; j &lt;= sz[x]; j++) &#123; update(res[i + j][0], 1ll * dp[pos][i][0] * dp[x][j][0] % P); if (i + j) update(res[i + j - 1][1], 1ll * dp[pos][i][0] * dp[x][j][0] % P); update(res[i + j][0], 1ll * dp[pos][i][0] * dp[x][j][1] % P); if (i + j) update(res[i + j - 1][1], 1ll * dp[pos][i][0] * dp[x][j][1] % P); update(res[i + j][0], 1ll * dp[pos][i][0] * dp[x][j][2] % P); update(res[i + j][1], 1ll * dp[pos][i][1] * dp[x][j][0] % P); if (i + j) update(res[i + j - 1][2], 1ll * dp[pos][i][1] * dp[x][j][0] % P); update(res[i + j][1], 1ll * dp[pos][i][1] * dp[x][j][1] % P); if (i + j) update(res[i + j - 1][2], 1ll * dp[pos][i][1] * dp[x][j][1] % P); update(res[i + j][1], 1ll * dp[pos][i][1] * dp[x][j][2] % P); update(res[i + j][2], 1ll * dp[pos][i][2] * dp[x][j][0] % P); update(res[i + j][2], 1ll * dp[pos][i][2] * dp[x][j][1] % P); update(res[i + j][2], 1ll * dp[pos][i][2] * dp[x][j][2] % P); &#125; for (int i = 1; i &lt;= sz[pos] + sz[x]; i++) &#123; dp[pos][i][0] = res[i][0]; dp[pos][i][1] = res[i][1]; dp[pos][i][2] = res[i][2]; &#125; sz[pos] += sz[x]; &#125;&#125;int power(int x, int y) &#123; if (y == 0) return 1; int tmp = power(x, y / 2); if (y % 2 == 0) return 1ll * tmp * tmp % P; else return 1ll * tmp * tmp % P * x % P;&#125;int main() &#123; freopen("astrology.in", "r", stdin); freopen("astrology.out", "w", stdout); int num; read(num); read(n); for (int i = 1; i &lt;= n - 1; i++) &#123; int x, y; read(x), read(y); a[x].push_back(y); a[y].push_back(x); &#125; work(1, 0); int ans = 1, tot = ((dp[1][1][1] + dp[1][1][2]) % P + dp[1][1][0]) % P; int fac = 1, frac = 1; for (int i = 1; i &lt;= n; i++) &#123; fac = 1ll * fac * i % P; frac = 1ll * frac * tot % P; int now = ((dp[1][i][1] + dp[1][i][2]) % P + dp[1][i][0]) % P; update(ans, 1ll * now * fac % P * power(frac, P - 2) % P); &#125; writeln(ans); return 0;&#125; T3 小X的咒语组合数学毒瘤题，推公式，要能够清晰地运用容斥原理，很难了。 my proud code:1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 510;ll c[N][N], fac[N+N], rev[N], p, n, ans;int main() &#123; freopen("abracadabra.in", "r", stdin); freopen("abracadabra.out", "w", stdout); int kase; scanf("%d", &amp;kase); scanf("%lld%lld", &amp;n, &amp;p); fac[0] = 1; for(int i = 1; i &lt;= n + n; i++) fac[i] = fac[i-1] * i % p; for(int i = 0; i &lt;= n; i++) c[i][0] = 1; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) c[i][j] = (c[i-1][j-1] + c[i-1][j]) % p; rev[0] = 1; rev[1] = (p + 1) / 2; for(int i = 2; i &lt;= n; i++) rev[i] = rev[i-1] * rev[1] % p; for(int j = 0; j &lt;= n; j++) for(int k = 0; k + j &lt;= n; k++) for(int i = 0; i + j + k &lt;= n; i++) &#123; ll tmp = c[n][j] * c[n-j][k] % p * c[n-j-k][i] % p * c[j+k][j] % p * rev[j+k] % p * rev[k] % p * fac[j] % p * fac[2*k+i] % p; if((i + j) % 2 == 0) ans = (ans + tmp) % p; else ans = (ans + tmp * (p-1) % p) % p; // cout &lt;&lt; ans &lt;&lt; endl; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>集训</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>树形dp</tag>
        <tag>搞</tag>
        <tag>组合数学</tag>
        <tag>数学期望</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSOI冬令营D2 课]]></title>
    <url>%2F2019%2F01%2F28%2FJSOI%E5%86%AC%E4%BB%A4%E8%90%A5D2-%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[树形动态规划一些关于树和dp的题，比较有难度，请谨慎 给定一个图G，求两点之间最短距离的最大值G是普通图G是树G是基环树 基环树情况：先不考虑环，每一棵树求一个到根的最长路径。这棵树就没用了。然后把环拆成链，单调队列维护dp就可以。 给定一棵树T，求k条不想交的路径的方案数（点构成的路径） k = 2：考虑树上的一条链有一个lca，这两条链的lca会有一个lca。如果他们位于大lca的不同子树，则求出每个子树的大小，答案贡献为$\sum_{u\not =v}C_{u+1}^2C_{v+1}^2$其中u、v为两棵子树，但这样需要$ O(n^2) $枚举，太慢了，变形为$(\sum_uC_{u+1}^2)^2-\sum_u(C_{u+1}^2)^2$这样就可以$ O(n) $了如果大lca就是其中一点，枚举另一点位置，另外一条链在这棵树剩下部分（也就是砍掉那棵子树），用组合数算就可以了。 k 任意用$dp[i][j][0/1/2]$表示以i为根的子树，j条链，i取且其链继续向上扩展、i取但这条链已结束、i不取的方案数。树形+背包dp状态转移尚未搞懂，回头再说 给定一棵数，求最小点覆盖 $ dp[i][0/1] $表示以i为根子树，i去或不取的最小点覆盖。$ dp[i][0] = \sum_{fa[j] = i}dp[j][1] $$ dp[i][1] = \sum_{fa[j] = i}max(dp[j][0], dp[j][1]) $ 给定一棵树T，求所有简单路径边权积的和取模SPOJ MTREE $ f[i] $表示从i往下的链积的和。可以维护出来$ f[i] $然后枚举lca，求出$ \sum_{x\not=y}f[x] w_x f[y] * w[y] $，x、y为lca的子树，化简同上。 给定一个树T，在T上寻找两条严格不想交的路径，使其长度之积最大，求这个积。SPOJ TWOPATHS 分两种情况 一条路径就是直径，另一条是其他路径中最大的 两条路径都只包含直径的一部分，枚举直径上相邻的两个点即可 给定一棵树T，在T上先去掉一条边，再加上一条树边，重新构成一棵树T’，要使T’的直径最小，求一种方案。SPOJ treecst 加边时一定是加在两棵树直径的中点上。从根开始dfs枚举砍掉的边，维护两个直径，更新答案。 给定一棵树T，以及起点X终点Y，T上每一个节点都以给定的概率向其相邻的节点走，允许重复经过同一个点，求从X到Y的期望步数。SPOJ GS 以Y为根。令$ f[i] $表示从i走到i的父亲的期望步数，$ p_i $表示i走向父亲的概率，$ p_{ij} $表示i走向第j个儿子的概率。$ f[i] = p_i * 1 + \sum_{j=1}^kp_{ij}(1+f[son[i][j]] + f[i]) $ ，其中k为i的子树个数。这事实上是一个方程，$ f[i] $为未知数，其他都是已求或已知的常量。手动求解即可。 给定一棵树或者基环树，以相等的概率选择一个起点，每一步等概率地走向未经过得点，求期望的移动步数PS:给定的基环树中，环长不超过20NOI2012 Day2 T1 迷失游乐园 $ up[i] $表示从i向上走的期望步数。$ down[i] $表示从i向下走的期望步数。一遍dfs可以求出down，再一遍求出up，树的情况解决了。 基环树时，先对每个数向上面一样求down。预处理出$ p[i][j][0/1] $表示从i顺/逆时针到j的概率。之后dfs统计up，计算答案。 给定一棵带权无根树T，先选一点作为树根，然后每一步操作可以任选一点u，将树边$ (u,fa(u)), (fa(u), fa(fa(u))) $一起覆盖。同时，所有操作要满足，每条树边只被覆盖至多一次，求所有被覆盖的树边总长度的最大值。APIO2014 T3 连珠线 $ dp[i][0/1] $表示以i为根的子树，i是不是中间点，最大被覆盖边权任选一个根，$ O(n) $求出所有dp值然后考虑换根，选当前根的一个儿子作为新的根，对dp数组进行维护，可以$ O(1) $做到，多记录一些信息，和之前的转移是一样的。取最大值即可。]]></content>
      <categories>
        <category>集训</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学整理集锦]]></title>
    <url>%2F2019%2F01%2F23%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[排列的生成 按字典序思想生成下一个排列 排列和组合的计数 基本组合恒等式 两种特殊的排列组合技术公式 Catalan数 公式 应用 操练 Bell数 Stirling数 多重集的排列组合 多重集的排列 多重集的组合 容斥原理与鸽笼原理 鸽笼原理 容斥原理 计算并集元素个数 计算错排的方案数 Ramsey定理 Ramsey数 波利亚定理 定义们 Bornside引理 波利亚定理 递推与生成函数 k阶常系数线性齐次递推关系 生成函数 排列的生成按字典序思想生成下一个排列设当前序列为$ (p) = p_1p_2p_3…p_n $，按字典序思想生成下一个排列方法如下： 从右向左，计算最后一个増序的尾元素的下标i，即$ i = max{j\ |\ p_{j-1} &lt; p_j,\ p_j \ge p_{j+1} } $ 从右向左找到$p_{i-1}$后面比$p_{i-1}$大的最后一个元素的下标j，即$j = max{ k\ |\ k \ge i,\ p_{i-1} &lt; p_k }$ 交换$p_{i-1}$与$p_j$，得到$p_1…p_{i-2}p_jp_ip_{i+1}…p_{j-1}p_{i-1}p_{j+1}…p_n$ 翻转新的$p_j$后面的元素，使其递增（也就是说原来是递减的），得到$p_1…p_{i-2}p_jp_n…p_{j+1}p_{i-1}p_{j-1}…p_{i+1}p_i$ 原理想想就明白啦，下面有一道题： POJ1146 ID Codes 就是一道很裸的题，直接来代码：12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;using namespace std;char str[100];int len;int main() &#123; while(scanf("%s", str) &amp;&amp; strcmp(str, "#")) &#123; len = strlen(str); bool flag = 0; for(int i = len - 1; i; i--) &#123; if(str[i-1] &lt; str[i]) &#123; for(int j = len - 1; j &gt;= i; j--) if(str[i-1] &lt; str[j]) &#123; swap(str[i-1], str[j]); break; &#125; for(int j = i; j &lt;= len - (j - i + 1); j++) swap(str[j], str[len - (j - i + 1)]); puts(str); flag = 1; break; &#125; &#125; if(!flag) puts("No Successor"); &#125; return 0;&#125; 再说一句，要注意看清楚流程中的大于号和大于等于号，另外就是当找不到时代表已经找完了，这就是最后一个，算法结束。 排列和组合的计数基本组合恒等式$$\sum_{i=0}^{n} {n \choose i} = 2 ^ n $$$$ \sum_{i=0}^{n} {i \choose x} = {n+1 \choose x+1} $$$$ \sum_{i=0}^{n} {k+i \choose i} = {k+n+1 \choose n} $$$$ \sum_{i=0}^{m} {m \choose i} {n-m \choose m-i} = {n \choose m}$$ 两种特殊的排列组合技术公式Catalan数公式 Catalan数是序列｛C｝，其中 $ C_0=1,\ C_1=1,$$$C_n = C_0C_{n-1}+C_1C_{n-2}+…+C_{n-1}C_0,\ n\ge2. $$ 在定义中就已经给出了它最一般的递推式，下面还有几个计算是很常用的： 变形递推式$$ C_n = \frac{4n-2}{n+1}\times C_{n-1}, n &gt; 1 $$ 通项公式$$ C_n = \frac{C(2n, n)}{n+1}, n = 0, 1, 2… $$$$C_n=C(2n,n)-C(2n,n+1),n=0,1,2…$$ 酌情使用，方便为上要注意卡特兰数的下标从0开始，不要随意改，会出现意想不到的问题。 应用 由n个1和n个0构成2n项满足所有前缀中1比0多的序列个数等于第n个Catalan数。证明：我们先求出所有的序列，然后减去不合法的序列即是答案。所有序列个数直接根据组合数的定义为$C(n,2n)$，现在要证明满足存在一个结论中所说的序列与n+1个0与n-1个1构成的01序列构成一个双射，即11对应关系，因为很显然，后者的数量为$C(n−1,2n)$。对前者，很显然可以找到一个位置为$2p+1$的前缀，使得其中有$p+1$个1和$p$个0，好的我们把它取反，即得到了后者。对后者，同理。于是得到了上述第二个通项公式。&emsp; 我们可以将应用1变换形式：将1看成右括号，0看成左括号，就变成了左括号和右括号各有n个时，合法括号表达式的个数。比如2个左括号和2个右括号组成的合法表达式有种，是()()和(())。&emsp; n个节点构造二叉树的所有可能形态数为$C_n$。考虑随便取一个节点作为根，那么他左边和右边的儿子节点个数就确定了，假定根节点标号为x，那么左子树的标号就是从1到x-1,共x-1个，右子树的标号就是从x+1到n，共n-x个，那么将x从1取到n，就获得了所有的情况数。得到的为定义递推式。&emsp; n个非叶节点的满二叉树的形态数（对称后得到的二叉树除非自己本身对称，否则算是不同）。对于满二叉树，实际上就是将应用4中的每个子节点的空儿子上都加上叶子，就形成了对应的满二叉树，那么n个非叶节点形成的满二叉树的形态数即为$C_n$&emsp; 对于一个n*n的正方形网格，每次只能向右或者向上移动一格，那么从左下角到右上角所有在副对角线右下方的路径总数为$C_n$。可以将一条水平边记为+1,垂直边记为-1,那么就组成了一个n个+1和n个-1的序列，并且保证前k步中水平边数不小于垂直边数，换句话说前k个元素的和非负。&emsp; 对凸n+2边形进行不同的三角形分割（只连接顶点对形成n个三角形）数为$C_n$&emsp; n个数入栈后的出栈的排列总数是$C_n$。例如1,2,3入栈的出栈排序有123，132，213，231和321五种&emsp; n层的阶梯切割为n个矩形的切法数也是。如下图所示：考虑先绘制如下图片，即n为5的时候的阶梯：注意到每个切割出来的矩形都必需包括一块标示为*的小正方形，那么此时枚举每个*与#标示的两角作为矩形，剩下的两个小阶梯就是我们的两个更小的子问题了。 &emsp;事实上，从应用中我们也可以看到很多证明通项公式的方法。 操练给道题目吧： BZOJ2822: [AHOI2012]树屋阶梯 卡特兰数+高精度，比较裸，代码如下：12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 10000;int n, a[100000];void mul(int a[], int x)&#123; int &amp;l = a[0]; int left = 0; for(int i = 1; i &lt;= l; i++)&#123; a[i] = a[i] * x + left; left = a[i] / mod; a[i] = a[i] % mod; &#125; while(left) a[++l] = left % mod, left /= mod;&#125;void div(int a[], int x)&#123; int &amp;l = a[0]; int left = 0; for(int i = l; i; i--)&#123; a[i] += left * mod; left = a[i] % x; a[i] /= x; &#125; while(!a[l]) l--;&#125;void print(int a[])&#123; int l = a[0]; printf("%d", a[l]); for(int i = l - 1; i; i--) printf("%04d", a[i]); cout &lt;&lt; endl;&#125;int main()&#123; cin &gt;&gt; n; a[0] = a[1] = 1; for(int i = n + 1; i &lt;= 2 * n; i++) mul(a, i); for(int i = 1; i &lt;= n; i++) div(a, i); div(a, n + 1); print(a); return 0;&#125; Bell数 Bell数是集合的划分数，也是一个集合上的等价关系的数目；Bell数{B}, 其中$B_n$是包含n个元素的集合的划分方法的数目。显然，$B_0=1, B_1=1, B_2=2, B_3=5$$$B_{n+1} = \sum_{k=0}^nC(n, k)B_k $$ 很简单吧 Stirling数 第一类Stirling数是将n个不同元素放入m个环排列的数目。其中，$S(n, 0)=0,\ S(1,1)=1$$$S(n, m) = S(n-1, k-1) + (n-1)*S(n-1, m)$$ 生成函数:$$\begin{aligned}&amp; x^{\overline{n}} = \sum_{i=0}^{n} \begin{bmatrix} n \ i \end{bmatrix} x^i \&amp; x^{\underline{n}}= \sum_{i=0}^{n} (-1)^{n-i} \begin{bmatrix} n \ i \end{bmatrix} x^i\end{aligned}$$ 第二类Stirling数是将n个元素的集合划分为k个不为空的子集的方式的个数，其中$S(n, n) = S(n, 1) = 1 $$$S(n, m) = S(n-1, m-1) + k * S(n-1, m) $$ 生成函数: $$\begin{aligned}&amp; x^n = \sum_{i=0}^{n} {n \brace i} x^{\underline{i}} \&amp; m!{n \brace m} = \sum_{i=0}^{m} (-1)^{m-i} {m \choose i} i^n\end{aligned}$$ 多重集的排列组合 多重集是可重复出现的元素组成的集合。若多重集中不同元素个数为k，称该多重集为k元多重集。多重集中元素$a_i$出现的次数$n_i$称为元素$ai$的重数。若有限多重集S有$a_1, a_2, …, a_k$共k个不同元素，且ai的重数为ni，则S可记为：${ n_1•a_1, n_2•a_2, ……, n_k•a_k }$。 多重集的排列 设有限多重集$S={ n_1•a_1, n_2•a_2, …, n_k•a_k }$，且$n=n_1+n_2+ ……+n_k$，从S中有序选取r个元素称为S的一个r-排列$(r\le|S|=n)$，当$r=n$时，称为S的一个全排列。 从k元多重集$S= { \infty•a_1, \infty•a_2, …, \infty•a_k }$中有序选取r个元素我们也称为S的一个r-排列。 设k元多重集$S= { \infty•a_1, \infty•a_2, …, \infty•a_k }$，则S的r-排列数是$k^r$。 证明太简单，不写了。 多重集的组合 设多重集$S={ n_1•a_1, n_2•a_2, ……, n_k•a_k }$，（这里$n_i$可以是有限也可以是无限的）。S的含有r个元素的子多重集称为S的r-组合。 设k元多重集$S= { \infty•a_1, \infty•a_2, …, \infty•a_k }$，设$r\le n_i(\forall i \in [1, k])$则S的r-组合数是$$C_{k+r-1}^r$$ 证明：原问题等价于统计下列集合的数量：$ { x_1\cdot a_1, x_2\cdot a_2,…,x_k\cdot a_k } $，其中，$ \sum_{i=1}^k x_i = r $并且$x_i\le n_i$，故原问题等价于r个0，k-1个1构成的全排列数——k-1个1把r个0分成k组，每组的0的数量对应$x_i$。而多重集${ r\cdot 0, (k-1)\cdot 1 }$的全排列数为$$ \frac{(r+k-1)!}{r!(k-1)!} = C_{k+r-1}^r = C_{k+r-1}^{k-1} $$ 对于更为一般的r的情况，需要用到下面的容斥原理，之后再说，敬请期待。 容斥原理与鸽笼原理鸽笼原理 应用鸽笼原理解题的一般步骤： 分析题意，分清什么是“元素”，什么是“集合”；也就是说，什么可以作为“元素”，什么可以作为“集合”。 构造集合。这是关键的一步。根据题目条件和结论，结合有关的数学知识，抓住最基本的数量关系，设计和确定解决问题所需的集合及其个数，为应用鸽笼原理奠定基础。应用鸽笼原理解题。 有一道题目，比较巧妙，巧妙在思路上，代码并不复杂 POJ2356 Find a multiple 鸽笼原理主要还是在于能不能想得到，解决的题目往往令人惊叹，比如这一题，结合起算法中常用的前缀和，就非常非常巧妙。还是要灵活运用啊。 容斥原理 定义就是这样，开启我们的练习吧—— 计算并集元素个数 Ural 1091 Tmutarakan Exams (这是vjudge上的网址哦) AC代码：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int k, s, p[60];long long ans, c[60][60];bool judge(int x)&#123; for(int i = 2; i &lt;= s; i++) if(x % i == 0 &amp;&amp; !p[i] &amp;&amp; !p[x / i] &amp;&amp; i != x / i) return true; return false;&#125;int main() &#123; scanf("%d%d", &amp;k, &amp;s); for(int i = 0; i &lt;= s; i++) c[i][0] = 1; for(int i = 1; i &lt;= s; i++) for(int j = 1; j &lt;= k; j++) c[i][j] = c[i-1][j-1] + c[i-1][j]; p[0] = p[1] = 1; for(int i = 2; i &lt;= s; i++) if(!p[i]) for(int j = i + i; j &lt;= s; j += i) p[j] = 1; for(int i = 2; i &lt;= s; i++) &#123; if(!p[i]) &#123; ans += c[(s - i) / i + 1][k]; &#125; else if(judge(i)) ans -= c[(s - i) / i + 1][k]; &#125; cout &lt;&lt; min(ans, (long long)10000) &lt;&lt; endl; return 0;&#125; 下面是一道难一点的 ZOJ3638 Fruit Ninja 下面是我的不知为何没有AC的代码，segment falt，但样例至少是可以过得，一般这种时候我就认为它对了，总之贴出来吧（不过话说这题的输入格式好恶心啊）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 100000007;typedef long long ll;int n, m, gr, le[20], cnt, num[1 &lt;&lt; 20];ll c[10000100][20], ans;string str;char s[1000], tmp1[1000], ty[1000], tmp2[1000];int main() &#123; int x; for(int i = 1; i &lt; (1 &lt;&lt; 17); i++) for(int j = i; j; j -= j&amp;-j) num[i]++; for(int i = 0; i &lt;= 1e7+20; i++) c[i][0] = 1; for(int i = 1; i &lt;= 1e7+20; i++) for(int j = 1; j &lt;= 18; j++) c[i][j] = (c[i-1][j-1] + c[i-1][j]) % mod; while(scanf("%d%d", &amp;n, &amp;m) == 2 &amp;&amp; (n || m != 1)) &#123; ans = gr = cnt = 0; /*getchar(); while(1) &#123; getline(cin, str); strcpy(s, str.c_str()); if(!strcmp(s, "")) break; sscanf(s, "%s%s%s%d", tmp1, ty, tmp2, &amp;x); if(ty[0] == 'g') gr += x + 1; else if(ty[0] == 'l') le[cnt++] = x; &#125;*/ gets(s); while(1)&#123; if(!gets(s)) break; if(strlen(s) &lt; 2) break; sscanf(s,"%s %s %s %d",tmp1,ty,tmp2,&amp;x); if(ty[0] == 'g') gr += x + 1; else le[cnt++] = x; &#125; for(int i = 0; i &lt; (1 &lt;&lt; cnt); i++) &#123; int cur = 0; for(int j = 0; j &lt; cnt; j++) if(i &amp; (1 &lt;&lt; j)) cur += le[j]; if(n + m - gr - cur - 1 &gt;= 0) ans = (ans + 1ll * (num[i] % 2 == 0 ? 1 : -1) * c[n + m - gr - cur - 1][n - 1] % mod) % mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; &emsp;还记得在上面讲多重集的时候说，r任意的情况要使用容斥原理讨论吗，事实上，上一题已经利用了这一方法。这里再系统讲一下。 设多重集$ $。对于任意整数$ $，从S中取出r个元素组成一个多重集(不考虑顺序)，产生的不同的多重集的数量为$$ C_{k+r-1}^{k-1}- \sum_{i=1}^kC_{k+r-n_i-2}^{k-1} + \sum_{1\le i &lt; j \le k}C_{k+r-n_i-n_j-3}^{k-1} - …+(-1)^kC_{k+r-\sum_{i=1}^kn_i-(k+1)}^{k-1}$$ 证明：不考虑$n_i$的限制，从S中任选r个元素，相当于上一节讨论过的情况，方法数为$C_{k+r-1}^{k-1}$。设$S_i(1\le i\le k)$表示至少包含$n_i+1$个$a_i$的多重集。我们先从S中取出$n_i+1$个$a_i$，然后在任选$r-n_i-1$个元素，即可构成$S_i$。与上面同理，可以构成的不同的$S_i$的数量为$C_{k+r-n_i-2}^{k-1}$进一步地，先从S中取出$n_i+1$个$a_i$和$n_j+1$个$a_j$，然后在任选$r-n_i-n_j-2$个元素，即可构成$S_i\cap S_j$，方法数为$C_{k+r-n_i-n_j-3}^{k-1}$。根据容斥原理，至少有一种$a_i$选取的数量超过$n_i$限制的多重集共有：$$ \begin{vmatrix} \bigcup_{i=1}^kS_i\end{vmatrix} = \sum_{i=1}^kC_{k+r-n_i-2}^{k-1} - \sum_{1\le i &lt; j \le k}C_{k+r-n_i-n_j-3}^{k-1} + …-(-1)^kC_{k+r-\sum_{i=1}^kn_i-(k+1)}^{k-1} $$故所有满足限制的合法多重集个数即为上述结论。证毕。&emsp;总结一下：从上面的应用也可以发现，使用容斥原理时常常使用补集转换思想，先求出题目所要求的补集，它往往是很多子集的并集，可以用容斥原理轻松解决。在这个过程中，“至少”，“有”，“存在”等字眼应相当重视，往往涉及到思路是否清晰。 计算错排的方案数 递推法:设n个元素$a_1, a_2, …, a_n$，错排数目为$D_n$。任取其中一个元素，错排产生有两种情况：情况1：$a_i$与其它$n-1$个元素之一互换，其余$n-2$个元素错排。根据乘法原理，共产生$(n-1) D_{n-2}$个错排；情况2：$a_i$以外的$n-1$个元素先错排，然后$a——i$与其中每个元素互换。根据乘法原理，共产生$(n-1) D_{n-1}$个错排；使用加法原理综合上述情况，可得出递推式：$D_1=0；D_2=1；D_n=(n-1)(D_{n-2}+ D_{n-1})$，其中$n&gt;2$。注意：当$n$较大时，错排数可能会超过任何整数类型允许的范围。在这种情况下一般采用高精度运算，以避免数据溢出。 依旧一道水题练练手 UVA10497 Sweet Child Makes Trouble 错排裸题+高精，水题不解释，代码：123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;long long f[810][10010], n;int main() &#123; f[0][0] = 1; for(int i = 2; i &lt;= 800; i++) &#123; int x = 0; for(int j = 0; j &lt;= 10000; j++) f[i][j] += f[i-1][j] + f[i-2][j], f[i][j+1] += f[i][j] / 10000, f[i][j] %= 10000; for(int j = 0; j &lt;= 10000; j++) f[i][j] *= i - 1, f[i][j] += x, x = f[i][j] / 10000, f[i][j] %= 10000; &#125; while(scanf("%lld", &amp;n) == 1 &amp;&amp; n != -1) &#123; int i = 10000; while(!f[n][i] &amp;&amp; i) i--; printf("%lld", f[n][i--]); while(i &gt;= 0) printf("%04lld", f[n][i--]); printf("\n"); &#125; return 0;&#125; Ramsey定理 对于任何一个具有6个节点的简单图，要么它包含一个三角形，要么它的补图包含一个三角形。 证明：设6个节点的简单图为G。考察G中的任意一个节点a，那么，另外5个节点中的任何一个节点，要么在G中与a邻接，要么在G’（G的补图）中与a邻接。这样，就可以把5个节点分成两类：在G中与a邻接，或在G’中与a邻接。因此，根据鸽笼原理，必有一类至少含有3个节点，不妨假设其中的3个节点b, c, d与a邻接。如果b, c, d间有边相连，则命题成立；否则在补图中b, c, d任意两点间有边相连，命题成立。 Ramsey定理 6个人中至少存在3人相互认识或者相互不认识。 Ramsey数 对于正整数a和b，对应于一个整数r，使得r个人中或有a个人相互认识，或有b个人互不认识；或有a个人互不认识，或有b个人相互认识。这个数r的最小值用R(a, b)来表示。R(3, 3)=6。Ramsey数还有若干推论：R(3, 4)=9，R(4, 4)=18。 Ramsey数有如下性质。$R(a, b)= R(b, a)；R(a, 2)=2$。对任意的整数$a, b \ge 2$，$R(a, b)$存在。对任意的整数$a, b，R(a, b)\le R(a-1, b)+ R(a, b-1)$；如果$a, b \ge 2，且R(a-1, b)$和$R(a, b-1)$是偶数，则$$R(a, b)\le R(a-1, b)+ R(a, b-1)-1。R(a, b)\le C(a+b-2, a-1)。$$ 说了那么多，其实很简单的burnside引理： 所有置换写成循环节的形式每个循环节看成一样的，求出染色方案数把所有置换这样求出的方案数算平均数就好了 根据这一句话，所有类似问题都可以解决了，不用纠结定义，也不用背波利亚定理 波利亚定理终于写到这了，首先要介绍群论： 定义们群的定义 一个群是一个集合G和一个在集合G上被称为G的群法则的操作，这一操作将任意两个元素a和b合成为一个新元素，标志为a * b或ab。(G, *)满足下述4个条件。[1] 封闭性；对于任意$a, b\in G，ab\in G$。[2] 结合律；对于任意$a, b, c\in G，(ab)c = a(bc)$。[3] 存在单位元素；在G中存在一个元素e，使得对于任意$a\in G，ea = ae = a$。[4] 存在逆元素；对于任意$a\in G$，在G中存在元素$b$，使得$ab = b*a = e$，其中$e$是单位元素。 置换的定义： 设集合A由n个不同元素$a_1, a_2, …, a_n$组成。A中的元素之间的一个置换是$a_1$被A中的某个元素$b_1$所取代，$a_2$被A中的某个元素$b_2$所取代，…，$a_n$ 被A中的某个元素$b_n$；并且$b_1, b_2, …, b_n$互不相同。 置换群： 一个置换群是一个群(G, *)，其元素是${a_1, a_2, ……, a_n}$的置换，而*是置换的合成。也就是说，置换群的元素是置换，操作是置换的合成。Pólya计数公式基于置换群。 例如，{1, 2, 3, 4}的所有置换$S_4＝{(1)(2)(3)(4), (12), (13), (14), (23), (24), (34),$$ (123), (124), (132), (134), (142), (143), (234), (243), $$(1234), (1243), (1324), (1342), (1423), (1432), $$(12)(34), (13)(24), (14)(23)}$。 在$S_4$中，具有相同格式的置换所示如下：$(1)^0(2)^2(3)^0(4)^0$，也就是$(2)^2$，有3个置换：$(12)(34)，(13)(24)$和$(14)(23)$；$(1)^1(3)^1$有8个置换：$(123)，(124)，(132)，(134)，(142)，(143)，(234)$和$(243)$；$(1)^2(2)^1$有6个置换：$(12)，(13)，(14)，(23)，(24)$和$(34)$；$(1)^4$只有1个置换：$(1)(2)(3)(4)$；$(4)^1$有6个置换：$(1234)，(1243)，(1324)，(1342)，(1423)$和$(1432)$。 共轭类以及其计算定理： K不动置换类： 设$K$是${1, 2, …, n}$中的一个数。$G$中使$K$保持不变的置换全体，记为$Z_K$，叫做$G$中使$K$不动的置换类，或简称K不动置换类。 例如，$G={e, (1 2), (3 4), (1 2)(3 4)}。Z_1={e, (3 4)}；Z_2={e, (3 4)}；Z_3={e, (1 2)}；Z_4＝{e, (1 2)}。e$是单位元。显然，$Z_K$是$G$的子群，$K$是${1, 2, 3, 4}$中的一个数。对于$G$，在这一置换下，1可以置换为2，2可以置换为1；3可以置换为4，4可以置换为3。但1或2不可能置换为3或4，而且3或4也不可能置换为1或2。所以，1和2在一个等价类中，3和4在另一个等价类中。 等价类： 设G是${1, 2, …, n}$的置换群，K是${1, 2, …, n}$中的一个数。在这一置换下，${1, 2, …, n}$可以被划分为若干等价类，K所属的等价类记为$E_K$。 例如，$G={e, (1 2), (3 4), (1 2)(3 4)}$。1和2在一个等价类中，3和4在另一个等价类中。$E_1=E_2={1, 2}，E_3=E_4={3, 4}$。因此，对于数$K，1\le K\le 4$，置换群G有对应的等价类$E_K$和不动置换类$Z_K$。 长舒一口气，终于介绍完定义了。下面，最关键部分来了。 Bornside引理一个小结论，但很重要： 设G是${1, 2, …, n}$的置换群，K是${1, 2, …, n}$中的一个数，则$|E_K|*|Z_K| = |G|$。 例如，$G={e, (1 2), (3 4), (1 2) (3 4)}$；$E_1=E_2={1, 2}，E_3=E_4={3, 4}$;$|E_1|=|E_2|=|E_3|=|E_4|=2$；$Z_1＝Z_2＝{e, (3 4)}，Z_3＝Z_4＝{e, (1 2)}$；$ |Z_1|=|Z_2|=|Z_3|=|Z_4|=2$。则$|E_1|* |Z_1|=|E_2|* |Z_2|=|E_3|* |Z_3|=|E_4|*|Z_4|=4=|G|$ 设$G={\alpha_1, \alpha_2, …, \alpha_m}$是一个在${1, 2, …, n}$上的置换群，其中$\alpha_1=e$；$\alpha_k$可以被记为一个若干循环节的乘积，$c_1(\alpha_k)$是置换$\alpha_k$中1阶循环节的个数，$k=1, 2, …, m$。 要到一个小高潮了 可以利用上面的结论进行证明：不妨设$ N={ 1, 2, …n } $中共有$L$个等价类，$ N=E_1+E_2+…+E_n $$$\sum_{k=1}^n|Z_k| = \sum_{i=1}^L\sum_{k\in E_i}|Z_k| = \sum_{i=1}^L|E_i|\cdot |Z_i| = L\cdot |G|$$L就是我们要求的等价类数，于是，$$L = \frac{1}{|G|}\sum_{k=1}^n|Z_k| = \frac{1}{|G|}\sum_{j=1}^s|C(\alpha_j)|$$ 下面，最主要的部分，波利亚定理，闪亮登场 波利亚定理 可以做题了 POJ 1286 Necklace of Beads code:12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;long long ans[30], n;int gcd(int x, int y) &#123; if(!y) return x; return gcd(y, x % y);&#125;long long pow(int x, int y) &#123; long long res = 1; for(int i = 1; i &lt;= y; i++) res *= x; return res;&#125;int main() &#123; for(n = 1; n &lt;= 25; n++) &#123; for(int i = 1; i &lt;= n; i++) ans[n] += pow(3, gcd(i, n)); if(n % 2 == 1) ans[n] += pow(3, n / 2 + 1) * n; else ans[n] += pow(3, n / 2) * n / 2 + pow(3, n / 2 + 1) * n / 2; ans[n] /= 2 * n; &#125; while(scanf("%lld", &amp;n) == 1 &amp;&amp; n != -1) printf("%d\n", ans[n]); return 0;&#125; 递推与生成函数k阶常系数线性齐次递推关系$ h_n-a_ih_{n-1}-a_2h_{n-2}-…-a_kh_{n-k} = 0 $ … …(1)求解形如$ q^n $的解，得q是下面方程的根（需要同时约去$ q^{n-k} $）$ x^b-a_1x^{k-1}-a_2x^{k-2}-…-a_{k-1}x-a_k = 0 $ … …(2)称(2)为(1)的特征方程（耳熟）称(2)的k个根为(1)的特征根 若$ p\not=q $是(1)的特征根，则$ c_1p^n+c_2q^n $是(1)的解若$q$是(2)的重根，则$ nq^n $是(1)的解 求解$ c_1, c_2 $时可以有已知的几项列方程组求解可以证明一定只要有k个不一样的根，方程(1)一定有解。(使用范德蒙矩阵)。 也就是说，最后一定会有k个特征根（可以相同），通项里就一定有k项（可以合并），分别为每个特征根的n次方。（这是我提炼出来的，意思差不多~） 举例：对于递推关系$ h_n - 5h_{n-1} + 6h_{n-2}，h_1 = 4, h_2 = 5 $，求通项。解：通项一定形如$ h_n = c_1\cdot 2^n + c_2\cdot 3^n $列方程求出$ c_1, c_2 $，做完了。 一般情况（跟我想的一样）：对于线性常系数齐次递推关系$ h_n + a_1h_{n-1} + a_2h_{n-2} + … + a_kh_{n-k} = 0$它的k个特征根为$ q_1, q_2, …, q_k $，它们的重数为$ r_1, r_2, …, r_k $，且$ r_1 + r_2 + .. + r_k = k $那么，通项为$ h_n = c_1r_1q_1^n + c_2r_2q_2^n + … + c_kr_kq_k^n $$ c_1, c_2, …, c_k $为常数，可以由已知的前几项解出来。完美。 叠加原理：设$ x_1, x_2, …, x_k $满足递推关系$ h_n + a_1h_{n-1} + … + a_kh_{n-k} = f(n) $$ y_1, y_2, …, y_k $满足递推关系$ h_n + a_1h_{n-1} + … + a_kh_{n-k} = g(n) $则$ x_1+y_1, x_2+y_2, …, x_k+y_k $满足递推关系$ h_n + a_1h_{n-1} + … + a_kh_{n-k} = f(n) + g(n) $一个重要的应用，有他可知(1)的通解 + (2)的特解 = (2)的通解这样可以求带有常数项的通项公式了，例如$h_n = 2h_{n-1} + 1$ （汉诺塔步数）$ h_n - 2h_{n-1} = 0 $ … …(1)$ h_n - 2h_{n-1} = 1 $ … …(2)(1)的通解可以轻松求出为$ h_n = 2^n $(2)有特解-1因此(2)通解为$ h_n = 2^n - 1 $ 特解求法定理:（未完）待定系数法吧 转移矩阵与递推关系有相同的特征多项式（转移矩阵就是矩阵优化里那个搭配快速幂的东西） 生成函数数列$ h_1, h_2, h_3, … $对应的生成函数定义为$ g(x) = h_0 + h_1x + h_2x^2 + h_3x^3 … $有限数列$ h_n $可补零变成无限 例：无限序列$ h_n = 1 $的生成函数是$ g(x) = 1 + x + x^2 + x^3 + … $在$ |x|&lt;1 $时，上式为$ g(x) = \frac{1}{1-x} $ $$ \frac{1}{1-x} = 1 + x + x^2 + x^3 + … \ \frac{1}{(1-x)^2} = 1 + 2x + 3x^2 + … \\frac{1}{(1-x)^k} = \sum_{n=0}^{+\infty}C_{k+n-1}^{k-1}x^n \e^x = 1 + \frac{x}{1!} + \frac{x^2}{2!} + \frac{x^2}{3!} $$ 多重集组合可以使用生成函数 例：2个1袋的苹果无限，5个1提的香蕉无限，4个散橘子，1个梨子，求从中组合出n个水果的方案数解：$ h_n = (\sum_{a=0}^{+\infty}x^{2a})\cdot (\sum_{b=0}^{+\infty}x^{5b})\cdot (\sum_{c=0}^4x^c)\cdot (\sum_{d=0}^1x^c) \ = (1 + x^2 + x^4 + …)(1 + x^5 + x^{10} + …)(1 + x + x^2 + x^3 + x^4)(1 + x) \ = \frac{1}{1-x^2}\cdot \frac{1}{1-x^5}\cdot (1+x+x^2+x^3+x^4)(1+x) \ = \frac{1}{(1-x)(1+x)}\cdot\frac{1}{(1+x+x^2+x^3+x^4)(1-x)}\cdot(1+x+x^2+x^3+x^4)\cdot(1+x)\ = \frac{1}{(1-x)^2} $的n次项系数答案为$ n + 1 $ 泰勒展开公式$ f(x) = f(0) + \frac{f’(0)}{1!}x + \frac{f’’(0)}{2!}x^2 + \frac{f’’’(0)}{3!}x^3 + … $哇喔 求卷积：求卷积利用生成函数具有天然的优势原数列生成函数的平方做多项式乘法，$x^n$前的系数，就是n的卷积]]></content>
      <categories>
        <category>数学</category>
        <category>组合</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1001 狼抓兔子]]></title>
    <url>%2F2019%2F01%2F22%2FBZOJ1001-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ1001 Solution解法一：网络流很容易想到题目让求的就是最小割，利用最小割最大流定理，就是一道求最大流的裸题。说几点Dinic的注意点： tot初始化为1 当发现一条路无法增光时，将d数组设为0，表示该点不可能继续增广，可以大大提速 路径是双向边，再加上反向边，总共是4条边 模板尽可能背的准一点吧，我默写的时候出来很多小问题 解法二：耦合图这个解法就巧妙多了。 Code解法一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010, inf = 0x3f3f3f3f;int n, m, head[N*N], ver[N*N*12], Next[N*N*12], edge[N*N*12], tot = 1, d[N*N], maxflow, f, s, t;queue&lt;int&gt; q;void add(int x, int y, int z) &#123; ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot; ver[++tot] = x, edge[tot] = z, Next[tot] = head[y], head[y] = tot;&#125;bool bfs() &#123; while(q.size()) q.pop(); memset(d, 0, sizeof(d)); d[s] = 1; q.push(s); while(q.size()) &#123; int x = q.front(); q.pop(); for(int i = head[x]; i; i = Next[i]) if(edge[i] &amp;&amp; !d[ver[i]]) &#123; d[ver[i]] = d[x] + 1; q.push(ver[i]); if(ver[i] == t) return true; &#125; &#125; return false;&#125;int dinic(int x, int flow) &#123; if(x == t) return flow; int k, rest = flow; for(int i = head[x]; i &amp;&amp; rest; i = Next[i]) if(edge[i] &amp;&amp; d[ver[i]] == d[x] + 1) &#123; k = dinic(ver[i], min(rest, edge[i])); if(!k) d[ver[i]] = 0; rest -= k; edge[i] -= k; edge[i ^ 1] += k; &#125; return flow - rest;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); int z; s = 1, t = n * m; for(int i = 0; i &lt; n; i++) for(int j = 1; j &lt; m; j++) scanf("%d", &amp;z), add(i*m+j, i*m+j+1, z), add(i*m+j+1, i*m+j, 0); for(int i = 0; i &lt; n - 1; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;z), add(i*m+j, i*m+m+j, z), add(i*m+m+j, i*m+j, 0); for(int i = 0; i &lt; n - 1; i++) for(int j = 1; j &lt; m; j++) scanf("%d", &amp;z), add(i*m+j, i*m+m+j+1, z), add(i*m+m+j+1, i*m+j, 0); while(bfs()) while(f = dinic(s, inf)) maxflow += f; cout &lt;&lt; maxflow &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最短路</tag>
        <tag>对偶图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2434 阿狸的打字机]]></title>
    <url>%2F2019%2F01%2F22%2FBZOJ2434-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ2434 Solution40分做法第一想法，AC自动机，记录每个字符串以及它们在Trie上的哪个节点结束，直接匹配（好暴力啊）。事实上，这种做法，仅仅是记录所有的字符串都会超时超内存，都轮不到匹配的事。但可以作为一个模板题写写嘛。 100分做法这道题作为一道NOI题，非常巧妙地运用了AC自动机的一系列扩展性质。我们考虑构建自动机之后做了什么，无非是在fail数组上跳来跳去来寻找匹配。而每一个节点有唯一的fail节点，这让我们联想到一棵新的树，“fail树”，它以fail数组为边。于是，惊喜地发现，要想出现字符串x，就要出现在x的尾节点在“fail树”上的子树中。要发现，若字符串x在字符串y中出现，则y所在Trie的节点会出现在x对应在“fail树”上的子树中，出现的次数即为匹配数因此，题目就转化为，搞出AC自动机，搞出“fail树”，求出x的子树，求出y在Trie上的链，回答他们有多少公共节点。但如果对于每个询问都这样求一边，依旧是40分，因此我们考虑一起计算。这里在代码实现上比较巧妙。子树可以用dfs序变成区间问题，而对于链，我们可以只用一遍dfs，进入一个节点时把他+1，出来时-1， Code40分代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;char str[N];int n, m, ch[N][30], pos[N], nxt[N], tot = 1, s[N], tail;vector&lt;int&gt; dic[N];void insert() &#123; int cur = 1; for(int i = 1; i &lt;= tail; i++) &#123; if(!ch[cur][s[i]]) ch[cur][s[i]] = ++tot; cur = ch[cur][s[i]]; &#125; pos[++n] = cur; for(int i = 1; i &lt;= tail; i++) dic[n].push_back(s[i]);&#125;void bfs() &#123; for(int i = 1; i &lt;= 26; i++) ch[0][i] = 1; queue&lt;int&gt; q; q.push(1); nxt[1] = 0; while(q.size()) &#123; int x = q.front(); q.pop(); for(int i = 1; i &lt;= 26; i++) &#123; if(!ch[x][i]) ch[x][i] = ch[nxt[x]][i]; else q.push(ch[x][i]), nxt[ch[x][i]] = ch[nxt[x]][i]; &#125; &#125;&#125;int find(int pa, int son) &#123; int cur = 1, res = 0; for(int i = 0; i &lt; dic[pa].size(); i++) &#123; int c = dic[pa][i], k = ch[cur][c]; while(k &gt; 1) &#123; res += pos[son] == k; k = nxt[k]; &#125; cur = ch[cur][c]; &#125; return res;&#125;int main()&#123; scanf("%s", str); int len = strlen(str); for(int i = 0; i &lt; len; i++) &#123; if(str[i] == 'P') insert(); else if(str[i] == 'B' &amp;&amp; tail) tail--; else s[++tail] = str[i] - 'a' + 1; &#125; bfs(); scanf("%d", &amp;m); while(m--)&#123; int x, y; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", find(y, x)); &#125; return 0;&#125; 100分代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200010;char str[N];int n, m, ch[N][30], fa[N], nxt[N], tot = 1, ans[N], ch1[N][30];int pos[N], bel[N];vector&lt;int&gt; dic[N];int head[N], ver[N+N], Next[N+N], edgetot;int fir[N], sec[N], nod[N+N], pool;void add(int x, int y) &#123; ver[++edgetot] = y, Next[edgetot] = head[x], head[x] = edgetot;&#125;struct Q&#123; int i, x, y; &#125;q[N];int ql[N], qr[N];bool cmp(Q a, Q b) &#123; return a.y &lt; b.y; &#125;int c[N+N];void pplus(int p, int x) &#123; for(; p &lt;= pool; p += p&amp;-p) c[p] += x;&#125;int query(int p) &#123; int res = 0; for(; p; p -= p&amp;-p) res += c[p]; return res;&#125;void bfs() &#123; for(int i = 1; i &lt;= 26; i++) ch[0][i] = 1; queue&lt;int&gt; q; q.push(1); nxt[1] = 0; while(q.size()) &#123; int x = q.front(); q.pop(); for(int i = 1; i &lt;= 26; i++) &#123; if(!ch[x][i]) ch[x][i] = ch[nxt[x]][i]; else &#123; q.push(ch[x][i]); nxt[ch[x][i]] = ch[nxt[x]][i]; add(ch[x][i], ch[nxt[x]][i]); add(ch[nxt[x]][i], ch[x][i]); &#125; &#125; &#125;&#125;void getdfn(int x, int f) &#123; fir[x] = ++pool; nod[pool] = x; for(int i = head[x]; i; i = Next[i]) if(ver[i] != f) getdfn(ver[i], x); sec[x] = ++pool; nod[pool] = x;&#125;void dfs(int x) &#123; pplus(fir[x], 1); if(bel[x] &amp;&amp; ql[bel[x]]) &#123; for(int i = ql[bel[x]]; i &lt;= qr[bel[x]]; i++) ans[q[i].i] = query(sec[pos[q[i].x]]) - query(fir[pos[q[i].x]] - 1); &#125; for(int i = 1; i &lt;= 26; i++) if(ch1[x][i]) dfs(ch1[x][i]); pplus(fir[x], -1);&#125;int main()&#123; scanf("%s", str); int len = strlen(str); for(int i = 0, u = 1; i &lt; len; i++) &#123; if(str[i] == 'P') bel[u] = ++n, pos[n] = u; else if(str[i] == 'B') u = fa[u]; else &#123; int c = str[i] - 'a' + 1; if(ch[u][c]) u = ch[u][c]; else ch[u][c] = ++tot, fa[ch[u][c]] = u, u = tot; &#125; &#125; memcpy(ch1, ch, sizeof(ch)); bfs(); getdfn(1, 0); scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++) scanf("%d%d", &amp;q[i].x, &amp;q[i].y), q[i].i = i; sort(q + 1, q + 1 + m, cmp); for(int i = 1, pos = 1; i &lt;= m; i = pos) &#123; ql[q[i].y] = i; while(q[i].y == q[pos].y) pos++; qr[q[i].y] = pos - 1; &#125; dfs(1); for(int i = 1; i &lt;= m; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>AC自动机</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1926 粟粟的书架]]></title>
    <url>%2F2019%2F01%2F22%2FBZOJ1926-%E7%B2%9F%E7%B2%9F%E7%9A%84%E4%B9%A6%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ1926 Solution前50%的数据注意到P不大于1000，因此可以预处理出与P有关的数组。val[i][j][k]表示(i, j)左上方的子矩阵中大于等于k的数的总和num[i][j][k]表示(i, j)左上方的子矩阵中大于等于k的数的个数然后就可以二分答案了，二分k，求矩阵前缀和，判定一下OK。 后50%的数据沿用前面的二分思路，但预处理时间和空间都会爆。这里可以用比较暴力的方法乱搞，但我们要追求高效嘛。 因此想到前缀和就要想到主席树，可以大大节省时间空间。具体来说，对每个前缀维护一个线段树，节点(l, r)维护两个信息：P处于l、r之间的数的总和…(1)P处于l、r之间的数的个数…(2)(就和上面的前缀和意义一样)。对这个线段树可持久化，得到一棵主席树。查询时，在要求的区间的线段树上用(1)判断左走还是右走，用(2)计算答案。 注意点： 一个区间可能有很多相同的数，只要取其中的一部分，计算得到要取多少，具体看代码。 前缀和左端点-1 递归到头后控制返回 为了防止混淆，我在代码中把两种解法放在不同的命名空间里。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int P = 1010;int r, c, m;namespace easy &#123; const int N = 210; int p[N][N], num[N][N][P], x1, x2, y1, y2; long long val[N][N][P], h; long long calc(int k)&#123; return val[x2][y2][k] - val[x1-1][y2][k] - val[x2][y1-1][k] + val[x1-1][y1-1][k]; &#125; void work() &#123; for(int i = 1; i &lt;= r; i++) for(int j = 1; j &lt;= c; j++) &#123; scanf("%d", &amp;p[i][j]); for(int k = 0; k &lt;= 1000; k++) &#123; val[i][j][k] = val[i-1][j][k] + val[i][j-1][k] - val[i-1][j-1][k]; num[i][j][k] = num[i-1][j][k] + num[i][j-1][k] - num[i-1][j-1][k]; if(k &lt;= p[i][j]) val[i][j][k] += p[i][j], num[i][j][k]++; &#125; &#125; while(m--)&#123; scanf("%d%d%d%d%lld", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;h); int l = 0, r = 1000; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(calc(mid) &gt;= h) l = mid; else r = mid - 1; &#125; if(l == 0) printf("Poor QLW\n"); else printf("%d\n", num[x2][y2][l+1] - num[x1-1][y2][l+1] - num[x2][y1-1][l+1] + num[x1-1][y1-1][l+1] + (h - calc(l+1) + l - 1) / l); //此处要考虑重复的部分到底选几个，肯定是达到要求的前提下选的越少越好 &#125; &#125;&#125;namespace hard &#123; const int N = 500010; int lc[N*32], rc[N*32], num[N*32], p[N], rt[N], tot; long long val[N*32], h; int build(int pre, int l, int r, int x) &#123; int p = ++tot; lc[p] = lc[pre], rc[p] = rc[pre], val[p] = val[pre] + x, num[p] = num[pre] + 1; if(l == r) return p; int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) lc[p] = build(lc[pre], l, mid, x); else rc[p] = build(rc[pre], mid + 1, r, x); return p; &#125; int query(int lp, int rp, int l, int r, int x) &#123; if(l == r) &#123; return (x + l - 1) / l; //这里跟上面一样，要考虑相同的部分。 &#125; int mid = (l + r) &gt;&gt; 1, y = val[rc[rp]] - val[rc[lp]]; if(y &gt;= x) return query(rc[lp], rc[rp], mid + 1, r, x); else return query(lc[lp], lc[rp], l, mid, x - y) + num[rc[rp]] - num[rc[lp]]; &#125; void work() &#123; for(int i = 1; i &lt;= c; i++) scanf("%d", &amp;p[i]), rt[i] = build(rt[i-1], 1, 1000, p[i]); while(m--)&#123; int l, r, t1, t2; scanf("%d%d%d%d%lld", &amp;t1, &amp;l, &amp;t2, &amp;r, &amp;h); int ans = query(rt[l-1], rt[r], 1, 1000, h); if(ans &gt; r - l + 1) printf("Poor QLW\n"); else printf("%d\n", ans); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;r, &amp;c, &amp;m); if(r == 1) hard::work(); else easy::work(); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>可持久化</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1070 修车]]></title>
    <url>%2F2019%2F01%2F17%2FBZOJ1070-%E4%BF%AE%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ1070 Solution对于像这样的对应匹配的问题，一般可以使用网络流求解，即构建二分图，大部分时候求最大匹配（当然也不仅是匹配）。本题中一次维修要消耗一定的时间，因此需要使用最小费用最大流。 最原始的思路是，左部工人，右部客户的二部图，但本题的特殊之处在于排在后面的人会有更长的等待时间。我们仍需保持这是一个二分图，因此需要对点或边进行一些调整。 首先，要使用一个重要的思想，考虑每辆车对总等待时间的贡献，即不计算每个顾客等多久，而计算他让别人等了多久 每一个工人一个车一个车的修，每修一辆车会让后面的人多等一会儿。 此时就可以想到拆点。把每一个工人节点k拆成个N点，等同于正在修他将要修的倒数第i辆车，向另外一部j点连边即代表他这个修的是j号车， 费用为$a[j][k]*i$，乘以i是因为后面的i辆车都要等待这个时间。 事实上本题的构图体现了一个阶段化拆点的思想，一个点拆成它的不同阶段，相互独立。 至于二部图的网络流构图法就不累述了，这里说几个注意点： 边编号要从2开始计 不要忘记建反向边，容量0，费用-w 清空数组神马的别忘了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int V = 1010, E = 200010, inf = 0x3f3f3f3f;int n, m, tot = 1, head[V], ver[E], Next[E], cap[E], cost[E], a[20][100];int s, t, pe[V], pv[V], maxflow, mincost, d[V], v[V];void add(int x, int y, int c, int w)&#123; ver[++tot] = y, cap[tot] = c, cost[tot] = w; Next[tot] = head[x], head[x] = tot;&#125;void solve() &#123; queue&lt;int&gt; q; while(1) &#123; memset(v, 0, sizeof(v)); memset(d, 0x3f, sizeof(d)); while(q.size()) q.pop(); q.push(s); d[s] = 0; v[s] = 1; while(q.size()) &#123; int x = q.front(); q.pop(); v[x] = 0; for(int i = head[x]; i; i = Next[i]) if(cap[i]) &#123; int y = ver[i]; if(d[y] &gt; d[x] + cost[i]) &#123; d[y] = d[x] + cost[i]; pv[y] = x; pe[y] = i; if(!v[y]) v[y] = 1, q.push(y); &#125; &#125; &#125; if(d[t] == inf) break; int flow = inf; for(int i = t; i != s; i = pv[i]) flow = min(flow, cap[pe[i]]); maxflow += flow; mincost += flow * d[t]; for(int i = t; i != s; i = pv[i]) cap[pe[i]] -= flow, cap[pe[i] ^ 1] += flow; &#125;&#125;int main() &#123; scanf("%d%d", &amp;m, &amp;n); s = n * m + n + 1, t = s + 1; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;a[j][i]); for(int i = 0; i &lt; m; i++) for(int j = 1; j &lt;= n; j++) for(int k = 1; k &lt;= n; k++) add(i * n + j, m * n + k, 1, a[i+1][k] * j), add(n * m + k, i * n + j, 0, -a[i+1][k] * j); for(int i = 1; i &lt;= n * m; i++) add(s, i, 1, 0), add(i, s, 0, 0); for(int i = n * m + 1; i &lt;= n * m + n; i++) add(i, t, 1, 0), add(t, i, 0, 0); solve(); printf("%.2lf", (double)mincost / n); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3994 约数个数和]]></title>
    <url>%2F2019%2F01%2F13%2FBZOJ3994-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目链接：BZOJ3994 Solution首先，要先介绍一个可爱的结论：$$ d(ij) = \sum_{x|i}\sum_{y|j}[gcd(x, y) = 1] $$简单证明一下：当$(i, j)=1$时，结果显然为i的约数个数乘j的约数个数。否则，会有一部分重复，因为i*j的某一个因数可以有不同方式得到。怎样得到另一种方式呢？比如现在有$x|i,\ y|j,\ xy|ij,\ d|x$此时让x除以d，y乘以d，得到新的$xy|ij$，而这样做合法的前提是d同时是i和j的因数，或者说$gcd(x, yd)\ne 1$，当有这样的一对约数时，把结果减1，就可以得到这个式子。 结合其他几道题目，可以发现反演似乎非常青睐gcd，所有的数论函数都要尽量往最大公约数上面靠，然后再开始套路。 之后就是一道比较经典的反演题目了，总之就是推式子吧。求$$ \sum_{i=1}^N\sum_{j=1}^M\sum_{x|i}\sum_{y|j}[gcd(x, y) = 1] $$相同的x, y枚举了很多次，因此先枚举x, y，贡献可以直接计算得到，原式即$$\sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[gcd(i, j) = 1]$$我们令$$ f(n) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[gcd(i, j) = n] $$$$ F(d) = \sum_{d|n}f(n) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[d\ |\ gcd(i, j)] $$此处可以开心得去掉gcd，用漂亮的除法代替，枚举i和j分别是d的多少倍，得到$$ F(x) = \sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\lfloor\frac{N}{id}\rfloor\lfloor\frac{M}{jd}\rfloor$$这时就可以使用莫比乌斯反演了，因为可以看到我们已经消去了gcd，也就是说式子里不存在数论函数了，于是$$ f(d) = \sum_{d|n}\mu(\frac{n}{d})F(n) $$得到答案为$$ ans = f(1) = \sum_{d=1}^{min(N, M)}\mu(d)F(d) =\sum_{d=1}^{min(N, M)}\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\mu(d)\lfloor\frac{N}{id}\rfloor\lfloor\frac{M}{jd}\rfloor $$现在讨论代码实现，暴力需要三层循环，因此需要用线性筛预处理，对于每一个x，处理出$s[x] = \sum_{i=1}^x\lfloor\frac{x}{i}\rfloor$，未来查询$s[\frac{N}{d}]$，因此只需要枚举d这一个变量。再利用整除分块，$\lfloor\frac{N}{d}\rfloor$且$\lfloor\frac{M}{d}\rfloor$相同的部分只计算一次，就可以在$O(\sqrt{n})$的时间完成一次询问，总复杂度$O(T\sqrt{n})$ 关于$\mu$的计算最好作为一个模板记下啦。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 50010;int miu[N], smiu[N], v[N];long long s[N];void init(int n)&#123; for(int i = 1; i &lt;= n; i++) miu[i] = 1, v[i] = 0; for(int i = 2; i &lt;= n; i++)&#123; if(v[i]) continue; miu[i] = -1; for(int j = i + i; j &lt;= n; j += i)&#123; v[j] = 1; if((j / i) % i == 0) miu[j] = 0; else miu[j] *= -1; &#125; &#125; for(int i = 1; i &lt;= n; i++) smiu[i] = smiu[i-1] + miu[i]; for(int i = 1; i &lt;= n; i++) &#123; for(int l = 1, r; l &lt;= i; l = r + 1) &#123; r = i / (i / l); s[i] += 1ll * (r - l + 1) * (i / l); &#125; &#125;&#125;int main()&#123; init(50000); int T; scanf("%d", &amp;T); while(T--)&#123; int n, m; scanf("%d%d", &amp;n, &amp;m); if(n &gt; m) swap(n, m); long long ans = 0; for(int i = 1, j; i &lt;= n; i = j + 1)&#123; j = min(n / (n / i), m / (m / i)); ans += 1ll * (smiu[j] - smiu[i - 1]) * s[n / i] * s[m / i]; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[施工结束]]></title>
    <url>%2F2019%2F01%2F13%2F%E7%BA%AA%E5%BF%B5%E6%97%A5%2F</url>
    <content type="text"><![CDATA[博客建成日2019年1月13日，该博客基本搭建搭建完成。话说步入OI也有将近一年的时间了，之前从来没有写过博客。曾经搜题解时看到别人的博客常常是一番羡慕，但不知什么原因，或许是太懒了，一直没有为自己搭建一个blog。从昨晚起，忙碌（玩）了几个小时，心里还是非常有成就感的。从今天起，我应该会养成写题解、发博客的习惯，这应当是有深远意义的。这篇博客主要是为了一个纪念，就像古代人建了一座房子还要写一篇序一样，我如今也是有blog的人了，不仅一番激动。但愿未来这个博客会充实起来，像很多大佬一样有几十篇来自各个OJ的题解。博客界面开不是很满意，未来会慢慢润色的。]]></content>
      <categories>
        <category>纪念日</category>
      </categories>
  </entry>
</search>
