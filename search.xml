<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BZOJ1129 [POI2008]Per</title>
      <link href="/2019/09/09/BZOJ1129-POI2008-Per/"/>
      <url>/2019/09/09/BZOJ1129-POI2008-Per/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1129" target="_blank" rel="noopener">BZOJ1129</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>如果没有重复元素，直接一位一位计数即可<br>有相同元素仍然是一位一位计数，考虑从后往前，假设当前前i-1个是固定的，数在第i位开始小于给定的序列的方案数<br>设原数列为$a$，可以变动的中，不同的元素分别是$b_1, b_2, b_3, …, b_k$，个数分别为$c_1, c_2, c_3…, c_k$个，则答案为<br>$$<br>\sum_{b_j&lt; a_i}\frac{(n-i)!}{\Pi_{k!=j} b_k\cdot(b_j-1) }<br>$$<br>硬算是$O(n^2)$的，可以用树状数组优化<br>分别维护分母和分子，每次i–时有一个新的元素加进来，某一个b会+1，分母会乘以新的b</p><p>关键是这个模数的问题，他不是质数，要质因数分解，分别求答案，然后用CRT合并<br>逆元需要用扩展欧几里得来算</p><p>还有比较麻烦的，如果乘以或除以的数是当前处理的模数对应的那个质因子的倍数，那么需要把这个数所有该因数除掉，同时记录去掉了几个这个因数<br>最后要把这些去掉的因数再快速幂乘回来<br>这是因为求逆元时要求与模数互质，因此必须先去掉，求完逆元再乘回来</p><p>任意模数的逆元的处理方式要记笔记。。。</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, mod, a[maxn], m, pr[maxn], b[maxn], pb[maxn], cnt, v[maxn], mx;</span><br><span class="line">ll c[maxn], res[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123; x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="keyword">int</span> d = exgcd(b, a % b, y, x);</span><br><span class="line">y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r, y;</span><br><span class="line">exgcd(x, p, r, y);</span><br><span class="line"><span class="keyword">return</span> (r % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p -= p&amp;-p) res = (res + c[p]) % mod; </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(; p &lt;= mx; p += p&amp;-p) c[p] = (c[p] + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line">ll pwp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mx; i++) c[i] = <span class="number">0</span>, v[i] = <span class="number">0</span>;</span><br><span class="line">ll p1 = <span class="number">0</span>, a1 = <span class="number">1</span>, aa, pp;</span><br><span class="line">res[k] = <span class="number">1</span>;</span><br><span class="line">pwp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pwp[i] = pwp[i<span class="number">-1</span>] * pr[k] % mod;</span><br><span class="line">v[a[n]]++; add(a[n]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) &#123;</span><br><span class="line">v[a[i]]++; add(a[i]);</span><br><span class="line"><span class="keyword">for</span>(aa = n - i, pp = <span class="number">0</span>; aa % pr[k] == <span class="number">0</span>; aa /= pr[k], pp++);</span><br><span class="line">a1 = a1 * aa % mod; p1 += pp;</span><br><span class="line"><span class="keyword">for</span>(aa = v[a[i]], pp = <span class="number">0</span>; aa % pr[k] == <span class="number">0</span>; aa /= pr[k], pp++);</span><br><span class="line">a1 = a1 * inv(aa, mod) % mod; p1 -= pp;</span><br><span class="line">res[k] = (res[k] + a1 % mod * query(a[i] - <span class="number">1</span>) % mod * pwp[p1] % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; res[k] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"> <span class="keyword">int</span> sm = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), mx = max(mx, a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= m; i++) <span class="keyword">if</span>(m % i == <span class="number">0</span>) &#123;</span><br><span class="line">pr[++cnt] = i; pb[cnt] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(m % i == <span class="number">0</span>) m /= i, b[cnt]++, pb[cnt] *= pr[cnt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(m != <span class="number">1</span>) pr[++cnt] = m, b[cnt] = <span class="number">1</span>, pb[cnt] = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) mod = pb[i], solve(i);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> M = sm / pb[i];</span><br><span class="line">ans = (ans + res[i] * M % sm * inv(M, pb[i]) % sm) % sm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 数据结构 </category>
          
          <category> 组合 </category>
          
          <category> 树状数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1113 [Poi2008]海报PLA</title>
      <link href="/2019/09/09/BZOJ1113-Poi2008-%E6%B5%B7%E6%8A%A5PLA/"/>
      <url>/2019/09/09/BZOJ1113-Poi2008-%E6%B5%B7%E6%8A%A5PLA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1113" target="_blank" rel="noopener">BZOJ1113</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>海报个数减少的机会就是两个矩阵高度相同，且他们之间的矩阵都比他们高</p><p>这样用一个单调栈就可以了，维护一个上升的高度，每个矩阵只有在弹出一个和他高度相同的矩阵时才不增加答案。<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, sta[<span class="number">250010</span>], tp, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">while</span>(tp &amp;&amp; sta[tp] &gt;= y) &#123;</span><br><span class="line"><span class="keyword">if</span>(sta[tp] &gt; y) ans++;</span><br><span class="line">tp--;</span><br><span class="line">&#125;</span><br><span class="line">sta[++tp] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans + tp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1098 [POI2007]办公楼biu</title>
      <link href="/2019/09/09/BZOJ1098-POI2007-%E5%8A%9E%E5%85%AC%E6%A5%BCbiu/"/>
      <url>/2019/09/09/BZOJ1098-POI2007-%E5%8A%9E%E5%85%AC%E6%A5%BCbiu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1098" target="_blank" rel="noopener">BZOJ1098</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意：将一个图的点分成尽可能多的集合，任意两个属于不同集合的点都有边相连</p><p>换句话说，求补图的联通块数</p><p>然而补图的边数是$ O(n^2) $的，连边都连不了，并查集不行啊<br>我们回归到原始，考虑bfs或dfs时需要做什么<br>其实就是在每个点的时候，快速找到所有与他相连的未标记的点。</p><blockquote><p>对于一个点，可以$O(n)$找到所有与他相连的点（废话）</p></blockquote><blockquote><p>如果使用bfs的话，每个点只需要被这样找到一次（不是废话）</p></blockquote><p>因为一个点被找到之后，就可以入队然后找他的连边的点了，之后就算他再一次被找到，他们也已经被标记在同一个联通块里了，所以再一次找到他一次就没有必要了<br>因此在找到一个点后，入队之余把他删除掉就好了，这个用一个链表就解决了</p><p>实质上相当于把每个连通块简化成了一个bfs树，所有其他边都是没有必要的，边数就是$O(n)$的，然后就很好搞了</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>, maxm = <span class="number">4000010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxm], Next[maxm], tot, n, m, v[maxn], nxt[maxn], pre[maxn], col[maxn], tim, dd[maxn], sz[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">nxt[pre[x]] = nxt[x];</span><br><span class="line">pre[nxt[x]] = pre[x];</span><br><span class="line">dd[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s); col[s] = tim; del(s);</span><br><span class="line"><span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = nxt[<span class="number">0</span>]; i; i = nxt[i]) v[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(!dd[ver[i]]) v[ver[i]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = nxt[<span class="number">0</span>]; i; i = nxt[i]) <span class="keyword">if</span>(!v[i] &amp;&amp; !dd[i]) col[i] = tim, del(i), q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) nxt[i] = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pre[i] = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!col[i]) tim++, bfs(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tim);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sz[col[i]]++;</span><br><span class="line">sort(sz + <span class="number">1</span>, sz + <span class="number">1</span> + tim);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tim; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, sz[i]); <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 补图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搞 </tag>
            
            <tag> bfs </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1065 [NOI2008]奥运物流</title>
      <link href="/2019/08/31/BZOJ1065-NOI2008-%E5%A5%A5%E8%BF%90%E7%89%A9%E6%B5%81/"/>
      <url>/2019/08/31/BZOJ1065-NOI2008-%E5%A5%A5%E8%BF%90%E7%89%A9%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1065" target="_blank" rel="noopener">BZOJ1065</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>有一颗有根树，根节点还有一个父亲，每个点的可靠性与儿子们相关。</p><p>考虑如果是一棵纯正的树，那么答案应为<br>$$<br>\sum_{i=1}^nk^{dep[i]}C_i<br>$$<br>当出现环后，也就出现了一个方程，解这个方程即可，设1号点的后继为t<br>$$<br>ans = \sum_{i=1}^nk^{dep[i]}C_i + ans\times k^{dep[x]} \\<br>ans = \frac{\sum_{i=1}^nk^{dep[i]}C_i}{1 - k^{dep[x]}}<br>$$<br>容易发现每个修改后继的点，后继一定修改成了1号节点，这样最优<br>枚举1号点的后继的深度，分母也就确定了，就可以不用考虑环了</p><p>于是就是在树上dp，用$f[i][j]$表示以i为根的子树中，j个点接到1的下面，最大的稳定度<br>但问题是转移时稳定度需要用深度来算啊，这样的状态无法转移<br>因此再加一维记录深度，用$f[i][j][k]$表示以i为根的子树中，i的深度为k，有j个点接到1的下面，最大的稳定度<br>这样转移时每个点u可以考虑是否接到1的下面</p><ol><li><p>如果u后继改为1，那么儿子的深度要么是1（也改了），要么是2（没改）<br>转移如下（设v是u的儿子）<br>$$<br>f[u][i][j] = C_u\times k + max(f[v][k][1], f[v][k][2])<br>$$<br>有限制条件，$\sum k = i - 1$，所以后面一项要用背包dp来做</p></li><li><p>如果u后继不改，那么儿子深度为$j + 1$或1<br>可以同理得到这样的转移<br>$$<br>f[u][i][j] = C_u \times k^j + max(f[v][k][1], f[v][k][j + 1])<br>$$<br>限制相同，用同样的背包dp做</p></li></ol><p>代码中背包dp部分的$g[i][j]$表示的是考虑前i个儿子，j个点后继改为1的最大值，实际上就是套路的背包dp</p><p>关于上面说的枚举1后继的深度，实际上可以在1的后继到1号点这条链上枚举每一个点，将他的后继改为1，dp更新答案之后再改回去，这样比较容易实现</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">70</span>;</span><br><span class="line"><span class="keyword">int</span> v[maxn], F, s[maxn], dep[maxn], sz[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">double</span> k, c[maxn], pk[maxn], f[maxn][maxn][maxn], g[maxn][maxn], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) f[i][j][k] = <span class="number">-1e18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dpbag</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sz[x]; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) g[i][j] = <span class="number">-1e18</span>;</span><br><span class="line">g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">2</span>, i = <span class="number">0</span>; y &lt;= n; y++) <span class="keyword">if</span>(s[y] == x) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k++) g[i+<span class="number">1</span>][j] = max(g[i+<span class="number">1</span>][j], g[i][k] + f[y][j-k][d]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">sz[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span>(s[i] == x) sz[x]++, dep[i] = dep[x] + <span class="number">1</span>, dfs(i);</span><br><span class="line">dpbag(x, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) f[x][j][i] = c[x] * k + g[sz[x]][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dpbag(x, i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) f[x][j][i] = max(f[x][j][i], g[sz[x]][j] + c[x] * pk[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"trans.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"trans.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;n, &amp;m, &amp;k); m = min(m, n - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;F); s[<span class="number">1</span>] = F;</span><br><span class="line">pk[<span class="number">0</span>] = <span class="number">1.0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) pk[i] = pk[i<span class="number">-1</span>] * k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), s[i] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;c[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = s[<span class="number">1</span>]; i != <span class="number">1</span>; i = s[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = s[i]; s[i] = <span class="number">1</span>;</span><br><span class="line">init();</span><br><span class="line">dfs(<span class="number">1</span>); ans = max(ans, f[<span class="number">1</span>][m - (tmp == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>)][<span class="number">0</span>] / (<span class="number">1</span> - pk[dep[F] + <span class="number">1</span>]));</span><br><span class="line">s[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 树形dp </category>
          
          <category> 背包dp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1064 [Noi2008]假面舞会</title>
      <link href="/2019/08/31/BZOJ1064-Noi2008-%E5%81%87%E9%9D%A2%E8%88%9E%E4%BC%9A/"/>
      <url>/2019/08/31/BZOJ1064-Noi2008-%E5%81%87%E9%9D%A2%E8%88%9E%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1064" target="_blank" rel="noopener">BZOJ1064</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>对于每条信息连一条边权为1的正向边和一条边权为-1的反向边，然后染色问题，dfs一遍为每个点分配编号。若出现矛盾直接退出，否则得到这个连通块的最大可能数。<br>对每个联通的结果求gcd，就得到了整体的最大可能数<br>最小值就是最大值的第一个大于等于3的因数<br>注意小于3为无解<br>正确性显然，关键是正向反向的边权和染色<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>, maxm = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, head[maxn], ver[maxm], edge[maxm], Next[maxm], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123; ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> col[maxn], cir[maxm], cnt, v[maxn], cmx = <span class="number">1</span>, cmn = <span class="number">1</span>, len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cur, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">col[x] = cur; v[x] = <span class="number">1</span>;</span><br><span class="line">cmn = min(cmn, col[x]), cmx = max(cmx, col[x]);</span><br><span class="line"><span class="comment">// cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; cur &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(i != pa) &#123;</span><br><span class="line"><span class="keyword">if</span>(v[ver[i]]) cir[++cnt] = <span class="built_in">abs</span>(col[ver[i]] - (cur + edge[i]));</span><br><span class="line"><span class="keyword">else</span> dfs(ver[i], cur + edge[i], i ^ <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> y ? gcd(y, x % y) : x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen("2.in", "r", stdin);</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y, <span class="number">1</span>), add(y, x, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!v[i]) dfs(i, <span class="number">1</span>, <span class="number">0</span>), len += cmx - cmn + <span class="number">1</span>, cmx = cmn = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= cnt; i++) cout &lt;&lt; cir[i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) mx = gcd(mx, cir[i]);</span><br><span class="line"><span class="keyword">if</span>(mx == <span class="number">1</span> || mx == <span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(mx == <span class="number">0</span>)&#123; </span><br><span class="line"><span class="keyword">if</span>(len &lt; <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, len, <span class="number">3</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mn;</span><br><span class="line"><span class="keyword">for</span>(mn = <span class="number">3</span>; mn &lt;= mx; mn++) <span class="keyword">if</span>(mx % mn == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, mx, mn); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 染色 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 染色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1063 [Noi2008]道路设计</title>
      <link href="/2019/08/31/BZOJ1063-Noi2008-%E9%81%93%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/08/31/BZOJ1063-Noi2008-%E9%81%93%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1063" target="_blank" rel="noopener">BZOJ1063</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意：给定一棵有根树，可以将任意条路径上的边打上标记，每个点的“不便利度”为其到根的路径上未标记边的条数，要求最小化所有点不便利度的最大值，并求方案数</p><p>树形dp，用$ f[i][0/1] $表示以i为根的子树中，i连向父亲的边是否标记，最小的不便利度<br>考试时，我直接二分f值，实际上也可以递推，方法类似下面要说的g</p><p>这里有一个非常有用的性质<br>考虑树链剖分时的轻重链的划分，可以发现不便利度也就是轻边个数，因此有方法使不便利度最大不会超过$ log_2n $，这样就可以进一步设计状态了</p><p>用$ g[i][0/1/2][j] $表示以i为根的子树中，i连向子树的边标记了0或1或2条，不便利度为j的方案数<br>然后背包dp转移即可<br>至于为什么这里开了3个，f只开了2个，因为算f时由贪心策略，每个点连出去的边一定有一条标记，但算方案数时就不一定了</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, mod, head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot, N;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">2</span>], q[maxn];</span><br><span class="line">ll g[maxn][<span class="number">3</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa, <span class="keyword">int</span> mid, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[ver[i]][<span class="number">0</span>] + <span class="number">1</span> &lt;= mid) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(f[ver[i]][<span class="number">1</span>] &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt; lim) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) dp(ver[i], x);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(valid(x, pa, mid, <span class="number">1</span>)) r = mid; <span class="keyword">else</span> l = mid + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">1</span>] = l;</span><br><span class="line">l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(valid(x, pa, mid, <span class="number">2</span>)) r = mid; <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">0</span>] = l;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; f[x][0] &lt;&lt; ' ' &lt;&lt; f[x][1] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) dfs(ver[i], x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= N; j++) &#123;</span><br><span class="line">g[x][<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) &#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line">g[x][<span class="number">2</span>][j] = (g[x][<span class="number">1</span>][j] * g[y][<span class="number">1</span>][j] % mod + (j ? g[x][<span class="number">2</span>][j] * g[y][<span class="number">2</span>][j<span class="number">-1</span>] % mod : <span class="number">0</span>)) % mod;</span><br><span class="line">g[x][<span class="number">1</span>][j] = (g[x][<span class="number">0</span>][j] * g[y][<span class="number">1</span>][j] % mod + (j ? g[x][<span class="number">1</span>][j] * g[y][<span class="number">2</span>][j<span class="number">-1</span>] % mod : <span class="number">0</span>)) % mod;</span><br><span class="line"><span class="keyword">if</span>(j) (g[x][<span class="number">0</span>][j] *= g[y][<span class="number">2</span>][j<span class="number">-1</span>] % mod) %= mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Next[head[x]]) g[x][<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">(g[x][<span class="number">1</span>][j] += g[x][<span class="number">0</span>][j]) %= mod;</span><br><span class="line">(g[x][<span class="number">2</span>][j] += g[x][<span class="number">1</span>][j]) %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for(int i = 0; i &lt;= N; i++) cout &lt;&lt; g[x][2][i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for(int i = 0; i &lt;= N; i++) cout &lt;&lt; g[x][1][i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for(int i = 0; i &lt;= N; i++) cout &lt;&lt; g[x][0][i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("design.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//freopen("design.out", "w", stdout);</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;mod);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line"><span class="keyword">if</span>(m &lt; n - <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">"-1\n-1\n"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">dp(<span class="number">1</span>, <span class="number">0</span>); N = f[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (g[<span class="number">1</span>][<span class="number">2</span>][N]) % mod);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 树形dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1062 [NOI2008]糖果雨</title>
      <link href="/2019/08/31/BZOJ1062-NOI2008-%E7%B3%96%E6%9E%9C%E9%9B%A8/"/>
      <url>/2019/08/31/BZOJ1062-NOI2008-%E7%B3%96%E6%9E%9C%E9%9B%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1062" target="_blank" rel="noopener">BZOJ1062</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意：一些线段在左右飘，支持加入和删除线段，多次询问某个时刻某个区间接触的线段个数</p><p>我们把一条线段看成是平面坐标系中横坐标为左端点，纵坐标为线段长度的一个点．同时将横坐标复制一边，代表反方向，这样就变成了标准的循环．</p><p>考虑每个询问可以覆盖的范围，那么也就是求这个范围内的点数</p><p>如果时刻都为０的话，那么每个询问的范围是一个矩形切掉一个角形成的五边形，可以补成一个平行四边形．由于翻倍了，因此是两个</p><p>当时刻不为０时，这两个平行四边形会左右平移，要考虑到有重合部分的边界情况．</p><p>平行四边形不方便处理，可以坐标变换，新的纵坐标为原来的横纵坐标之和或差，对于两个平行四边形有不同的变换方式，要建两个坐标系</p><p>懒得画图了，贴一个<a href="https://oi.men.ci/noi2008-candy/" target="_blank" rel="noopener">写的很清楚的链接</a><br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, len, rev[<span class="number">1000010</span>], X[maxn], Y[maxn], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">2020</span>][<span class="number">4020</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">x++; y++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= <span class="number">2010</span>; i += i&amp;-i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = y; j &lt;= <span class="number">4010</span>; j += j&amp;-j)</span><br><span class="line">c[i][j] += z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">x++; y++;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">2</span> * len) x = <span class="number">2</span> * len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y &gt; <span class="number">4</span> * len) y = <span class="number">4</span> * len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ';</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= i&amp;-i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = y; j; j -= j&amp;-j) res += c[i][j];</span><br><span class="line"><span class="comment">//cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x1 &lt;&lt; ' ' &lt;&lt; y1 &lt;&lt; ' ' &lt;&lt; x2 &lt;&lt; ' ' &lt;&lt; y2 &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> query(x2, y2) - query(x1<span class="number">-1</span>, y2) - query(x2, y1<span class="number">-1</span>) + query(x1<span class="number">-1</span>, y1<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;bit1, bit2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"candy.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"candy.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> o, t, l, r, c, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;o);</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">1</span>) &#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;t, &amp;c, &amp;l, &amp;r, &amp;d);</span><br><span class="line">rev[c] = cnt; </span><br><span class="line">t = (t - d * l + len * <span class="number">2</span>) % (len * <span class="number">2</span>); r = r - l;</span><br><span class="line">bit1.add(t, r + t, <span class="number">1</span>); bit2.add(t, r - t + <span class="number">2</span> * len, <span class="number">1</span>);</span><br><span class="line">X[cnt] = t; Y[cnt] = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;t, &amp;l, &amp;r);</span><br><span class="line"><span class="keyword">int</span> d = (r == len);</span><br><span class="line">t %= (len * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> res = bit1.sum(t, t + l, t + r, <span class="number">4</span> * len) + bit1.sum(<span class="number">0</span>, t + l - <span class="number">2</span> * len, t + r - <span class="number">2</span> * len - d, <span class="number">4</span> * len);</span><br><span class="line"><span class="comment">//cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">res += bit2.sum(t - r, l - t + <span class="number">2</span> * len, t - <span class="number">1</span>, <span class="number">4</span> * len) + bit2.sum(t - r + <span class="number">2</span> * len + d, l - t, <span class="number">2</span> * len, <span class="number">4</span> * len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;l);</span><br><span class="line"><span class="keyword">int</span> i = rev[l];</span><br><span class="line">bit1.add(X[i], Y[i] + X[i], <span class="number">-1</span>); </span><br><span class="line">bit2.add(X[i], Y[i] - X[i] + <span class="number">2</span> * len, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树状数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 数形转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1921 [Ctsc2010]珠宝商</title>
      <link href="/2019/08/28/BZOJ1921-Ctsc2010-%E7%8F%A0%E5%AE%9D%E5%95%86/"/>
      <url>/2019/08/28/BZOJ1921-Ctsc2010-%E7%8F%A0%E5%AE%9D%E5%95%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1921" target="_blank" rel="noopener">BZOJ1921</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>本题综合利用后缀自动机的呀</p><p>首先第一想法是怎么写暴力，从每个点为起点开始想下走，同时在SAM上走DAG，对于树上的每走到一个点，把答案加上其SAM对应节点的endpos大小即可，复杂度$ O(n^2) $</p><p>然后看到这种统计路径的题，回想到点分和DSU，先试试点分，那么需要做的是统计以经过某个点x的路径的贡献，假设这条路径是$ u \to x \to v $<br>点分的一般思路，如果可以单独算出$ u \to x $和$ x \to v $，那么拼在一起就好了<br>但是如何拼在一起呢<br>考虑可以在M串上统计，每个u到x在匹配的位置上加一个标记，那么最后的答案就是每个位置 向前匹配的标记和*向后匹配的标记和 之和<br>发现上面说的两种路径其中一种可以变成反串上的另一种，因此只需考虑一种就可以</p><p>然后就要求后缀自动机理解透彻了<br>网上的题解都说要在后缀树上统计$ u \to x $的路径贡献<br>然后我就想，为什么还要搞后缀树，直接在DAG上统计$ x \to v $的贡献不就可以啦，每次在后面加一个字符，方法同第一种暴力一样啊<br>然而在网上找不到这种做法，于是我就手画了好多后缀自动机和后缀树（因为画挂了很多次），然后找到了原因<br>如果我们走DAG来计算贡献，那么走到一个点时，要计入的是以$ x…v $为前缀的串的个数，但在DAG上走到一个位置，这个节点代表的字串可以有在$x…v$前面加了几个字符，然后就不满足要求了，但我们同样会计入答案。也就是说这样会统计多<br>但如果在后缀树上统计$ u \to x $，那么每次是在前面加一个字符，需要向儿子走，但可以保证之后走到的每一个点代表的所有串都是以$ u…x $为后缀的，就是当且仅当的意思，所以可以正确统计<br>这个还是要搞张图看看啊</p><p>后缀自动机一个重要性质：自动机的par树即是其反串的后缀树（所以par树也叫前缀树，前缀树是反串的后缀树，多好）<br>然后建后缀树时记录一下每个点到其儿子走的是哪个字符的转移边</p><p>这样点分的做法就完善了，由于在每个分治点都要在后缀树上将标记推到儿子并统计，复杂度是$ O(nlogn + nm) $，后面一部分成了瓶颈</p><p>前人想出了一个很神仙的操作，我们发现第一个解法（暴力）复杂度与m无关，因此可以考虑当分治的子树大小低于某个值时直接暴力统计即可<br>当这个值设为$ \sqrt n $时最优，复杂度可以控制在$ O((n + m)\sqrt n) $</p><p>写在最后<br>后缀系列算法真的好神啊，后缀自动机和后缀树的坑好深啊<br>主要是有各种各样的性质，互相转换又即为方便<br>然后通过这道题我还练熟了手画自动机[滑稽]</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i(a), i##_ORZ(b); i &lt;= i##_ORZ; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drep(i, a, b) for(int i(a), i##_ORZ(b); i &gt;= i##_ORZ; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">char</span> tr[maxn], eg[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, head[maxn], ver[maxn], Next[maxn], tot, totsz, mn, rt, sz[maxn], v[maxn], B;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> par[maxn], ch[maxn][<span class="number">30</span>], val[maxn], cnt, las, rt;</span><br><span class="line"><span class="keyword">int</span> sz[maxn], pos[maxn], nxt[maxn][<span class="number">30</span>], c[maxn], A[maxn], nod[maxn], sum[maxn];</span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> po)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = las, np = ++cnt; nod[po] = np;</span><br><span class="line">val[np] = val[p] + <span class="number">1</span>; sz[np] = <span class="number">1</span>; pos[np] = po;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line"><span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> q = ch[p][x];</span><br><span class="line"><span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span>(ch[nq]));</span><br><span class="line">par[nq] = par[q];</span><br><span class="line">par[q] = par[np] = nq;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">las = np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cnt = rt = las = <span class="number">1</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, m) extend(S[i] - <span class="string">'a'</span>, i);</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) c[val[i]]++;</span><br><span class="line">rep(i, <span class="number">1</span>, m) c[i] += c[i<span class="number">-1</span>];</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) A[c[val[i]]--] = i;</span><br><span class="line">drep(i, cnt, <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x = A[i];</span><br><span class="line">sz[par[x]] += sz[x]; </span><br><span class="line"><span class="keyword">if</span>(!pos[par[x]]) pos[par[x]] = pos[x];</span><br><span class="line">nxt[par[x]][S[pos[x] - val[par[x]]] - <span class="string">'a'</span>] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) sum[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) sum[A[i]] += sum[par[A[i]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa, <span class="keyword">int</span> cur, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(len == val[cur]) cur = nxt[cur][tr[x] - <span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S[pos[cur] - len] != tr[x]) cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">len++; sum[cur]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]])</span><br><span class="line">match(ver[i], x, cur, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;sam[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">sz[x] = <span class="number">1</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]]) &#123;</span><br><span class="line">getroot(ver[i], x);</span><br><span class="line">sz[x] += sz[ver[i]];</span><br><span class="line">res = max(res, sz[ver[i]]);</span><br><span class="line">&#125;</span><br><span class="line">res = max(res, totsz - sz[x]);</span><br><span class="line"><span class="keyword">if</span>(res &lt; mn) rt = x, mn = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">cur = sam[<span class="number">0</span>].ch[cur][tr[x] - <span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">ans += sam[<span class="number">0</span>].sz[cur];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]])</span><br><span class="line">calc(ver[i], x, cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brute</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">calc(x, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]])</span><br><span class="line">brute(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">sam[<span class="number">0</span>].clear(); sam[<span class="number">1</span>].clear();</span><br><span class="line">sam[<span class="number">0</span>].match(x, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); sam[<span class="number">0</span>].pushdown();</span><br><span class="line">sam[<span class="number">1</span>].match(x, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); sam[<span class="number">1</span>].pushdown();</span><br><span class="line">rep(i, <span class="number">1</span>, m) ans += <span class="number">1l</span>l * sam[<span class="number">0</span>].sum[sam[<span class="number">0</span>].nod[i]] * sam[<span class="number">1</span>].sum[sam[<span class="number">1</span>].nod[m - i + <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">sam[<span class="number">0</span>].clear(); sam[<span class="number">1</span>].clear();</span><br><span class="line">sam[<span class="number">0</span>].match(x, <span class="number">0</span>, sam[<span class="number">0</span>].ch[<span class="number">1</span>][tr[pa] - <span class="string">'a'</span>], <span class="number">1</span>); sam[<span class="number">0</span>].pushdown();</span><br><span class="line">sam[<span class="number">1</span>].match(x, <span class="number">0</span>, sam[<span class="number">1</span>].ch[<span class="number">1</span>][tr[pa] - <span class="string">'a'</span>], <span class="number">1</span>); sam[<span class="number">1</span>].pushdown();</span><br><span class="line">rep(i, <span class="number">1</span>, m) ans -= <span class="number">1l</span>l * sam[<span class="number">0</span>].sum[sam[<span class="number">0</span>].nod[i]] * sam[<span class="number">1</span>].sum[sam[<span class="number">1</span>].nod[m - i + <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsz</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">sz[x] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(!v[ver[i]] &amp;&amp; ver[i] != pa) </span><br><span class="line">getsz(ver[i], x), sz[x] += sz[ver[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(totsz &lt;= B) &#123; brute(x, <span class="number">0</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">Insert(x); v[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(!v[ver[i]]) Delete(ver[i], x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(!v[ver[i]]) &#123;</span><br><span class="line">getsz(ver[i], x);</span><br><span class="line">totsz = mn = sz[ver[i]];</span><br><span class="line">getroot(ver[i], x);</span><br><span class="line">DFS(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line">B = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, tr + <span class="number">1</span>, eg + <span class="number">1</span>);</span><br><span class="line">m = <span class="built_in">strlen</span>(eg + <span class="number">1</span>);</span><br><span class="line">rep(i, <span class="number">1</span>, m) sam[<span class="number">0</span>].S[i] = eg[i], sam[<span class="number">1</span>].S[m - i + <span class="number">1</span>] = eg[i];</span><br><span class="line">sam[<span class="number">0</span>].build(); sam[<span class="number">1</span>].build();</span><br><span class="line">totsz = mn = n; </span><br><span class="line">getroot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">DFS(rt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 字符串 </category>
          
          <category> 后缀自动机 </category>
          
          <category> 后缀树 </category>
          
          <category> 点分治 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀自动机 </tag>
            
            <tag> 后缀树 </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1920 [Ctsc2010]产品销售</title>
      <link href="/2019/08/28/BZOJ1920-Ctsc2010-%E4%BA%A7%E5%93%81%E9%94%80%E5%94%AE/"/>
      <url>/2019/08/28/BZOJ1920-Ctsc2010-%E4%BA%A7%E5%93%81%E9%94%80%E5%94%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接:<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1920" target="_blank" rel="noopener">BZOJ1920</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>对于30分的部分分，就是建出图后跑最小费用最大流<br>对于100分，就是模拟费用流的过程，中间用数据结构（线段树）维护</p><p>建图方式如下<br>$ s \to i $ 容量为U，费用为P<br>$ i \to i+1$ 容量为$ \infty$，费用为M<br>$ i+1 \to i$ 容量为$ \infty$，费用为C<br>$ i \to t$ 容量为D，费用为0<br>还有他们的反向边</p><p>考虑如何模拟费用流，首先得性质是，源点和汇点都是满流的，并且他们可以不退流，因此可以考虑枚举每个点i，分配他到汇点的流量使之满流<br>可以发现源点到i的流有两种：<br>$ s \to k \to k+1 \to … \to i-1 \to i ……(1)$<br>$ s \to k \to k-1 \to … \to i+1 \to i ……(2)$<br>我们每次选两种决策中费用较少的进行扩流，直到$D[i]$流满为止<br>也就是过程分为三步，<br>一、计算两种决策的代价<br>二、取较优的方式扩流，维护信息，更新答案，直到流满<br>三、从i移动到i+1，维护信息</p><h3><span id="决策2">决策（2）</span></h3><p>由于i是递增枚举的，所以从右到左的流只可能走C的正向边，可以不考虑M的反响边，代价为$ P[k] + sumC[k-1] - sumC[i] $，前面只与k有关，可以先排好序，每次跳过非法的（$k \le i || U[k]==0$）的k就可以直接询问</p><p>扩流的话，流量为$flow = min(U[k], D[i])$，将$[i, k-1]$的区间流量加上$flow$即可</p><h3><span id="决策1">决策（1）</span></h3><p>M的正向边有无限容量，但代价大，C的反向边代价小（为负），但有容量限制，为路径上所有正向边流量的最小值，因此前面每条边的代价有两种情况，$-C $或$ +M$<br>如果可以对C的流量进行维护的话，那么就可以维护正确的代价，进而求最小值<br>这个维护，需要在流量从0边成非0时设置代价为$-C$，在其又退回0后将代价加上$C+M$，可以发现每条边最多在右边时变大，在左边时变小，因此只有这两个过程就够了</p><p>扩流同上</p><p>考虑这个0的维护，如果最开始初值设为0的话，那么很难区分0到底是初值还是后来减回来的，所以一个比较好的办法是初值设为inf<br>在没有用到它的时候默认inf就是初值的0<br>然后会面临在决策（2）的时候，流量被区间加，这时需要先把所有inf设为0，再区间加，可以发现每个inf最多被设为0一次，可以用并查集优化，每次跳到下一个inf的位置即可<br>然后面临在决策（1）时区间减，会出现减到0的情况这标志着要修改代价了，只有在这个时候会真正出现0。修改完代价后我们立刻把0再变回inf，代表它已经没有流量了。之所以他可以改成inf而不会继续对区间的容量有所限制，是因为我们已经修改过费用了，新的容量正好对应着新的费用。<br>这样就完美解决了最棘手的问题。</p><h3><span id="维护的信息">维护的信息</span></h3><p>需要维护C的流量flow，支持区间加减，查询最小值及其位置，以及获得每个0的位置，单点置为某值。<br>还要维护i之前每个点到i的代价（费用）cost，支持区间加减，查询最小值及其位置，单点置为某值<br>实际上操作是类似的，可以写成一个结构体的两个对象</p><p>具体怎么维护</p><p>在$cost[1…i-1] $中查询最小值和位置k，作为决策（1）<br>从排序好的那个序列首取出合法位置k，作为决策（2）<br>判断用那个决策，<br>对于（1）在$ flow[k…i-1] $中查询最小值，和U和D取min，得到流量，将$ flow[k…i-1] $区间减这个流量。在$flow$同样的区间递归找到每个为0的位置j，在$cost[1…j]$中区间加$ C[j]+M[j] $<br>对于（2），取U和D的min作为流量，$flow$区间加流量，加之前跳并查集将inf改为0<br>直到D[i]为0<br>将$cost[1…i]$区间加P[i]（前提是U[i]不为0）<br>将$cost[1…i]$区间加M[i]或-C[i]，取决于C[i]是否有流量，这是i对于前面每个点贡献的费用</p><p>然后终于结束了</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i(a), i##_END(b); i &lt;= i##_END; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drep(i, a, b) for(int i(a), i##_END(b); i &gt;= i##_END; i--);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, D[maxn], U[maxn], P[maxn], M[maxn], C[maxn], fa[maxn], sumC[maxn];</span><br><span class="line">pii rcs[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = get(fa[x]); &#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> mn[maxn * <span class="number">4</span>], pos[maxn * <span class="number">4</span>], tag[maxn * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; mn[p] = x; pos[p] = l; tag[p] = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(p*<span class="number">2</span>, l, mid, x); build(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!tag[p]) <span class="keyword">return</span>; </span><br><span class="line">mn[p*<span class="number">2</span>] += tag[p]; mn[p*<span class="number">2</span>+<span class="number">1</span>] += tag[p];</span><br><span class="line">tag[p*<span class="number">2</span>] += tag[p]; tag[p*<span class="number">2</span>+<span class="number">1</span>] += tag[p];</span><br><span class="line">tag[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123; mn[p] += x; tag[p] += x; <span class="keyword">return</span>; &#125;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) change(p*<span class="number">2</span>, l, mid, L, R, x);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) change(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; mn[p] = x; <span class="keyword">return</span>; &#125;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(u &lt;= mid) change(p*<span class="number">2</span>, l, mid, u, x);</span><br><span class="line"><span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, u, x);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> make_pair(mn[p], pos[p]);</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="function">pii <span class="title">res</span><span class="params">(inf, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) res = min(res, query(p*<span class="number">2</span>, l, mid, L, R));</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) res = min(res, query(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, SegmentTree &amp;tar)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; tar.change(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, l, C[l] + M[l]); mn[p] = inf; <span class="keyword">return</span>; &#125;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid &amp;&amp; mn[p*<span class="number">2</span>] == <span class="number">0</span>) reset(p*<span class="number">2</span>, l, mid, L, R, tar);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid &amp;&amp; mn[p*<span class="number">2</span>+<span class="number">1</span>] == <span class="number">0</span>) reset(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, tar);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;flow, cost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"product.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"product.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); </span><br><span class="line">rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;D[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;U[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;P[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n) fa[i] = i, sumC[i] = sumC[i<span class="number">-1</span>] + C[i], rcs[i] = make_pair(P[i] + sumC[i - <span class="number">1</span>], i);</span><br><span class="line">sort(rcs + <span class="number">1</span>, rcs + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">int</span> rpos = <span class="number">1</span>;</span><br><span class="line">flow.build(<span class="number">1</span>, <span class="number">1</span>, n, inf); cost.build(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">while</span>(D[i]) &#123;</span><br><span class="line">pii lcost = (i &gt; <span class="number">1</span> ? cost.query(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, i - <span class="number">1</span>) : make_pair(inf, <span class="number">0</span>)), rcost;</span><br><span class="line"><span class="keyword">while</span>(rpos &lt;= n &amp;&amp; (rcs[rpos].second &lt; i || !U[rcs[rpos].second])) ++rpos;</span><br><span class="line"><span class="keyword">if</span>(rpos &lt;= n) rcost = rcs[rpos], rcost.first -= sumC[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> rcost = make_pair(inf, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; lcost.second &lt;&lt; ' ' &lt;&lt; rcost.second &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span>(lcost &lt;= rcost) &#123;</span><br><span class="line"><span class="keyword">int</span> k = lcost.second;</span><br><span class="line">pii flowleft = flow.query(<span class="number">1</span>, <span class="number">1</span>, n, k, i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> nflow = min(flowleft.first, min(U[k], D[i]));</span><br><span class="line">flow.change(<span class="number">1</span>, <span class="number">1</span>, n, k, i - <span class="number">1</span>, -nflow);</span><br><span class="line">D[i] -= nflow; U[k] -= nflow;</span><br><span class="line">ans += <span class="number">1l</span>l * nflow * lcost.first;</span><br><span class="line"><span class="keyword">if</span>(!U[k]) cost.change(<span class="number">1</span>, <span class="number">1</span>, n, k, inf);</span><br><span class="line">flow.reset(<span class="number">1</span>, <span class="number">1</span>, n, k, i - <span class="number">1</span>, cost);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> k = rcost.second;</span><br><span class="line"><span class="keyword">int</span> nflow = min(U[k], D[i]);</span><br><span class="line">D[i] -= nflow; U[k] -= nflow;</span><br><span class="line">ans += <span class="number">1l</span>l * nflow * rcost.first;</span><br><span class="line"><span class="keyword">int</span> j = get(i);</span><br><span class="line"><span class="keyword">while</span>(j &lt;= k - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> fy = get(j + <span class="number">1</span>);</span><br><span class="line">flow.change(<span class="number">1</span>, <span class="number">1</span>, n, j, <span class="number">0</span>);</span><br><span class="line">fa[j] = fy; j = get(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k &gt; i) flow.change(<span class="number">1</span>, <span class="number">1</span>, n, i, k - <span class="number">1</span>, nflow);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == n) <span class="keyword">break</span>;</span><br><span class="line">cost.change(<span class="number">1</span>, <span class="number">1</span>, n, i, U[i] ? P[i] : inf);</span><br><span class="line">cost.change(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, i, fa[i] == i ? M[i] : -C[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 数据结构 </category>
          
          <category> 网络流 </category>
          
          <category> 线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 费用流 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1919 [Ctsc2010]性能优化</title>
      <link href="/2019/08/28/BZOJ1919-Ctsc2010-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/08/28/BZOJ1919-Ctsc2010-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1919" target="_blank" rel="noopener">BZOJ1919</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>据说是循环卷积板子题 需要对FFT有深刻的理解（不能只会敲模板）</p><p>FFT本身就是支持循环卷积的，只要把长度定为n就可以<br>令$ A,B,C $分别是点值表示的数组, $ a,b,c $为原数组<br>$$<br>A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\<br>B(\omega_n^k) = \sum_{i=0}^{n-1}b_i\omega_n^{ik} \\<br>C(\omega_n^k) = A(\omega_n^k) \times B(\omega_n^k)<br>= \sum_{i=0}^{n-1}a_i\omega_n^{ik}\sum_{i=0}^{n-1}b_i\omega_n^{ik}<br>$$<br>由于$ \omega_n^{k}=\omega_n^{k+n} $, 所以将其展开可得<br>$$<br>C(\omega_n^k) = \sum_{s=0}^{n-1}T_s\omega_n^{is}\\<br>T_s = \sum_{(i+j)mod(n+1)=s}a_i\cdot b_j<br>$$<br>我们要求的循环卷积$c$也就是$T$<br>所以实际上$C$就是$c$的卷积, 直接逆卷积回去就可以了. 证毕</p><p>然后要解决的问题是如何求任意长度FFT, 因为无法将其补成2的幂, 所以原来的板子行不通了<br>考虑n可以分解成P=2、3、5、7的幂，因此每次分治可以考虑分成P段，而不是单一的2段，但式子要重新搞。下面以3为例推一边，然后给出一个一般式子<br>$$<br>A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\<br>=(a_0\omega_n^k+a_3\omega_n^{3k}+a_6\omega_n^{6k}+…) \\+(a_1\omega_n^k+a_4\omega_n^{3k}+a_7\omega_n^{6k}+…) \\+(a_2\omega_n^k+a_5\omega_n^{3k}+a_8\omega_n^{6k}+…)  \\<br>= A_0(\omega_n^{3k}) + \omega_n^kA_1(\omega_n^{3k}) + \omega_n^{2k}A_2(\omega_n^{3k})<br>$$<br>这里按照3的同余系进行分组，$A_i$代表将a按照膜3的余数分组后递归求出的点值，同理可得<br>$$<br>A(\omega_n^{k+\frac{n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{2k}{3}}A_2(\omega_n^{3k}) \\<br>A(\omega_n^{k+\frac{2n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{2n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{4n}{3}}A_2(\omega_n^{3k}) \\<br>$$<br>然后这三个数就可以一起算了，方法类似FFT<br>对于其他的P，同理有如下式子<br>$$<br>A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_n^{Pk})<br>$$<br>或者写成如下形式更能看出来如何递归子问题<br>$$<br>A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_{\frac{n}{P}}^{k})<br>$$<br>也就是n的规模缩小了$\frac{1}{P}$，递归后每一个对应位置都枚举i，j求一下，需要一个临时数组来备份上一层的结果<br>也可以写非递归的，好像要预处理一下每个位置最后会移到哪里，但是递归也能A，我就没写迭代的（其实是懒）</p><p>最后的问题是FFT复数运算会存在极大精度问题，因为本题要快速幂算C次方，值域极大。<br>所以改成NTT，题目保证n+1是质数，又已经说了n最多4个质因数，因此求一下原根就好，这里在提一下原根求法（这里的n是题目中的n，求的是n+1的原根）<br>从2到n-1枚举g，验证g是原根的条件是：任意p是n的质因数，有<br>$$<br>g^{\frac{n}{p}} \neq 1\quad mod\ (n+1)<br>$$</p><p>为了做这题不得不复习一遍FFT的推导，本来只会敲板子的ε=(´ο｀*)))</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i(a), i##_AWSL(b); i &lt;= i##_AWSL; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drep(i, a, b) for(int i(a), i##_AWSL(b); i &gt;= i##_AWSL; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, C, mod, g, pr[<span class="number">10</span>], cnt;</span><br><span class="line">ll a[maxn], b[maxn], tmp[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getg</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">5</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">7</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span>(g = <span class="number">2</span>; g &lt;= n; g++) &#123;</span><br><span class="line"><span class="keyword">int</span> tag = <span class="number">0</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) <span class="keyword">if</span>(Power(g, n / pr[i]) % mod == <span class="number">1</span>) tag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!tag) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(ll *p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> len = r - l + <span class="number">1</span>, P = <span class="number">2</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) <span class="keyword">if</span>(len % pr[i] == <span class="number">0</span>) P = pr[i];</span><br><span class="line"><span class="keyword">int</span> lp = len / P;</span><br><span class="line">rep(i, <span class="number">0</span>, len - <span class="number">1</span>) tmp[(i % P) * lp + i / P] = p[l + i]; </span><br><span class="line">rep(i, <span class="number">0</span>, len - <span class="number">1</span>) p[l + i] = tmp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i += lp) ntt(p, i, i + lp - <span class="number">1</span>, inv);</span><br><span class="line">ll omega = Power(g, n / len), w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(inv &lt; <span class="number">0</span>) omega = Power(omega, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= l + lp - <span class="number">1</span>; i++, w = w * omega % mod) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= r; j += lp) tmp[j] = p[j];</span><br><span class="line">ll x = w, delta = Power(g, n / P);</span><br><span class="line"><span class="keyword">if</span>(inv &lt; <span class="number">0</span>) delta = Power(delta, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= r; j += lp, x = x * delta % mod) &#123;</span><br><span class="line">ll tim = <span class="number">1</span>; p[j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= r; k += lp, tim = tim * x % mod)</span><br><span class="line">p[j] = (p[j] + tmp[k] * tim % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;C); mod = n + <span class="number">1</span>;</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]);</span><br><span class="line">getg();</span><br><span class="line">ntt(a, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>); ntt(b, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) a[i] = a[i] * Power(b[i], C) % mod;</span><br><span class="line">ntt(a, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">ll tmp = Power(n, mod - <span class="number">2</span>);</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) a[i] = a[i] * tmp % mod;</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 多项式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> NTT </tag>
            
            <tag> 任意长度FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3672 [Noi2014]购票</title>
      <link href="/2019/07/18/BZOJ3672-Noi2014-%E8%B4%AD%E7%A5%A8/"/>
      <url>/2019/07/18/BZOJ3672-Noi2014-%E8%B4%AD%E7%A5%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3672" target="_blank" rel="noopener">BZOJ3672</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>$O(n^2)$的暴力dp很好想<br>$$<br>f[i] = min(f[j] + (dis[i] - dis[j])\times p_i + q_i),\quad dis[i] - dis[j] &lt;= l_i<br>$$<br>如果在一个序列上的话，这应该是一个经典的斜率优化，对于任意$ a &lt; b $，若要求对于i来说决策a比b更优，则<br>$$<br>p_i &lt; \frac{f[b] - f[a]}{dis[b] - dis[a]}<br>$$<br>由于p不具有单调性，因此不能从队头删除元素，而应在队列中二分查找最优的决策<br>再加上对于决策的位置有l的限制，因此还需要用线段树</p><p>那么对于本题，在树上进行转移，就需要树链剖分了<br>剖分后的线段树上每个节点开一个vector，维护这个节点的决策集合，一个原树上的点最多出现在log个vector中，因此空间复杂度是对的<br>一遍dfs进行转移，维护一个根到当前节点的栈，转移时通过跳top将所有满足小于等于$l_x$的点分割成线段树上的区间，在线段树的各个vector上二分查找最优决策，取最小值，得到当前dp值，再在线段树上进行修改，最多修改log个节点，每个节点把队尾不优的决策弹出，再压如新决策<br>网上的题解都把这个方法叫树剖线段树维护凸包</p><p>下面的代码洛谷上可过，BZOJ上会RE<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot, n, fa[maxn];</span><br><span class="line">ll edge[maxn * <span class="number">2</span>], P[maxn], q[maxn], L[maxn], dis[maxn], f[maxn];</span><br><span class="line"><span class="keyword">int</span> son[maxn], top[maxn], seg[maxn], rev[maxn], sz[maxn], cnt, sta[maxn], Tp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[maxn * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll z)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1.0</span> * (f[y] - f[x]) / (dis[y] - dis[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x]) &#123;</span><br><span class="line">        dis[ver[i]] = dis[x] + edge[i];</span><br><span class="line">        dfs1(ver[i]);</span><br><span class="line">        <span class="keyword">if</span>(sz[ver[i]] &gt; sz[son[x]]) son[x] = ver[i];</span><br><span class="line">        sz[x] += sz[ver[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    seg[x] = ++cnt; rev[cnt] = x;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) top[son[x]] = top[x], dfs2(son[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x] &amp;&amp; ver[i] != son[x]) &#123;</span><br><span class="line">        top[ver[i]] = ver[i];</span><br><span class="line">        dfs2(ver[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tail = vec[p].size();</span><br><span class="line">    <span class="keyword">while</span>(tail &gt; <span class="number">1</span> &amp;&amp; slope(rev[pos], vec[p][tail<span class="number">-1</span>]) &lt; slope(vec[p][tail<span class="number">-1</span>], vec[p][tail<span class="number">-2</span>])) tail--, vec[p].pop_back();</span><br><span class="line">    vec[p].push_back(rev[pos]);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) change(p*<span class="number">2</span>, l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = vec[p].size() - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(slope(vec[p][mid], vec[p][mid - <span class="number">1</span>]) &lt; (<span class="keyword">double</span>)P[i]) res = mid, l = mid + <span class="number">1</span>; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> v = vec[p][res];</span><br><span class="line">    <span class="keyword">return</span> f[v] + (dis[i] - dis[v]) * P[i] + q[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> calc(p, i); </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; ll res = inf;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) res = min(res, query(p*<span class="number">2</span>, l, mid, L, R, i));</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) res = min(res, query(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, i));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fly</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = x; x = fa[x];</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[des]) &#123;</span><br><span class="line">        f[X] = min(f[X], query(<span class="number">1</span>, <span class="number">1</span>, n, seg[top[x]], seg[x], X));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    f[X] = min(f[X], query(<span class="number">1</span>, <span class="number">1</span>, n, seg[des], seg[x], X));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sta[++Tp] = x;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = Tp; </span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[x] - dis[mid] &gt; L[x]) l = mid + <span class="number">1</span>; <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        Fly(x, l);</span><br><span class="line">    &#125;</span><br><span class="line">    change(<span class="number">1</span>, <span class="number">1</span>, n, seg[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x]) DFS(ver[i]);</span><br><span class="line">    Tp--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;z); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld%lld%lld"</span>, &amp;fa[i], &amp;z, &amp;P[i], &amp;q[i], &amp;L[i]);</span><br><span class="line">        add(i, fa[i], z), add(fa[i], i, z);</span><br><span class="line">    &#125;</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs1(<span class="number">1</span>); dfs2(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)); f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    DFS(<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
          <category> 树链剖分 </category>
          
          <category> 斜率优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 树链剖分 </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ4543 [POI2014]Hotel加强版</title>
      <link href="/2019/07/17/BZOJ4543-POI2014-Hotel%E5%8A%A0%E5%BC%BA%E7%89%88/"/>
      <url>/2019/07/17/BZOJ4543-POI2014-Hotel%E5%8A%A0%E5%BC%BA%E7%89%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4543" target="_blank" rel="noopener">BZOJ4543</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>长链剖分第一题<br>考虑答案只可能后两种情况</p><ol><li>一个点往下三个分支</li><li>一个点往下两个分支，其中一个再往下有两个分支</li></ol><p>考虑都在最上方的LCA处统计，鉴于第二种比较特殊，我们定义两个dp数组</p><p>令$f[i][j]$表示i的子树中与i距离为j的点数<br>令$g[i][j]$表示i的子树中，两个点到其lca距离均为d，且lca到i的距离为$d - j$的点对数</p><p>这样就可以在最上方的LCA由f和g拼接出两种情况，转移方程如下：(v是u的儿子)<br>$$<br>f[u][j] += f[v][j-1]<br>$$$$<br>g[u][j] += g[v][j+1]<br>$$$$<br>ans += f[u][j-1] \times g[v][j] + f[v][j] \times g[u][j+1]<br>$$$$<br>ans += g[u][0]<br>$$<br>这样的做法是$O(n^2)$的<br>可以使用长链剖分优化到$ O(nlogn) $<br>每个点的f和g数组可以由重儿子继承来，再讲请儿子合并进去<br>巧妙的地方在于，合并轻儿子时并不需要枚举满的第二维，只要枚举轻儿子的链长，因为轻儿子向下的最长长度就是链长。因此总共枚举的第二维实际上是$ O(n) $的<br>正是这一点巧妙地保证了时间复杂度。从重儿子继承只是其中必要的一环，优化的关键在于转移是可以与深度有关的。<br>不仅仅是状态与深度有关，转移也要与深度有关</p><p>还有关于如何从重儿子继承的问题，可以直接复制指针，但数组指针无法修改，单单是一个指针的话没有内存是无法下标访问的，因此事先为所有点声明好空间（也是$O(n)$)的。代码中的id变量的作用就是为每个指针预留下足够的空间。<br>具体可以研究代码，是一个新技巧。<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> son[maxn], mx[maxn], *f[maxn], *g[maxn], fa[maxn], tmp[maxn * <span class="number">6</span>], *id = tmp;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">    fa[x] = pa; mx[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) &#123;</span><br><span class="line">        dfs(ver[i], x);</span><br><span class="line">        <span class="keyword">if</span>(mx[ver[i]] + <span class="number">1</span> &gt; mx[x]) son[x] = ver[i], mx[x] = mx[ver[i]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Give</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; f[x] = id; id += mx[x] + <span class="number">1</span>; id += mx[x] + <span class="number">1</span>; g[x] = id; id += mx[x] + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) f[son[x]] = f[x] + <span class="number">1</span>, g[son[x]] = g[x] - <span class="number">1</span>, dp(son[x]);</span><br><span class="line">    f[x][<span class="number">0</span>] = <span class="number">1</span>; ans += g[x][<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x] &amp;&amp; ver[i] != son[x])&#123;</span><br><span class="line">        Give(ver[i]); dp(ver[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mx[ver[i]]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j) ans += f[x][j<span class="number">-1</span>] * g[ver[i]][j];</span><br><span class="line">            ans += g[x][j+<span class="number">1</span>] * f[ver[i]][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mx[ver[i]]; j++) &#123;</span><br><span class="line">            g[x][j+<span class="number">1</span>] += f[x][j+<span class="number">1</span>] * f[ver[i]][j];</span><br><span class="line">            <span class="keyword">if</span>(j) g[x][j<span class="number">-1</span>] += g[ver[i]][j];</span><br><span class="line">            f[x][j+<span class="number">1</span>] += f[ver[i]][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>); Give(<span class="number">1</span>); dp(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 动态规划 </category>
          
          <category> 树形dp </category>
          
          <category> 长链剖分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
            <tag> 长链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1488 [HNOI2009]图的同构</title>
      <link href="/2019/07/15/BZOJ1488-HNOI2009-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84/"/>
      <url>/2019/07/15/BZOJ1488-HNOI2009-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://lydsy.com/JudgeOnline/problem.php?id=1488" target="_blank" rel="noopener">BZOJ1488</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意求N个点不同构图的个数<br>显然要用Burnside引理<br>思路就是求出每个置换的循环个数，求2的幂的平均值<br>需要注意求的是<strong>点</strong>置换下的<strong>边</strong>循环<br>分情况讨论：</p><ol><li><p>一个长度为$x$的点的循环内部有$\lfloor\frac{x}{2}\rfloor$个边的循环。</p></li><li><p>两个长度分别为$x$和$y$的点的循环之间有$gcd(x,y)$个边的循环</p></li></ol><p>这个画画图就能明白，对于第一点，实际上是不同“长度”的边，对于第二点，每个循环节的长度一定是lcm，因此个数就是gcd</p><p>但是置换共有$n!$个，无法枚举<br>事实上我们只需要知道每个循环的大小，求出来后乘以方案数即可。因此考虑枚举n的拆分，求出每种拆分的方案数。设共k个循环，长度分别为$a[i]$，每种长度有$c[i]$个，则方案数为：<br>$$<br>\frac{n!}{\Pi a[i]\Pi c[i]！}<br>$$<br>因为长度相同的要除以排列数，每一个循环里会有$a[i]$个是循环相同的，也要除掉</p><p>最后，本题卡常，gcd和逆元都要预处理，少了一个都会TLE（亲身实践）<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">65</span>, mod = <span class="number">997</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn], cnt, fac[maxn], c[maxn], ans, rev[maxn], rfac[maxn], g[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">int</span> res = <span class="number">1</span>; <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod; <span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">if</span>(!x) <span class="keyword">return</span> y; <span class="keyword">return</span> gcd(y % x, x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = fac[n], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c[i]; j++) a[++cnt] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) tmp = tmp * rev[a[i]] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(c[i]) tmp = tmp * rfac[c[i]] % mod;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) num += a[i] / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= cnt; j++) num += g[a[i]][a[j]];</span><br><span class="line">    ans = (ans + tmp * Power(<span class="number">2</span>, num) % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) &#123; c[<span class="number">1</span>] = n - s; calc(); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s + i * x &lt;= n; i++) c[x] = i, dfs(x - <span class="number">1</span>, s + i * x), c[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = fac[i<span class="number">-1</span>] * i % mod, rfac[i] = Power(fac[i], mod - <span class="number">2</span>);</span><br><span class="line">    rev[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) rev[i] = (mod - mod / i) % mod * rev[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) g[i][j] = gcd(i, j);</span><br><span class="line">    dfs(n, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * Power(fac[n], mod - <span class="number">2</span>) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 组合 </category>
          
          <category> Burnside引理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> Burnside引理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ2655 calc</title>
      <link href="/2019/07/15/BZOJ2655-calc/"/>
      <url>/2019/07/15/BZOJ2655-calc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2655" target="_blank" rel="noopener">BZOJ2655</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>我真是见识到了插值这个东西的好处<br>第一步的想法是直接退出一个式子，这样最好，如果没有两两不同的限制，那么式子很简单就是$[\frac{A(A+1)}{2}]^n$<br>多了不同这个限制，那么容斥就好了，总方案$-$一对相同$+$两对相同$-…$<br>这样写出式子看看<br>$$<br>(\sum_{i=1}^Ai)^n-C_{n-1}^1(\sum_{i=1}^Ai)^{n-2}(\sum_{i=1}^Ai^2)+…<br>$$<br>但是第三项开始就不好写了，因为可能是三连等，也可能有两对分别相同<br>然而我们可以发现不管怎么写，这个式子始终是一个关于A的$2n$次多项式。每一项都是这个次数。<br>然后用插值就好了，根本不用考虑什么烦人的容斥，反正插出来都一样<br>这样A再大都可以被降到2n的级别，考虑暴力做法算$0…2n$的函数值就可以了<br>实在是太神了，感觉什么都没做，就解决了容斥的问题！<br>暴力的部分用dp就可以了，令$f[i][j]$表示j个小于等于i的正整数的所有序列的值得和，则<br>$$<br>f[i][j] = f[i-1][j-1] \times i \times j + f[i-1][j]<br>$$<br>意思是，如果j个数中有i，共有j种情况，每种的值都会乘以i，从f[i-1][j-1]转移，否则和f[i-1][j]相同</p><p>感觉如果发现某题的式子是个多项式，那么这题就可以转化为暴力题了<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll mod, A, n, f[maxn*<span class="number">2</span>][maxn], ans;</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;A, &amp;n, &amp;mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            f[i][j] = (f[i<span class="number">-1</span>][j<span class="number">-1</span>] * i % mod * j % mod + f[i<span class="number">-1</span>][j]) % mod;</span><br><span class="line">    <span class="keyword">if</span>(A &lt;= n * <span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[A][n]); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        ll s1 = <span class="number">1</span>, s2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n * <span class="number">2</span>; j++) <span class="keyword">if</span>(i != j) </span><br><span class="line">            s1 = (A - j + mod) % mod * s1 % mod, s2 = (i - j + mod) % mod * s2 % mod;</span><br><span class="line">        ans = (ans + s1 * f[i][n] % mod * Power(s2, mod - <span class="number">2</span>) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 动态规划 </category>
          
          <category> 拉格朗日插值 </category>
          
          <category> 计数dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数dp </tag>
            
            <tag> 拉格朗日插值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ5339 [TJOI2018]教科书般的亵渎</title>
      <link href="/2019/07/14/BZOJ5339-TJOI2018-%E6%95%99%E7%A7%91%E4%B9%A6%E8%88%AC%E7%9A%84%E4%BA%B5%E6%B8%8E/"/>
      <url>/2019/07/14/BZOJ5339-TJOI2018-%E6%95%99%E7%A7%91%E4%B9%A6%E8%88%AC%E7%9A%84%E4%BA%B5%E6%B8%8E/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5339" target="_blank" rel="noopener">BZOJ5339</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题面好难理解啊<br>不过多看几遍，再算算样例，也就懂了<br>可以转化为求$ \sum_{i=1}^ni^m $（n，m不是题面中的）<br>经典的自然数幂和问题，有五种经典算法</p><ul><li>伯努利数</li><li>递推</li><li>差分序列</li></ul><p>我使用了另外两种方法</p><h2><span id="拉格朗日插值">拉格朗日插值</span></h2><p>$m$次自然数幂和是一个$m+1$次多项式，可以举$m=1$的例子，容易发现这一点<br>这样将$x=0…m+1$带进去，得到$m+2$个点，然后插值即可<br>暴力做法$O(m^2)$，但由于取的是等间隔的x，因此可以优化到$O(m)$</p><h2><span id="第二类斯特林数">第二类斯特林数</span></h2><p>下文中加点表示降阶函数，也就是下划线<br>第二类斯特林数有生成函数<br>$$<br>x^n=\sum_{i=0}^n<br>\begin{Bmatrix}<br>n \\<br>i \\<br>\end{Bmatrix}x^{i.}<br>$$<br>因此原式可以这样展开<br>$$<br>\sum_{i=0}^ni^m = \sum_{i=0}^n\sum_{j=0}^m<br>\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}i^{j.}<br>$$<br>$$<br>=\sum_{j=0}^m\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}j!\sum_{i=0}^n\begin{pmatrix}<br>i \\<br>j \\<br>\end{pmatrix}<br>$$<br>$$<br>= \sum_{j=0}^m\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}j!\begin{pmatrix}<br>n + 1 \\<br>j + 1 \\<br>\end{pmatrix}<br>$$<br>$$<br>=\sum_{j=1}^m\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}\frac{(n+1)^{(j+1).}}{j+1}<br>$$<br>然后就可以$O(n^2)$算了<br><a id="more"></a></p><h1><span id="code">Code</span></h1><h2><span id="拉格朗日插值">拉格朗日插值</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">60</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn], pre[maxn], suf[maxn], y[maxn], fac[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    y[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m + <span class="number">1</span>; i++) y[i] = (y[i<span class="number">-1</span>] + Power(i, m)) % mod;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= m + <span class="number">1</span>) <span class="keyword">return</span> y[n];</span><br><span class="line">    pre[<span class="number">0</span>] = n; suf[m + <span class="number">1</span>] = n - m - <span class="number">1</span>; fac[<span class="number">0</span>] = <span class="number">1</span>; suf[m + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) pre[i] = pre[i<span class="number">-1</span>] * (n - i) % mod, fac[i] = fac[i<span class="number">-1</span>] * Power(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i--) suf[i] = suf[i+<span class="number">1</span>] * (n - i) % mod;</span><br><span class="line">    ll res = suf[<span class="number">1</span>] * fac[m + <span class="number">1</span>] % mod * y[<span class="number">0</span>] % mod;</span><br><span class="line">    <span class="keyword">if</span>((m + <span class="number">1</span>) &amp; <span class="number">1</span>) res = (mod - res) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ll tmp = suf[i + <span class="number">1</span>] * pre[i - <span class="number">1</span>] % mod * fac[i] % mod * fac[m + <span class="number">1</span> - i] % mod;</span><br><span class="line">        <span class="keyword">if</span>((m - i + <span class="number">1</span>) &amp; <span class="number">1</span>) tmp = (mod - tmp) % mod;</span><br><span class="line">        res = (res + tmp * y[i] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    ll n, m;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">        a[m + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                ans= (ans + S(a[j] - a[i<span class="number">-1</span>] - <span class="number">1</span>, m + <span class="number">1</span>)) % mod;</span><br><span class="line">                ans = (ans + mod - S(a[j<span class="number">-1</span>] - a[i<span class="number">-1</span>], m + <span class="number">1</span>)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="第二类斯特林数">第二类斯特林数</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">60</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn], pre[maxn], suf[maxn], y[maxn], fac[maxn], s[maxn][maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= m) &#123; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = (res + Power(i, m)) % mod; <span class="keyword">return</span> res; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        ll tmp = s[m][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n - i + <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++) tmp = tmp * j % mod;</span><br><span class="line">        tmp = tmp * Power(i + <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        res = (res + tmp) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    ll n, m;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) s[i][j] = (s[i<span class="number">-1</span>][j<span class="number">-1</span>] + s[i<span class="number">-1</span>][j] * j % mod) % mod;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">        a[m + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                ans= (ans + S(a[j] - a[i<span class="number">-1</span>] - <span class="number">1</span>, m + <span class="number">1</span>)) % mod;</span><br><span class="line">                ans = (ans + mod - S(a[j<span class="number">-1</span>] - a[i<span class="number">-1</span>], m + <span class="number">1</span>)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 拉格朗日插值 </category>
          
          <category> 斯特林数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拉格朗日插值 </tag>
            
            <tag> 自然数幂和 </tag>
            
            <tag> 第二类斯特林数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ2806 [Ctsc2012]Cheat</title>
      <link href="/2019/07/13/BZOJ2806-Ctsc2012-Cheat/"/>
      <url>/2019/07/13/BZOJ2806-Ctsc2012-Cheat/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2806" target="_blank" rel="noopener">BZOJ2806</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>容易发现，L具有单调性，因此可以二分答案<br>考虑如何判定，分段，长度有限制，容易想到经典的1D1D动规，方程如下：<br>$$<br>f[i] = max(f[j] + i - j, f[i-1]),\ i - maxlen[i] \leq j \leq i - L<br>$$<br>其中maxlen表示以i为右端点能够匹配的最长子串<br>这个方程明显可以用单调队列优化，由于左右都有限制，因此每次入队入的是很久之前算的那个位置<br><del>我最开始的写法不知为何是错的，不知为何啊</del><br>剩下的就是怎样算maxlen<br>将所有的模板串建成广义后缀自动机，之后所有的maxlen可以用一个自动机上的指针一遍预处理出来，就是每次如果无法向下转移就跳父亲，直到可以走DAG为止，跳完父亲len要用val更新，走转移边就是len++，这样才能保证正确</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2200010</span>;</span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">2</span>], par[maxn], val[maxn], rt = <span class="number">1</span>, cnt = <span class="number">1</span>, las = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np = ++cnt, p = las; val[np] = val[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line">    <span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][x];</span><br><span class="line">        <span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line">            ch[nq][<span class="number">0</span>] = ch[q][<span class="number">0</span>]; ch[nq][<span class="number">1</span>] = ch[q][<span class="number">1</span>];</span><br><span class="line">            par[nq] = par[q];</span><br><span class="line">            par[q] = par[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    las = np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> ml[maxn], f[maxn], q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] - x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) f[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; calc(q[tail]) &lt; calc(i - l)) tail--;</span><br><span class="line">        q[++tail] = i - l;</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; q[head] &lt; i - ml[i]) head++;</span><br><span class="line">        <span class="keyword">if</span>(head &lt;= tail) f[i] = max(f[i], calc(q[head]) + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n] * <span class="number">10</span> &gt;= n * <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(str); j++) extend(str[j] - <span class="string">'0'</span>);</span><br><span class="line">        las = rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>); m = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cur = rt, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = str[j] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">while</span>(cur &amp;&amp; !ch[cur][u]) cur = par[cur], len = val[cur];</span><br><span class="line">            <span class="keyword">if</span>(!cur) &#123; ml[j] = <span class="number">0</span>; cur = rt; len = <span class="number">0</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            cur = ch[cur][u]; len++;</span><br><span class="line">            ml[j] = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = m;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid, m)) l = mid; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 字符串 </category>
          
          <category> 后缀自动机 </category>
          
          <category> 单调队列优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀自动机 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3926 [Zjoi2015]诸神眷顾的幻想乡</title>
      <link href="/2019/07/12/BZOJ3926-Zjoi2015-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/"/>
      <url>/2019/07/12/BZOJ3926-Zjoi2015-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3926" target="_blank" rel="noopener">BZOJ3926</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>20min 1A庆祝一下<br>国家队论文写过一个trie上SAM的科技<br>其实可以类比广义后缀自动机加入多个串，trie树上无非是每个点插入前将las移到其父亲对应的节点<br>本题由于叶子不超过20个，以每个叶子为根，分别遍历一遍trie，全部加入一个广义自动机中，累计每个节点的max-min+1即可<br>由于所有有向路径都可以看成以一个叶子为根的一个直的路径（也就是trie上的“子串”），因此正确性可以保证<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, C, col[maxn], head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot;</span><br><span class="line"><span class="keyword">int</span> du[maxn], cnt = <span class="number">1</span>, rt = <span class="number">1</span>, ch[maxn * <span class="number">40</span>][<span class="number">10</span>], par[maxn * <span class="number">40</span>], val[maxn * <span class="number">40</span>], pos[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np = ++cnt; val[np] = val[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line">    <span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][x];</span><br><span class="line">        <span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span>(ch[nq]));</span><br><span class="line">            par[nq] = par[q];</span><br><span class="line">            par[q] = par[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    pos[x] = extend(col[x], pos[fa]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa) dfs(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;C);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x), du[x]++, du[y]++;</span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(du[i] == <span class="number">1</span>) dfs(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) ans += val[i] - val[par[i]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
          <category> 后缀自动机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀自动机 </tag>
            
            <tag> trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3669 [Noi2014]魔法森林</title>
      <link href="/2019/07/10/BZOJ3669-Noi2014-%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97/"/>
      <url>/2019/07/10/BZOJ3669-Noi2014-%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3669" target="_blank" rel="noopener">BZOJ3669</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>第一想法是二分<br>然而不能二分a+b，更不能二分a或b<br>因此把a和b分开考虑<br>将所有边按照a排序，把b看成边权，一条一条加进去，维护1到n的最大边权最小的路径，随时更新答案<br>容易证明这条路径一定在最小生成树上<br>因此要在加边的过程中维护最小生成树<br>需要支持询问两点路径上的最大边权，以及最大边权所在的是那条边<br>加边时若构成环，则查询路径上的最大边，若大于当前边，则cut掉，然后加入当前边，否则跳过<br>若不构成环，就直接加入当前边<br>使用LCT维护，每个点记录子树最大权值及取到的位置，由于LCT只能维护点权，因此为每条边新建一个点，连到边的两个端点上<br>本题一遍过！！！<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>, maxm = <span class="number">100010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, val[maxn + maxm], fa[maxn + maxm], ch[maxn + maxm][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pos[maxn + maxm], sta[maxn + maxm], mx[maxn + maxm], rev[maxn + maxm];</span><br><span class="line"><span class="keyword">int</span> ans = inf;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edg</span> &#123;</span> <span class="keyword">int</span> x, y, a, b; &#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edg x, Edg y)</span> </span>&#123; <span class="keyword">return</span> x.a &lt; y.a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] != x &amp;&amp; ch[fa[x]][<span class="number">0</span>] != x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) <span class="built_in">printf</span>(<span class="string">"%d %d %d %d %d %d\n"</span>, i, fa[i], ch[i][<span class="number">0</span>], ch[i][<span class="number">1</span>], mx[i], rev[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mx[x] = max(val[x], max(mx[ch[x][<span class="number">0</span>]], mx[ch[x][<span class="number">1</span>]]));</span><br><span class="line">    <span class="keyword">if</span>(mx[x] == val[x]) pos[x] = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mx[x] == mx[ch[x][<span class="number">0</span>]]) pos[x] = pos[ch[x][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">else</span> pos[x] = pos[ch[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] ^= <span class="number">1</span>; rev[ch[x][<span class="number">0</span>]] ^= <span class="number">1</span>; rev[ch[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], d = get(x);</span><br><span class="line">    ch[y][d] = ch[x][d ^ <span class="number">1</span>]; fa[ch[y][d]] = y;</span><br><span class="line">    <span class="keyword">if</span>(!isroot(y)) ch[fa[y]][get(y)] = x;</span><br><span class="line">    fa[x] = fa[y];</span><br><span class="line">    ch[x][d ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">    pushup(y); pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>; sta[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) sta[++top] = fa[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i; i--) pushdown(sta[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pa = fa[x]; !isroot(x); pa = fa[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isroot(pa)) rotate(get(x) == get(pa) ? pa : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; x; t = x, x = fa[x]) </span><br><span class="line">        splay(x), ch[x][<span class="number">1</span>] = t, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); rev[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) pushdown(x), x = ch[x][<span class="number">0</span>]; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); access(y); splay(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); ch[y][<span class="number">0</span>] = fa[x] = <span class="number">0</span>; pushup(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); fa[x] = y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;edge[i].x, &amp;edge[i].y, &amp;edge[i].a, &amp;edge[i].b);</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) val[i + n] = mx[i + n] = edge[i].b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = edge[i].x, y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(findroot(x) == findroot(y)) &#123;</span><br><span class="line">            makeroot(x); access(y); splay(y);</span><br><span class="line">            <span class="keyword">if</span>(mx[y] &gt; edge[i].b) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = pos[y];</span><br><span class="line">                <span class="keyword">int</span> lc = edge[tmp - n].x, rc = edge[tmp - n].y;</span><br><span class="line">                cut(tmp, lc); cut(tmp, rc);</span><br><span class="line">                link(x, i + n); link(y, i + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> link(x, i + n), link(y, i + n);</span><br><span class="line">    <span class="comment">//debug(); cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(findroot(<span class="number">1</span>) != findroot(n)) <span class="keyword">continue</span>;</span><br><span class="line">        split(<span class="number">1</span>, n);</span><br><span class="line">        ans = min(ans, edge[i].a + mx[n]);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == inf) ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> LCT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ2049 [Sdoi2008]Cave 洞穴勘测</title>
      <link href="/2019/07/08/BZOJ2049-Sdoi2008-Cave-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B/"/>
      <url>/2019/07/08/BZOJ2049-Sdoi2008-Cave-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2049" target="_blank" rel="noopener">BZOJ2049</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>不能再裸的LCT裸题<br>好久没写了，写道题复习一下，再练难的<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>, maxm = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn], ch[maxn][<span class="number">2</span>], rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"><span class="keyword">int</span> sta[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] ^= <span class="number">1</span>; rev[ch[x][<span class="number">0</span>]] ^= <span class="number">1</span>; rev[ch[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = get(x);</span><br><span class="line">    ch[y][z] = ch[x][z ^ <span class="number">1</span>]; fa[ch[y][z]] = y;</span><br><span class="line">    <span class="keyword">if</span>(!isroot(y)) ch[fa[y]][get(y)] = x; </span><br><span class="line">    fa[x] = fa[y];</span><br><span class="line">    ch[x][z ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>; sta[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) sta[++top] = fa[i];</span><br><span class="line">    <span class="keyword">while</span>(top) pushdown(sta[top--]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pa = fa[x]; !isroot(x); pa = fa[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isroot(pa)) rotate(get(x) == get(pa) ? pa : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; x; t = x, x = fa[x])</span><br><span class="line">        splay(x), ch[x][<span class="number">1</span>] = t;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); rev[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) pushdown(x), x = ch[x][<span class="number">0</span>]; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); access(y); splay(y); fa[x] = ch[y][<span class="number">0</span>] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); fa[x] = y; &#125;</span><br><span class="line"><span class="keyword">char</span> o[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, o, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'C'</span>) link(x, y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'D'</span>) cut(x, y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'Q'</span>) <span class="built_in">printf</span>(findroot(x) == findroot(y) ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> LCT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ2729 [HNOI2012]排队</title>
      <link href="/2019/07/08/BZOJ2729-HNOI2012-%E6%8E%92%E9%98%9F/"/>
      <url>/2019/07/08/BZOJ2729-HNOI2012-%E6%8E%92%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2729" target="_blank" rel="noopener">BZOJ2729</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>插板法<br>以男生为基准，先插老师，再插女生<br>若老师之间有男生，就是n插2，再插m<br>若老师之间无男生，则之间只有一个女生，看成一个男生，n+1插m-1<br>答案为<br>$$<br>n!A_{n+1}^2A_{n+3}^m + 2m(n+1)!A_{n+2}^{m-1}<br>$$<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bigint</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> len, a[maxn * <span class="number">1000</span>];</span><br><span class="line">&#125;ans, ans1, ans2;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> += (bigint &amp;x, bigint &amp;y) &#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">x.len = max(x.len, y.len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++) </span><br><span class="line">x.a[i] += y.a[i] + t, t = x.a[i] / <span class="number">10</span>, x.a[i] %= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(t) x.a[++x.len] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> *= (bigint &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++) </span><br><span class="line">x.a[i] *= y, x.a[i] += t, t = x.a[i] / <span class="number">10</span>, x.a[i] %= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(t) x.a[++x.len] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(bigint &amp;x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x.len; i; i--) <span class="built_in">printf</span>(<span class="string">"%d"</span>, x.a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">ans1.len = <span class="number">1</span>; ans1.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">ans2 = ans1;</span><br><span class="line">ans1 *= n + <span class="number">1</span>; ans1 *= n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans1 *= n + <span class="number">4</span> - i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans1 *= i;</span><br><span class="line">ans2 *= <span class="number">2</span> * m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) ans2 *= n + <span class="number">3</span> - i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) ans2 *= i;</span><br><span class="line">ans1 += ans2;</span><br><span class="line">print(ans1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 组合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ2212 [Poi2011]Tree Rotations</title>
      <link href="/2019/07/07/BZOJ2212-Poi2011-Tree-Rotations/"/>
      <url>/2019/07/07/BZOJ2212-Poi2011-Tree-Rotations/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2212" target="_blank" rel="noopener">BZOJ2212</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>每个节点翻转所影响的逆序对是它的两棵子树之间的逆序对个数，其他的和子树内的都不影响<br>在读入的过程中就是一个dfs，在这个过程中考虑每个点是否翻转，也就是右节点中小于左节点的数对数<br>可以用线段树合并完成，每个点维护一个权值线段树和区间和<br>用子节点合并得到父节点，在合并时顺便统计一下前边所说的数对的个数，判断是否翻转，并累计答案</p><p>好了，正经话说完了，下面吐槽<br>我自认为代码写的很精炼，经过一番调试后在洛谷拿到了95分，剩下的一个点是MLE<br>最开始线段树节点数开的是maxn*50，<br>所以调成40，然后MLE<br>所以调成30，然后MLE<br>所以调成20，然后RE<br>看到人们很多写5000000，改成这个，然后MLE<br>这个点就对不了了吗[○･｀Д´･ ○]<br>去loj看看，然后发现了55个测试点，然后后面十几个点要么RE，要么TLE<br>网上的人说洛谷数据水，loj强，线段树合并过不去<br>最后去了BZOJ碰碰运气，结果RE<br>于是我下载了LOJ上一个大数据，开无线栈开始跑，打开任务管理器看占用内存<br>只见内存的那一个数据从9Mb，一路稳步上升，几分钟后达到了156Mb<br>对，几分钟后这个程序还在跑<br>然后突然156Mb降到了9Mb，程序异常退出。。。<br>不MLE+TLE+RE才怪<br>算了，我不纠结这个玄学的线段树合并了<br>它的复杂度到底会到多少啊。。。<br>下面贴上满是锅的代码<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, rt[maxn * <span class="number">8</span>], num, sum[maxn * <span class="number">30</span>], lc[maxn * <span class="number">30</span>], rc[maxn * <span class="number">30</span>], cnt;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function">ll <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> lp, <span class="keyword">int</span> rp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lp || !rp) &#123; p = lp + rp; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    p = ++cnt;</span><br><span class="line">    ll res = sum[lc[rp]] * sum[rc[lp]];</span><br><span class="line">    sum[p] = sum[lp] + sum[rp];</span><br><span class="line">    res += merge(lc[p], lc[lp], lc[rp]);</span><br><span class="line">    res += merge(rc[p], rc[lp], rc[rp]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    p = ++cnt;</span><br><span class="line">    sum[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) build(lc[p], l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> build(rc[p], mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(!x) &#123;</span><br><span class="line">        <span class="keyword">int</span> L = fuck(), R = fuck();</span><br><span class="line">        ll res = merge(rt[++num], rt[L], rt[R]);</span><br><span class="line">        ans += min(res, sum[rt[L]] * sum[rt[R]] - res);</span><br><span class="line">    &#125; <span class="keyword">else</span> build(rt[++num], <span class="number">1</span>, n, x);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    fuck();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3653 谈笑风生</title>
      <link href="/2019/07/07/BZOJ3653-%E8%B0%88%E7%AC%91%E9%A3%8E%E7%94%9F/"/>
      <url>/2019/07/07/BZOJ3653-%E8%B0%88%E7%AC%91%E9%A3%8E%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3653" target="_blank" rel="noopener">BZOJ3653</a>和<a href="https://www.luogu.org/problemnew/show/P3899" target="_blank" rel="noopener">洛谷P3899</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>由题意，b和a一定是祖先关系<br>若b是a的祖先，c在a的子树内，直接乘法累计即可<br>若a是b的祖先，题意转换为以a为根的子树内，与a距离$\leq k$的点的sz之和<br>可以使用主席树或线段树合并<br>主席树：<br>构造欧拉序列，以dfn为时间轴建立以dep为下标的权值线段树<br>一个节点的子树在欧拉序列上是一个区间，查分询问即可<br>线段树合并：<br>每个点建一颗以dep为下表的权值线段树，父节点由子节点得来，考虑空间会炸，所以父节点由子节点线段树合并来<br>代码为主席树，注意long long<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300010</span>, maxm = <span class="number">600010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxm], Next[maxm], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, sz[maxn], d[maxn], dfn[maxn], num;</span><br><span class="line"><span class="keyword">int</span> rt[maxn * <span class="number">4</span>], cnt, lc[maxn * <span class="number">40</span>], rc[maxn * <span class="number">40</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxn * <span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> las, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = ++cnt;</span><br><span class="line">    sum[p] = sum[las] + x;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> p;</span><br><span class="line">    lc[p] = lc[las]; rc[p] = rc[las]; </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) lc[p] = update(lc[las], l, mid, pos, x);</span><br><span class="line">    <span class="keyword">else</span> rc[p] = update(rc[las], mid + <span class="number">1</span>, r, pos, x);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    d[x] = d[fa] + <span class="number">1</span>; sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa) dfs(ver[i], x), sz[x] += sz[ver[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[x] = ++num;</span><br><span class="line">    rt[num] = update(rt[num - <span class="number">1</span>], <span class="number">1</span>, n, d[x], sz[x] - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa) build(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rp, <span class="keyword">int</span> lp, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[rp] - sum[lp];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) res += query(lc[rp], lc[lp], l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) res += query(rc[rp], rc[lp], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, Q, a, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>); build(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;k);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = min(d[a] - <span class="number">1</span>, k) * ((<span class="keyword">long</span> <span class="keyword">long</span>)sz[a] - <span class="number">1</span>);</span><br><span class="line">        ans += query(rt[dfn[a] + sz[a] - <span class="number">1</span>], rt[dfn[a] - <span class="number">1</span>], <span class="number">1</span>, n, d[a] + <span class="number">1</span>, d[a] + k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 可持久化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019扬中Day2</title>
      <link href="/2019/07/05/2019%E6%89%AC%E4%B8%ADDay2/"/>
      <url>/2019/07/05/2019%E6%89%AC%E4%B8%ADDay2/</url>
      
        <content type="html"><![CDATA[<p>这场比赛前两题我用自己的非正解算法水到了188分<br>真是好水的数据<br>题目出的很模拟赛<br><a id="more"></a><br>题目在这里<br><div class="row">    <embed src="problems.pdf" width="100%" height="550" type="application/pdf"></div></p><h1><span id="纸牌游戏cards">纸牌游戏（cards）</span></h1><p>我的算法就很奇怪了，$f[i][j]$只任选i个，gcd为j的方案数，然后第一问转化成组合数问题一通推式子得到$$ ans=\sum_{i=1}^{n/2}\frac{f[2<em>i][1]}{C_{n}^{i}}-\frac{f[2</em>i-1][1]}{C_{n}^{i-1}} $$<br>然后第二问不好做</p><p>其实正解很巧妙，难点就在于如何记录状态，要记录gcd，还要记录那些选了，但又不能状压<br>注意到如果当前gcd为x，那么之前选的所有数都是x的倍数，而所有x的倍数在此时应给是地位相等的，都再也不会更新gcd。这样就方便记录哪些数已经选过了<br>用$ f[i][j] $表示选了i个，gcd为j的概率，注意此时选的i个都是x的倍数，那么有<br>$$<br>f[i+1][j] += f[i][j]\times \frac{sum[j]-i}{n} \\<br>f[i+1][gcd(a[k], j)] += f[i][j]\times \frac{1}{n}<br>$$<br>其中$sum[j]$表示j的倍数的个数<br>转移方程很巧妙啊，本应枚举所有未选的数，但这不现实，因此枚举所有一定不可能被选过的数，剩下哪些不确定的只要知道个数就可以了</p><p>如果第一问的状态方程这样写，那么第二问用类似的方法配合SG函数方法就可以了，具体参见标程，用记忆化搜索，把乘法换成必胜必败的判定即可</p><p>my第一问<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">310</span>, maxm = <span class="number">1010</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmin</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = min(a, b); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmax</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = max(a, b); &#125;</span><br><span class="line"><span class="keyword">int</span> a[maxn], mx, n;</span><br><span class="line"><span class="keyword">double</span> f[maxn][maxm], c[maxn][maxn], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!a) <span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">return</span> gcd(b % a, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"cards.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"cards.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), mx = max(mx, a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) c[i][<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) c[i][j] = c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; c[n][i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0</span>; f[<span class="number">1</span>][a[<span class="number">1</span>]] = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= mx; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[j][k]) </span><br><span class="line">f[j + <span class="number">1</span>][gcd(k, a[i + <span class="number">1</span>])] += f[j][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i = 0; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">//for(int j = 0; j &lt;= mx; j++) cout &lt;&lt; f[i][j] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) ans += f[i][<span class="number">1</span>] / c[n][i] - f[i<span class="number">-1</span>][<span class="number">1</span>] / c[n][i<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf\n"</span>, ans);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>std满分做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> mx,a[N],g[N][N],sum[N],visit[N][N],zy[N][N],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">int</span> y=a%b;</span><br><span class="line"><span class="keyword">while</span> (y)</span><br><span class="line">&#123;</span><br><span class="line">a=b; b=y; y=a%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i][j]) <span class="keyword">return</span> g[i][j];</span><br><span class="line">visit[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (j==<span class="number">1</span>) <span class="keyword">return</span> g[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i&gt;n) <span class="keyword">return</span> g[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i&lt;=sum[j] &amp;&amp; calc(i+<span class="number">1</span>,j)==<span class="number">0</span>) <span class="keyword">return</span> g[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">if</span> ((j==<span class="number">0</span> || a[k]%j) &amp;&amp; calc(i+<span class="number">1</span>,zy[j][k])==<span class="number">0</span>) <span class="keyword">return</span> g[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> g[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"cards.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"cards.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">cur=gcd(cur,a[i]);</span><br><span class="line">mx=max(mx,a[i]);</span><br><span class="line">f[<span class="number">1</span>][a[i]]+=(<span class="keyword">double</span>)<span class="number">1</span>/n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=mx;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span> (a[j]%i==<span class="number">0</span>) sum[i]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mx;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">zy[i][j]=gcd(i,a[j]);</span><br><span class="line"><span class="keyword">if</span> (cur!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>,<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=mx;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(f[i][j])&lt;=eps || i&gt;sum[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">if</span> (a[k]%j)</span><br><span class="line">f[i+<span class="number">1</span>][zy[j][k]]+=f[i][j]*<span class="number">1</span>/(n-i);</span><br><span class="line">f[i+<span class="number">1</span>][j]+=f[i][j]*(sum[j]-i)/(n-i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i+=<span class="number">2</span>) ans+=f[i][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.10lf "</span>,ans);</span><br><span class="line">calc(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (g[<span class="number">1</span>][<span class="number">0</span>]) <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>,<span class="number">1.0</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>,<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="秀秀的森林forest">秀秀的森林（forest）</span></h1><p>本题我的做法按道理说是会被卡掉的<br>但看起来数据很随机，因此跑得飞起，直接AC<br>先讲我的做法<br>考虑dp求直径的做法，<br>砍掉一条边后下面的子树的dp值都不会改变，只要更新砍掉的边到根的节点的dp值就可以<br>因为这样dp值减小，不方便更新，所以时间倒流把砍边改成加边，先dfs预处理每个点的父亲和dp值，加边时暴力向上跳更新<br>复杂度最坏应该会高达$O(n^2)$，然而数据太水</p><p>下面是正解<br>仍然时间倒流，加上一条边后新树的直径只可能是以之前两棵树的直径端点为端点<br>这样就好做了<br>连边时4个端点两两组合用LCA求路径最大值，维护答案就可以了</p><p>之前好像见过这题。。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmin</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = min(a, b); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmax</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = max(a, b); &#125;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot, ena[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> X[maxn], Y[maxn], n, a[maxn], fa[maxn], d[maxn], rt[maxn], q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rt[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> rt[x] = get(rt[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[maxn], res = <span class="number">1</span>, lans[maxn], f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">ans[x] = f[x] = a[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x] &amp;&amp; ena[ver[i]]) &#123;</span><br><span class="line">ans[x] = max(ans[x], ans[ver[i]]);</span><br><span class="line">ans[x] = max(ans[x], f[x] + f[ver[i]]);</span><br><span class="line">f[x] = max(f[x], f[ver[i]] + a[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">fa[x] = pa; d[x] = d[pa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) dfs(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Power</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lres = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) lres = lres * x % mod;</span><br><span class="line"><span class="keyword">return</span> lres;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"forest.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"forest.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) X[i] = read(), Y[i] = read(), add(X[i], Y[i]), add(Y[i], X[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rt[i] = i, f[i] = a[i], ans[i] = a[i], res = res * ans[i] % mod;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">lans[n] = res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Q = <span class="number">1</span>; Q &lt; n; Q++) &#123;</span><br><span class="line">q[Q] = read();</span><br><span class="line"><span class="keyword">if</span>(d[X[q[Q]]] &gt; d[Y[q[Q]]]) swap(X[q[Q]], Y[q[Q]]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> rx = get(X[q[i]]), ry = get(Y[q[i]]);</span><br><span class="line">ena[ry] = <span class="number">1</span>;</span><br><span class="line">res = res * Power(ans[rx], mod - <span class="number">2</span>) % mod * Power(ans[ry], mod - <span class="number">2</span>) % mod;</span><br><span class="line">rt[ry] = rx;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = ry; j != rx; j = fa[j]) update(fa[j]);</span><br><span class="line">res = res * ans[rx] % mod;</span><br><span class="line">lans[i] = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, lans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="秀秀的照片photo">秀秀的照片（photo）</span></h1><blockquote><p>“组合数问题都是好题”</p></blockquote><p>组合数推出公式就可以了<br>显然的性质是<br>最左边和最右边一列不同颜色个数应当相同<br>中间m-2列的颜色是最两边两列颜色集合的交集的子集<br>枚举中间部分颜色个数，在枚举两端的独特的颜色个数，用C求出选颜色的方案，还要乘以用恰好那么多颜色涂那么多格子的方案数，这个用第二类stirling数求，$S[i][j]$表示i个球放到j个盒子中，每个盒子都有球的方案数，这里球对应格子，盒子对应颜色，有<br>$$S[i][j]=S[i-1][j-1]+S[i-1][j]\times j$$<br>由于考虑排列，所以乘以阶乘，最后的结果为<br>$$<br>\sum_{i=0}^{min(n, k)}C_k^i \times i^{n\times(m-2)}\sum_{j=0}^{min(n-i, (k-i)/2)}C_{k-i}^j \times C_{k-i-j}^j\times S_{n}^{i+j}\times (i+j)!<br>$$<br>按照组合数学常见套路，能预处理的都预处理<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>, maxn = <span class="number">4000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll fac[maxn + <span class="number">10</span>], infac[maxn + <span class="number">10</span>], ans, S[<span class="number">4010</span>][<span class="number">4010</span>];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fac[x] * infac[y] % mod * infac[x - y] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"photo.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"photo.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">infac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++) fac[i] = fac[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">infac[maxn] = Power(fac[maxn], mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = maxn - <span class="number">1</span>; i; i--) infac[i] = infac[i+<span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) </span><br><span class="line">S[i][j] = (S[i<span class="number">-1</span>][j<span class="number">-1</span>] + S[i<span class="number">-1</span>][j] * j % mod) % mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= min(n, k); i++) &#123;</span><br><span class="line">ll tmp = C(k, i) * Power(i, n *(m - <span class="number">2</span>)) % mod;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j + i + j &lt;= k, i + j &lt;= n; j++) &#123;</span><br><span class="line">ll tt = C(k - i, j) * C(k - i - j, j) % mod;</span><br><span class="line">ll t2 = S[n][i + j] * fac[i + j] % mod; t2 = t2 * t2 % mod;</span><br><span class="line">sum = (sum + tt * t2 % mod) % mod;</span><br><span class="line">&#125; </span><br><span class="line">ans = (ans + tmp * sum % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 集训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> 树上动规 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ4945 [Noi2017]游戏</title>
      <link href="/2019/07/04/BZOJ4945-Noi2017-%E6%B8%B8%E6%88%8F/"/>
      <url>/2019/07/04/BZOJ4945-Noi2017-%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4945" target="_blank" rel="noopener">BZOJ4945</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>本题标记着本人练习2-sat达到一个高潮<br>如果没有x，那就是一个裸的2-sat<br>然而x的个数很小，可以暴力枚举，所以实际上还是裸的2-sat<br>每个x枚举<br>1.不能选A，那么就是B、C二选一<br>2.不能选B，那么就是A、C二选一<br>这样就已经包含了ABC三种情况，所以暴力枚举的复杂度为$2^d$</p><p>下面说一说裸的2-sat怎么做<br>用tarjan算法求出所有的强连通分量<br>如果某个对偶的两点位于同一分量，则无解<br>否则有解，那么问题就是如何输出任意一解<br>对于缩点后的反图，按拓扑序，选当前节点，把她得姐妹节点删除<br>事实上不用拓扑排序，节点scc编号的大小就是反图拓扑序的大小，因此姐妹点选scc小的即可</p><p>tarjan比dfs快，我终于明白了，dfs是$O(nm)$的</p><p>这里还有一些要注意的地方，如果一个限制中提到了一定不会出现赛车，设此限制为$(x\to y)$，若x不可能选，则直接continue，若y不可能选，则x连向他的姐妹节点，巧妙地表达了x不可能选</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150010</span>, maxm = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxm], Next[maxm], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> str[maxn], qx[maxm], qy[maxm], car[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;, &#123;<span class="string">'A'</span>, <span class="string">'C'</span>&#125;, &#123;<span class="string">'A'</span>, <span class="string">'B'</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n, d, m, xpos[<span class="number">10</span>], xcnt, X[maxm], Y[maxm];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], num, scc, ins[maxn], sta[maxn], top, bel[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> rnk[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ins[x] = <span class="number">1</span>; sta[++top] = x;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ver[i]]) tarjan(ver[i]), low[x] = min(low[x], low[ver[i]]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[ver[i]] == <span class="number">1</span>) low[x] = min(low[x], dfn[ver[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x] == low[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = <span class="number">0</span>; scc++;</span><br><span class="line">        <span class="keyword">while</span>(z != x) &#123;</span><br><span class="line">            z = sta[top--]; ins[z] = <span class="number">2</span>; bel[z] = scc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; str + 1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(ins, <span class="number">0</span>, <span class="keyword">sizeof</span>(ins));</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">    num = scc = top = tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[X[i]] - <span class="string">'a'</span> == qx[i] - <span class="string">'A'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> x = rnk[str[X[i]] - <span class="string">'a'</span>][qx[i] - <span class="string">'A'</span>];</span><br><span class="line">        <span class="keyword">int</span> y = rnk[str[Y[i]] - <span class="string">'a'</span>][qy[i] - <span class="string">'A'</span>];</span><br><span class="line">        <span class="keyword">if</span>(str[Y[i]] - <span class="string">'a'</span> == qy[i] - <span class="string">'A'</span>) &#123; add(X[i] + x * n, X[i] + n * (<span class="number">1</span> - x)); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        add(x * n + X[i], y * n + Y[i]);</span><br><span class="line">        add((<span class="number">1</span> - y) * n + Y[i], (<span class="number">1</span> - x) * n + X[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(bel[i] == bel[i + n]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">if</span>(bel[i] &lt; bel[i + n]) <span class="built_in">printf</span>(<span class="string">"%c"</span>, car[str[i] - <span class="string">'a'</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>, car[str[i] - <span class="string">'a'</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; xcnt) <span class="keyword">return</span> solve();</span><br><span class="line">    str[xpos[x]] = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span>(dfs(x + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    str[xpos[x]] = <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">if</span>(dfs(x + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("input", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("user_out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, str + <span class="number">1</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(str[i] == <span class="string">'x'</span>) xpos[++xcnt] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d %c%d %c"</span>, &amp;X[i], &amp;qx[i], &amp;Y[i], &amp;qy[i]);</span><br><span class="line">    <span class="keyword">if</span>(!dfs(<span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 2-sat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2-sat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3160 万径人踪灭</title>
      <link href="/2019/07/03/BZOJ3160-%E4%B8%87%E5%BE%84%E4%BA%BA%E8%B8%AA%E7%81%AD/"/>
      <url>/2019/07/03/BZOJ3160-%E4%B8%87%E5%BE%84%E4%BA%BA%E8%B8%AA%E7%81%AD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3160" target="_blank" rel="noopener">BZOJ3160</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意在题面里已经说过了<br>对于第三点限制，只要算出所有满足1、2点的子序列，再减去回文子串的个数就可以<br>回文子串个数直接裸的马拉车<br>考虑如何求满足的子序列个数<br>枚举对称轴x，由于位置对称，我们只要知道有多少对是相等的就可以（这里的一对指的是位置为$i$和$2x-i$的一对位置<br>这个形式很像多项式卷积，因此用fft实现<br>a和b分开处理，处理a时把a的位置置为1，与自己卷积，得到的多项式中只有对称才会产生贡献，只要询问第$2x$位就可以</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">800010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; cp;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> str[maxn], nstr[maxn];</span><br><span class="line"><span class="keyword">int</span> n, r[maxn], x[maxn], y[maxn], f[maxn]; </span><br><span class="line">ll ans;</span><br><span class="line">cp a[maxn], b[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(cp *p, <span class="keyword">int</span> N, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) <span class="keyword">if</span>(i &lt; r[i]) swap(p[i], p[r[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; N; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="function">cp <span class="title">omega</span><span class="params">(<span class="built_in">cos</span>(pi / mid), inv * <span class="built_in">sin</span>(pi / mid))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="function">cp <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++, w *= omega) &#123;</span><br><span class="line">cp x = p[i + j], y = w * p[i + j + mid];</span><br><span class="line">p[i + j] = x + y, p[i + j + mid] = x - y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nn = <span class="number">0</span>, mx = <span class="number">1</span>, pos = <span class="number">1</span>;</span><br><span class="line">nstr[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">nstr[++nn] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nstr[++nn] = str[i], nstr[++nn] = <span class="string">'#'</span>;</span><br><span class="line">nstr[++nn] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; i++) &#123;</span><br><span class="line">f[i] = min(f[<span class="number">2</span> * pos - i], mx - i);</span><br><span class="line"><span class="keyword">if</span>(f[i] &lt; <span class="number">1</span>) f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(nstr[i + f[i]] == nstr[i - f[i]]) f[i]++;</span><br><span class="line"><span class="keyword">if</span>(i + f[i] &gt; mx) mx = f[i] + i, pos = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; i++) ans = (ans - f[i] / <span class="number">2</span> + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>); n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(str[i] == <span class="string">'a'</span>) a[i] = cp(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">else</span> b[i] = cp(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">1</span>, wei = <span class="number">0</span>; <span class="keyword">while</span>(N &lt;= <span class="number">2</span> * n) N &lt;&lt;= <span class="number">1</span>, wei++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (wei - <span class="number">1</span>));</span><br><span class="line">fft(a, N, <span class="number">1</span>); fft(b, N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) a[i] *= a[i], b[i] *= b[i];</span><br><span class="line">fft(a, N, <span class="number">-1</span>); fft(b, N, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) x[i] = (<span class="keyword">int</span>)(a[i].real() / N + <span class="number">0.5</span>), y[i] = (<span class="keyword">int</span>)(b[i].real() / N + <span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = x[i] + y[i]; </span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) tmp++;</span><br><span class="line">tmp /= <span class="number">2</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; x[i] &lt;&lt; ' ' &lt;&lt; y[i] &lt;&lt; ' ' &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">ans += (Power(<span class="number">2</span>, tmp) - <span class="number">1</span> + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">manacher();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 多项式 </category>
          
          <category> 字符串 </category>
          
          <category> manachar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> manachar </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3527 [Zjoi2014]力</title>
      <link href="/2019/07/02/BZOJ3527-Zjoi2014-%E5%8A%9B/"/>
      <url>/2019/07/02/BZOJ3527-Zjoi2014-%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3527" target="_blank" rel="noopener">BZOJ3527</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>我们要快速的求出<br>$$<br>\sum_{j=1}^i\frac{q_j}{(i-j)^2} \\<br>\sum_{j=i}^n\frac{q_j}{(i-j)^2}<br>$$<br>可以看成是分子*分母的倒数，分母递增或递减<br>构建两个个数组<br>$$b_i = \frac{1}{i^2} \\<br>c_i = \frac{1}{(n+1-i)^2}$$<br>分别与q卷积，<br>得到的新b数组的第$i$项是前部分的结果<br>新c数组的第$i+n+1$项是后半部分<br>怎么得出来的可以画图看看<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; cp;</span><br><span class="line"><span class="keyword">double</span> q[maxn];</span><br><span class="line">cp a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="keyword">int</span> n, r[maxn];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sq</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(cp *p, <span class="keyword">int</span> N, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) <span class="keyword">if</span>(i &lt; r[i]) swap(p[i], p[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; N; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">cp <span class="title">omega</span><span class="params">(<span class="built_in">cos</span>(pi / mid), inv * <span class="built_in">sin</span>(pi / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">cp <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++, w *= omega) &#123;</span><br><span class="line">                cp x = p[i + j], y = w * p[i + j + mid];</span><br><span class="line">                p[i + j] = x + y, p[i + j + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;q[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = cp(q[i], <span class="number">0</span>), b[i] = cp(<span class="number">1.0</span> / sq(i), <span class="number">0</span>), c[i] = cp(<span class="number">1.0</span> / sq(n - i + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span>, wei = <span class="number">0</span>; <span class="keyword">while</span>(N &lt; <span class="number">2</span> * n) N &lt;&lt;= <span class="number">1</span>, wei++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (wei - <span class="number">1</span>));</span><br><span class="line">    fft(a, N, <span class="number">1</span>); fft(b, N, <span class="number">1</span>); fft(c, N, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) b[i] *= a[i], c[i] *= a[i];</span><br><span class="line">    fft(b, N, <span class="number">-1</span>), fft(c, N, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, b[i].real() / N - c[i + n + <span class="number">1</span>].real() / N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 多项式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ4827 [Hnoi2017]礼物</title>
      <link href="/2019/07/01/BZOJ4827-Hnoi2017-%E7%A4%BC%E7%89%A9/"/>
      <url>/2019/07/01/BZOJ4827-Hnoi2017-%E7%A4%BC%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4827" target="_blank" rel="noopener">BZOJ4827</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意求<br>$$<br>min{\sum_{i=1}^n(x_i - y_{i+k} + C)}<br>$$<br>C是每个增加的亮度，k是旋转的位数<br>把他拆开可以写成<br>$$<br>\sum_{i=1}^n(x_i^2+y_i^2) +\sum_{i=1}^n2C(x_i-y_i)+nC^2-2\sum_{i=1}^nx_iy_{i+k}<br>$$<br>难点是求最后一项$\sum_{i=1}^nx_iy_{i+k}$的最大值<br>这种形式经常使用多项式卷积<br>把x数组倒序，y后面再连一个y，得到的两个新数组卷积<br>最后上面的式子就是$x^{n+1+k}$的系数，从$x^{n+1}$到$x^{n+n}$取最大值就可以了<br>之后C可以在m的值域内枚举，也可以直接得到，利用二次函数最值，可知$C=\frac{\sum_{i=1}^ny_i-\sum_{i=1}^nx_i}{n} $<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; cp;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> x[maxn * <span class="number">8</span>], y[maxn * <span class="number">8</span>], m, n, r[maxn * <span class="number">8</span>], f[maxn * <span class="number">8</span>], ans;</span><br><span class="line">cp a[maxn * <span class="number">8</span>], b[maxn * <span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(cp *p, <span class="keyword">int</span> N, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) <span class="keyword">if</span>(i &lt; r[i]) swap(p[i], p[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; N; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        cp omega = cp(<span class="built_in">cos</span>(pi / mid), inv * <span class="built_in">sin</span>(pi / mid));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">cp <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++, w *= omega) &#123;</span><br><span class="line">                cp x = p[i + j], y = w * p[i + j + mid];</span><br><span class="line">                p[i + j] = x + y; p[i + j + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("gift9.in", "r", stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = cp(x[n + <span class="number">1</span> - i], <span class="number">0</span>), b[i] = b[i + n] = cp(y[i], <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; ' ' &lt;&lt; b[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span>, wei = <span class="number">0</span>; <span class="keyword">while</span>(N &lt; <span class="number">3</span> * n) N &lt;&lt;= <span class="number">1</span>, wei++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (wei - <span class="number">1</span>));</span><br><span class="line">    fft(a, N, <span class="number">1</span>); fft(b, N, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) a[i] *= b[i];</span><br><span class="line">    fft(a, N, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) f[i] = (<span class="keyword">int</span>)(a[i].real() / N + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += x[i] * x[i] + y[i] * y[i], c += y[i] - x[i];</span><br><span class="line">    c = round(c / n);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + n; i++) tmp = max(tmp, f[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += <span class="number">2</span> * c * (x[i] - y[i]);</span><br><span class="line">    ans += n * c * c - <span class="number">2</span> * tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 多项式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> FFT </tag>
            
            <tag> 二次函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3930 [CQOI2015]选数</title>
      <link href="/2019/06/30/BZOJ3930-CQOI2015-%E9%80%89%E6%95%B0/"/>
      <url>/2019/06/30/BZOJ3930-CQOI2015-%E9%80%89%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3930" target="_blank" rel="noopener">BZOJ3930</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>整体除以gcd，相当于在一个区间内选gcd=1的方案数<br>$$<br>f(d) = \sum [gcd(a_i)=d] \\<br>F(d) = \sum [d|gcd(a_i)] = \sum_{d|n}f(n)<br>$$<br>$$<br>f(1) = \sum_{i=1}^{R}\mu(i)(\frac{R}{i}-\frac{L-1}{i})^k<br>$$<br>难点在$\mu$的计算上，因为左右端点都可能很大<br>所以使用杜教筛，很裸地计算$\mu$的前缀和<br>在这道题里记一下杜教筛<br>记$S(n)=\sum_{i=1}^nf(i)$，有$h=f*g$<br>$$<br>\sum_{i=1}^Nh(i) = \sum_{i=1}^N\sum_{d|i}g(d)f(\frac{i}{d}) \\<br>= \sum_{d=1}^N\sum_{i=1}^{\frac{N}{d}}g(d)f(i) \\<br>= \sum_{d=1}^Ng(d)\sum_{i=1}^{\frac{N}{d}}f(i) \\<br>= \sum_{d=1}^Ng(d)S(\frac{N}{d})<br>$$<br>关键的一步，提取后面的第一项<br>$$<br>\sum_{i=1}^Nh(i) = g(1)S(N) + \sum_{d=2}^Ng(d)S(\frac{N}{d})<br>$$<br>$$<br>g(1)S(N) = \sum_{i=1}^Nh(i) - \sum_{d=2}^Ng(d)S(\frac{N}{d})<br>$$<br>要求前面h的前缀和好求，后面可以整除分块<br>此乃杜教筛也</p><p>对于现在要求的mu，就是这样<br>$$<br>S(N) = 1 - \sum_{d=2}^NS(\frac{N}{d})<br>$$<br>就做完了<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> v[maxn], prim[maxn], cnt;</span><br><span class="line">ll sum[maxn], n, k, L, R, ans;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, ll&gt; miu;</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    v[<span class="number">0</span>] = v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    sum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) &#123; prim[++cnt] = i; sum[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prim[j] &lt;= N; j++) &#123;</span><br><span class="line">            v[i * prim[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prim[j]) sum[i * prim[j]] = -sum[i];</span><br><span class="line">            <span class="keyword">else</span> &#123; sum[i * prim[j]] = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) sum[i] = (sum[i] + sum[i<span class="number">-1</span>] + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">100000</span>) <span class="keyword">return</span> sum[x];</span><br><span class="line">    <span class="keyword">if</span>(miu[x]) <span class="keyword">return</span> miu[x];</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        res = (res + calc(x / l) * (r - l + <span class="number">1</span>) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> miu[x] = (<span class="number">1l</span>l + mod - res) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;n, &amp;k, &amp;L, &amp;R);</span><br><span class="line">    init(<span class="number">100000</span>);</span><br><span class="line">    L = (L - <span class="number">1</span>) / k; R = R / k;</span><br><span class="line">    <span class="keyword">for</span>(ll l = <span class="number">1</span>, r; l &lt;= R; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = R / (R / l); <span class="keyword">if</span>(l &lt;= L) r = min(r, L / (L / l)); </span><br><span class="line">        ans = (ans + (calc(r) - calc(l - <span class="number">1</span>) + mod) % mod * Power(R / l - L / l, n) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 莫比乌斯反演 </category>
          
          <category> 杜教筛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ2154 Crash的数字表格</title>
      <link href="/2019/06/29/BZOJ2154-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/"/>
      <url>/2019/06/29/BZOJ2154-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2154" target="_blank" rel="noopener">BZOJ2154</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意求<br>$$<br>\sum_{i=1}^n\sum_{j=1}^mlcm(i, j)<br>$$<br>$$<br> = \sum_{i=1}^n\sum_{j=1}^m\frac{ij}{gcd(i,i)}<br>$$<br>$$<br> = \sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^m[gcd(i, j)=d]\frac{ij}{d}<br>$$<br>套路地提取d<br>$$<br> = \sum_{d=1}^nd\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i, j) = 1]ij<br>$$<br>先处理后面一部分<br>令<br>$$<br>f(d) = \sum_{i=1}^x\sum_{j=1}^{y}[gcd(i, j)=d]ij \\<br>F(d) = \sum_{i=1}^x\sum_{j=1}^{y}[d|gcd(i, j)]ij \\<br> = \sum_{d|n}f(n) = d^2S(\frac{x}{d})S(\frac{y}{d})<br>$$<br>其中$S(n)$表示从1加到n，也就是$\frac{n(n+1)}{2}$<br>利用莫比乌斯反演<br>$$<br>f(d) = \sum_{d|k}\mu(\frac{k}{d})F(k)<br>$$<br>$$<br>ans = \sum_{d=1}^{n}df(1) = \sum_{d=1}^nd\sum_{i=1}^n\mu(i)i^2S(\frac{n}{id})S(\frac{m}{id})<br>$$<br>为了减少复杂度，从$O(n)$降到$O(\sqrt{n})$，令$T=id$，改为枚举T<br>$$<br>ans = \sum_{T=1}^nS(\frac{n}{T})S(\frac{m}{T})\sum_{d|T}dT\mu(d)<br>$$<br>至此，考虑如何实现<br>前面整除分块不用多说，讲讲后面的$\sum_{d|T}dT\mu(d)$，这是个积性函数，可以线性筛预处理出来，具体如下：<br>如果当前质因数p次数不为1<br>那么前面的所有因数要么包含一个p，要么不含p，否则贡献为零，不用考虑<br>前者会产生0和包含一个p的因数，后者会产生包含一个或不包含的<br>因此最终与没有p时相同，再乘上T的变化也就是p即可<br>如果p的次数唯一，则互质，由积性算即可</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">20101009</span>, maxn = <span class="number">10000010</span>, r2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, prim[maxn], cnt, s[maxn], v[maxn], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    v[<span class="number">1</span>] = v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) &#123; prim[++cnt] = i; s[i] = (i - <span class="number">1l</span>l * i * i % mod + mod) % mod; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prim[j] &lt;= N; j++) &#123;</span><br><span class="line">            v[i * prim[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prim[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                s[i * prim[j]] = s[i] * prim[j] % mod;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> s[i * prim[j]] = s[i] * s[prim[j]] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i = 1; i &lt;= N; i++) cout &lt;&lt; s[i] &lt;&lt; ' ';cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//for(int i = 1; i &lt;= N; i++) cout &lt;&lt; s[i] &lt;&lt; ' ';cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) s[i] = (s[i] + s[i<span class="number">-1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    init(max(n, m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n &amp;&amp; l &lt;= m; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(n / (n / l), m / (m / l));</span><br><span class="line">        ll s1 = (n / l + <span class="number">1</span>) * (n / l) % mod * r2 % mod;</span><br><span class="line">        ll s2 = (m / l + <span class="number">1</span>) * (m / l) % mod * r2 % mod;</span><br><span class="line">        ans = (ans + (s[r] - s[l - <span class="number">1</span>] + mod) % mod * s1 % mod * s2 % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 莫比乌斯反演 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3676 [Apio2014]回文串</title>
      <link href="/2019/06/29/BZOJ3676-Apio2014-%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2019/06/29/BZOJ3676-Apio2014-%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3676" target="_blank" rel="noopener">BZOJ3676</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>1.找出回文串<br>2.查询他出现次数，更新答案<br>第一步使用马拉车，需要注意，只有更新mx是会产生新的回文串，数量是$O(n)$的，也就是只有$O(n)$次询问<br>询问使用后缀自动机，从右端对应的节点开始树上倍增，由于祖先上全都是其后缀，所以定位到长度合适的节点。更新答案即可。<br>比较水，基本方法，基本性质<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">600005</span>;</span><br><span class="line"><span class="keyword">char</span> strr[maxn], str[maxn];</span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">26</span>], val[maxn], par[maxn], n, nn, cnt = <span class="number">1</span>, p[maxn], rt = <span class="number">1</span>, las = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> epos[maxn], sz[maxn], f[maxn][<span class="number">21</span>], c[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = las, np = ++cnt; val[np] = val[p] + <span class="number">1</span>; sz[np] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line"><span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> q = ch[p][x];</span><br><span class="line"><span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span>(ch[q]));</span><br><span class="line">par[nq] = par[q];</span><br><span class="line">par[q] = par[np] = nq;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">las = np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt; <span class="number">1</span> || r &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x = epos[r];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][i] &amp;&amp; val[f[x][i]] &gt;= len) x = f[x][i];</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, (<span class="keyword">long</span> <span class="keyword">long</span>)len * sz[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manachar</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; i++) str[++n] = <span class="string">'#'</span>, str[++n] = strr[i];</span><br><span class="line">str[++n] = <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; mx) p[i] = min(mx - i, p[pos * <span class="number">2</span> - i]);</span><br><span class="line"><span class="keyword">while</span>(str[i + p[i]] == str[i - p[i]]) &#123;</span><br><span class="line"><span class="keyword">if</span>(i + p[i] &gt;= mx) check((i - p[i] + <span class="number">1</span>) / <span class="number">2</span>, (i + p[i]) / <span class="number">2</span>); </span><br><span class="line">p[i]++; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(mx &lt; i + p[i]) mx = i + p[i], pos = i; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("testdata.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//freopen("testdata.my", "w", stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, strr + <span class="number">1</span>); nn = <span class="built_in">strlen</span>(strr + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; i++) extend(strr[i] - <span class="string">'a'</span>), epos[i] = las;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) c[val[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; i++) c[i] += c[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) a[c[val[i]]--] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = cnt; i; i--) sz[par[a[i]]] += sz[a[i]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = a[i];</span><br><span class="line">f[x][<span class="number">0</span>] = par[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) f[x][k] =  f[f[x][k<span class="number">-1</span>]][k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">manachar();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
          <category> 后缀自动机 </category>
          
          <category> manachar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀自动机 </tag>
            
            <tag> manachar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串算法总结</title>
      <link href="/2019/06/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/06/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>对于一些字符串算法的个人心得<br>其实就是记一些性质，还有容易忘的东西，不然未来还要上网查(┬＿┬)<br><a id="more"></a></p><h1><span id="ac自动机">AC自动机</span></h1><p>AC自动机是trie + KMP<br>在trie上设置fail指针，匹配失败就往上跳</p><blockquote><p>那么在跳的过程中经过的每个点其实都是当前字符串的后缀 </p></blockquote><p>匹配的过程就是从字符串对应trie的链上的每一个点向上跳fail</p><p>也就是相当于枚举了所有前缀的后缀</p><p>然而实际上并没有枚举那么多，因为后缀并未完全枚举，这就是复杂度稳定在$O(M+N)$的原因(N为模式串总长，M为母串长)<br>关于时间复杂度，走trie共M次，跳fail次数不会大于走trie的次数，因此匹配是$O(M)$的</p><p>然后我们把fail指针想象成一棵树</p><blockquote><p>一个点的子树是以他为后缀的所有串</p></blockquote><p>所以</p><blockquote><p>一个点对应的字符串x出现在另一个字符串y中，当且仅当 y对应的trie链 和 x对应的fail子树 有交集<br>其中x和y都是AC自动机上的字符串</p></blockquote><p>以上就是AC自动机的一些性质，以及本质的理解，其实和后缀自动机有点联系</p><h1><span id="扩展kmp">扩展KMP</span></h1><p>求给定字符串S的所有后缀与另一字符串T的最长公共前缀<br>也叫z-algorithm<br>其实和KMP思路一样，就是先算nxt[]，再算extend[]，都用已经算好的nxt来算</p><blockquote><p>extend：$S[i~N]$前缀与$T$前缀最长公共长度<br>nxt：$T[i~M]$前缀与$T$前缀最长公共长度</p></blockquote><p>对比一下KMP(T子串，S母串)</p><blockquote><p>f：$S[1~i]$后缀与$T[1~i]$前缀最长公共长度<br>nxt：$T[1~i]$后缀与$T[1~i]$前缀最长公共长度</p></blockquote><p>看起来这是字符串的常见套路啊</p><blockquote><p>啥的（前缀/后缀）与啥的（前缀/后缀）的最长公共长度</p></blockquote><p>而AC和后缀自动机也是在纠结前缀和后缀⊙﹏⊙</p><h1><span id="manachar">manachar</span></h1><p>只记一个东西</p><blockquote><p>马拉车求出所有本质不同的回文串是$ O(n) $的，也就是每次更新mx的时候才会产生新的一个回文子串，否则就是前面算过了的</p></blockquote><p>于是就可以有很多manachar + 的算法</p><h1><span id="后缀数组">后缀数组</span></h1><p>后缀数组主要是以下几个用法：</p><ul><li>$O(1)$求后缀的LCP，搭配其他算法和数据结构，比如调和级数法、倍增法（利用$f[][]$求匹配的区间，转化为区间问题）</li><li>二分长度，在height数组上划分成很多段，每一段进行判定，很多时候也可以用单调栈优化</li><li>直接在height上统计，比如相同子串个数、不同子串个数</li><li>height重叠之后就有循环节了，然后搞事情，关于循环节，经常使用调和级数法，然后处理不满一段的部分</li><li>处理很多串时可以连在一起，中间加入特殊字符，注意每一个特殊字符都不同</li></ul><p>例题<a href="https://www.cnblogs.com/Przz/p/5409570.html" target="_blank" rel="noopener">这篇博客</a>总结的很好<br>最后两题没有很想明白<br>课件已经下载在本地了</p><p>后缀数组是在数组（sa，height）上搞事情，后缀自动机是在DAG和树上搞事情</p><h1><span id="后缀自动机">后缀自动机</span></h1><p><a href="https://wenku.baidu.com/view/7afa5828ed630b1c59eeb512.html" target="_blank" rel="noopener">陈立杰课件</a><br><a href="https://oi.men.ci/suffix-automaton-notes/" target="_blank" rel="noopener">一个比较好的博客</a><br>利用这个图比较好纠结</p><img src="/2019/06/02/字符串算法总结/1.JPG"><img src="/2019/06/02/字符串算法总结/2.JPG"><p>我们关心的并不是他是怎么想出自动机的，而是自动机能怎么用，因此通过性质理解即可：</p><blockquote><p>每一个节点表示很多字符串，这些字符串按长度排序后每一个都是前一个加一个前缀字符，因此字符串长度是一个区间</p></blockquote><blockquote><p>所有这些字符串的结尾位置的集合就是end_pos</p></blockquote><blockquote><p>某个节点的end_pos是他的父节点的end_pos的子集</p></blockquote><blockquote><p>每个节点代表的不同子串个数是$ max - min + 1 $</p></blockquote><blockquote><p>每个节点匹配位置个数是end_pos大小，可由bfs求sz数组，每个点的sz是其子树的sz和，若为原串前缀则+1</p></blockquote><blockquote><p>拓扑排序用基数排序</p></blockquote><blockquote><p>DAG按字典序走可按字典序遍历子串</p></blockquote><blockquote><p>一个点的祖先所有字符串是他自己所有字符串的后缀</p></blockquote><blockquote><p>end_pos中的所有元素都可以匹配该节点代表的每一个子串</p></blockquote><blockquote><p>因此实际上每个节点可以匹配的所有子串（不同位置算多个）个数为$ |end_pos| * (max - min + 1) $</p></blockquote><p>后缀自动机其实也就是那几个用法，先写这些，以后慢慢加</p><ul><li>树上倍增可以$O(logn)$快速定位到一个子串的位置</li><li>按字典序遍历DAG，可以按字典序遍历所有子串，适合离线询问等操作</li><li>经常dfs一趟求出end_pos大小（若不同位置算多次则初始为$max - min + 1$，否则初始为1），之后定位后方便计数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ4650 [Noi2016]优秀的拆分</title>
      <link href="/2019/06/01/BZOJ4650-Noi2016-%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/"/>
      <url>/2019/06/01/BZOJ4650-Noi2016-%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4650" target="_blank" rel="noopener">BZOJ4650</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>感觉这道题的方法在SA里还是很常见的<br>考虑枚举AA和BB的分界点，对答案的贡献是以当前为结尾的XX的个数和以当前为结束的XX的个数<br>因此实际上要计算以每个字符开头的XX（两个相同字符串）的个数，同理也要算以他结尾的<br>枚举X字符串的长度$len$，每隔长度$len$设一个关键点<br>那么每一个XX一定过两个相邻的关键点<br>枚举每一对相邻的关键点，考虑其可能对那些位置产生贡献（所谓对某个位置产生贡献就是所这个位置开头的XX字符串个数+1）<br>请看下图，我们求出两个位置的最长公共前缀和最长公共后缀<br><img src="/2019/06/01/BZOJ4650-Noi2016-优秀的拆分/1.png"><br>此时两者没有交点，也就是长度之和$\le len$，不可能产生贡献（因为总会每截断）<br>但是下面这种情况<br><img src="/2019/06/01/BZOJ4650-Noi2016-优秀的拆分/2.png"><br>两者有了交点，就会产生贡献<br>两条橙色线都是可以产生的XX，在两者之间的每一条同样长度的字符串也是<br>因此紫色的那一段向后的XX会$+1$，棕色的那一段有向前的XX会$+1$<br>区间加一可以直接差分<br>至于LCP和LCS就是后缀数组的常见操作了，前后要构造两个</p><p>1.枚举 $len$ ，每隔 $len$ 设置关键点：这个的复杂度是调和级数 $O(n \log n)$<br>2.求 后缀LCP，前缀LCS：使用后缀数组 + st 表 做到 $O(1)$ 查询<br>3.区间加上 1 ： 差分维护就可以了。</p><p>记住这个方法，我叫他“调和级数法”<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> sa[<span class="number">2</span>][maxn], t1[maxn], t2[maxn], h[<span class="number">2</span>][maxn], rnk[<span class="number">2</span>][maxn], c[maxn], f[<span class="number">2</span>][maxn][<span class="number">30</span>], lg2[maxn], n;</span><br><span class="line"><span class="keyword">int</span> st[maxn], ed[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *x = t1, *y = t2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) c[x[i] = s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) c[i] += c[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) sa[w][c[x[i]]--] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; i++) y[++p] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(sa[w][i] &gt; k) y[++p] = sa[w][i] - k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) c[x[y[i]]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) c[i] += c[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i--) sa[w][c[x[y[i]]]--] = y[i];</span><br><span class="line">swap(x, y);</span><br><span class="line">p = <span class="number">1</span>; x[sa[w][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">x[sa[w][i]] = y[sa[w][i]] == y[sa[w][i<span class="number">-1</span>]] &amp;&amp; y[sa[w][i] + k] == y[sa[w][i<span class="number">-1</span>] + k] ? p : ++p;</span><br><span class="line"><span class="keyword">if</span>(p &gt; n) <span class="keyword">break</span>;</span><br><span class="line">m = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rnk[w][sa[w][i]] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(k) k--;</span><br><span class="line"><span class="keyword">if</span>(rnk[w][i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> j = sa[w][rnk[w][i] - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(s[i + k] == s[j + k]) k++;</span><br><span class="line">h[w][rnk[w][i]] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[w][i][<span class="number">0</span>] = h[w][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">20</span>; k++) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> &lt;= n; i++) f[w][i][k] = min(f[w][i][k<span class="number">-1</span>], f[w][i + (<span class="number">1</span> &lt;&lt; (k<span class="number">-1</span>))][k<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">l = rnk[w][l];</span><br><span class="line">r = rnk[w][r];</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) swap(l, r); </span><br><span class="line"><span class="comment">//if(w == 0) cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">l++;</span><br><span class="line"><span class="keyword">int</span> k = lg2[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> min(f[w][l][k], f[w][r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("testdata.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//freopen("testdata.ans", "w", stdout);</span></span><br><span class="line"><span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">lg2[<span class="number">2</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">300000</span>; i++) lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line"><span class="built_in">memset</span>(sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line"><span class="built_in">memset</span>(ed, <span class="number">0</span>, <span class="keyword">sizeof</span>(ed));</span><br><span class="line"><span class="built_in">memset</span>(t1, <span class="number">0</span>, <span class="keyword">sizeof</span>(t1));</span><br><span class="line"><span class="built_in">memset</span>(t2, <span class="number">0</span>, <span class="keyword">sizeof</span>(t2));</span><br><span class="line"><span class="built_in">memset</span>(rnk, <span class="number">0</span>, <span class="keyword">sizeof</span>(rnk));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">build(<span class="number">128</span>, <span class="number">0</span>);</span><br><span class="line">reverse(s + <span class="number">1</span>, s + <span class="number">1</span> + n);</span><br><span class="line">build(<span class="number">128</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; sa[0][i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; rnk[0][i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len + len &lt;= n; len++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; (i + <span class="number">1</span>) * len &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = i * len, y = x + len;</span><br><span class="line"><span class="keyword">int</span> tail = calc(<span class="number">0</span>, x, y), head = calc(<span class="number">1</span>, n + <span class="number">1</span> - x, n + <span class="number">1</span> - y);</span><br><span class="line"><span class="keyword">if</span>(head + tail - <span class="number">1</span> &lt; len) <span class="keyword">continue</span>;</span><br><span class="line">tail = min(tail, len); head = min(head, len);</span><br><span class="line"><span class="comment">//printf("%d %d %d %d\n", x, y, head, tail);</span></span><br><span class="line">st[x - head + <span class="number">1</span>]++; st[x + tail - len + <span class="number">1</span>]--;</span><br><span class="line">ed[y - head + len]++; ed[y + tail]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) st[i] += st[i<span class="number">-1</span>], ed[i] += ed[i<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; st[i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ed[i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i++) ans += st[i] * ed[i - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
          <category> 后缀数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
            <tag> 调和级数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1563 [Noi2009]诗人小G</title>
      <link href="/2019/05/27/BZOJ1563-Noi2009-%E8%AF%97%E4%BA%BA%E5%B0%8FG/"/>
      <url>/2019/05/27/BZOJ1563-Noi2009-%E8%AF%97%E4%BA%BA%E5%B0%8FG/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1563" target="_blank" rel="noopener">BZOJ1563</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>dp转移方程<br>$$<br>f[i] = min_{j=0}^{i-1}{ f[j] + | s[i] - s[j] - 1 - L | ^ p }<br>$$<br>其中$ s[i] = i + \sum_{j=1}^{i}len[j] $<br>采取了别人说的暴力打表法，发现确实具有决策单调性<br>证明？我不会。<br>因此以后见到这种1D1D的dp方程先写出来暴力，然后打表决策看有无单调性，没有的话一定是斜率优化了<br>每一时刻，所有位置对应的决策形成的数列一定是单调不减的，就是下面的样子<br>1111111111111<br>1111122222223<br>1111333344555<br>这个数列在每次计算出新的位置后会更新，之后下一个位置的决策实际上就确定了，更新的时候仍会保持单调性<br>具体实现可以使用单调队列配二分<br>每一个决策是一个区间，新的可能出现的决策会把队尾的区间弹掉<br>当队尾的区间无法弹掉后，使用二分确定在哪个位置之前是可以保留的，剩下的仍要更新<br>最后把当前决策补到队尾<br>下一轮的队首就是最终决策<br>同时及时把队首无用的决策区间弹掉<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line">ld f[maxn];</span><br><span class="line"><span class="keyword">int</span> n, L, p, s[maxn], cho[maxn], las[maxn];</span><br><span class="line"><span class="keyword">char</span> str[maxn][<span class="number">35</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inter</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, x;</span><br><span class="line">    Inter(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> x = <span class="number">0</span>) : l(l), r(r), x(x) &#123;&#125;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function">ld <span class="title">Power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pp)</span> </span>&#123;</span><br><span class="line">    ld res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pp--) res *= x; <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ld <span class="title">calc</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[j] + Power(<span class="built_in">abs</span>(s[i] - s[j] - <span class="number">1</span> - L), p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;L, &amp;p);</span><br><span class="line">        <span class="built_in">memset</span>(las, <span class="number">0</span>, <span class="keyword">sizeof</span>(las));</span><br><span class="line">        <span class="built_in">memset</span>(cho, <span class="number">0</span>, <span class="keyword">sizeof</span>(cho));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str[i]), s[i] = <span class="built_in">strlen</span>(str[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] += s[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        q[<span class="number">1</span>] = Inter(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            las[i] = q[head].x;</span><br><span class="line">            f[i] = calc(las[i], i);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; head &lt;&lt; ' ' &lt;&lt; tail &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; calc(q[tail].x, q[tail].l) &lt;&lt; ' ' &lt;&lt; calc(i, q[tail].l) &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">while</span>(head &lt;= tail &amp;&amp; calc(q[tail].x, q[tail].l) &gt; calc(i, q[tail].l)) tail--;</span><br><span class="line">            <span class="keyword">if</span>(head &gt; tail) &#123; q[++tail] = Inter(i + <span class="number">1</span>, n, i); <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">int</span> l = q[tail].l, r = q[tail].r + <span class="number">1</span>, x = q[tail].x;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(calc(x, mid) &gt; calc(i, mid)) r = mid; <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l = q[tail].l; </span><br><span class="line">            q[tail] = Inter(l, r - <span class="number">1</span>, x); </span><br><span class="line">            <span class="keyword">if</span>(r &lt;= n) q[++tail] = Inter(r, n, i);</span><br><span class="line">            <span class="keyword">while</span>(head &lt;= tail &amp;&amp; q[head].r &lt;= i) head++;</span><br><span class="line">            <span class="comment">//for(int i = head; i &lt;= tail; i++) cout &lt;&lt; q[i].l &lt;&lt; ' ' &lt;&lt; q[i].r &lt;&lt; ' ' &lt;&lt; q[i].x &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i; i = las[i]) cho[las[i]] = i;</span><br><span class="line">        <span class="keyword">if</span>(f[n] &gt; <span class="number">1e18</span>) <span class="built_in">printf</span>(<span class="string">"Too hard to arrange\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.0LF\n"</span>, f[n]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i = cho[i]) </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= cho[i]; j++) </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s%c"</span>, str[j], j == cho[i] ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--------------------\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
          <category> 决策单调性优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 决策单调性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1002 轮状病毒</title>
      <link href="/2019/02/03/BZOJ1002-%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92/"/>
      <url>/2019/02/03/BZOJ1002-%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1002" target="_blank" rel="noopener">BZOJ1002</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>组合数学，要么递推，要么通项公式<br>本题可以求出一个类递推式</p><p>用一个类似dp的方法。考虑分配周围这个圆的联通，就是一个线性dp了，过程中考虑和中间点的联通。<br>令$f[i]$表示考虑了圆上的前i个的方案数<br>$$<br>f[i] = \sum_{j=1}^if[i-j]\times j<br>$$<br>但这相当于把环拆成了链，还要考虑1和n连接的情况。如果有j个周围的点连成一条，且跨越了1和n，我们将所有这样的情况累加到答案中去。考虑如果这样的点有j个，剩下的点肯定不与这j个点相连，所以连边方案数就是$f[i-j]​$，这j个点有$(j-1)​$种选法(跨越1和n)，与中心点连边的方案数是j。设这种情况为$g[i]$<br>$$<br>g[i] = \sum_{j=2}^if[i-j]\times j\times (j-1)<br>$$</p><p>剩下的就是高精了，建一个结构体，写一个加法和乘法。</p><p>但这道题让我感受到了常数的力量。</p><p>最开始我写了一个+=，写了一个*，乘法会返回一个大整数类型，加等于就直接穿引用修改。<br>这样在洛谷上94ms过。<br>但BZOJ上TLE了（时限1000ms）。。。</p><p>于是我不得不常数优化。<br>把乘法改成乘等于，所有运算都是传引用，避免了频繁的复制操作。<br>结果洛谷上76ms，看起来没差多少<br>然而，BZOJ上108ms成功AC。。。</p><p>BZOJ是有毒吧，或者还是洛谷有毒？</p><p>所以告诉我们写高精是注意能引用就引用，尽量不要复制，常数很大的。</p><p>还有就是乘法运算进位不能直接加上去，要用一个变量先存一下，这个调了很久。（太菜了）</p><p>其实这个做法可以用差分序列来优化，复杂度小一些，也不用写乘法了，但我最后卡常成功（暗笑，冷笑）<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bigint</span>&#123;</span> <span class="keyword">int</span> n[<span class="number">10010</span>], len; &#125;f[<span class="number">110</span>], g[<span class="number">110</span>], ans, tmp;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(bigint &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">"%d"</span>, a.n[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> += (bigint &amp;a, bigint &amp;b) &#123;</span><br><span class="line">    a.len = max(a.len, b.len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">        a.n[i] += b.n[i], a.n[i+<span class="number">1</span>] += a.n[i] / <span class="number">10</span>, a.n[i] %= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(a.n[a.len]) a.len++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> *= (bigint &amp;a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++) </span><br><span class="line">        a.n[i] *= b, a.n[i] += x, x = a.n[i] / <span class="number">10</span>, a.n[i] %= <span class="number">10</span>;</span><br><span class="line">    a.n[a.len] = x;</span><br><span class="line">    <span class="keyword">while</span>(a.n[a.len]) </span><br><span class="line">        a.n[a.len + <span class="number">1</span>] += a.n[a.len] / <span class="number">10</span>, a.n[a.len] %= <span class="number">10</span>, a.len++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    f[<span class="number">0</span>].n[<span class="number">0</span>] = <span class="number">1</span>; f[<span class="number">0</span>].len = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>].n[<span class="number">0</span>] = <span class="number">1</span>; f[<span class="number">1</span>].len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) </span><br><span class="line">            tmp = f[i - j], tmp *= j, f[i] += tmp;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; ' '; print(f[i]);</span></span><br><span class="line">    ans += f[n]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) </span><br><span class="line">        tmp = f[n - j], tmp *= (j - <span class="number">1</span>) * j, ans += tmp;</span><br><span class="line">    print(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 组合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ4698 Sandy的卡片</title>
      <link href="/2019/02/02/BZOJ4698-Sandy%E7%9A%84%E5%8D%A1%E7%89%87/"/>
      <url>/2019/02/02/BZOJ4698-Sandy%E7%9A%84%E5%8D%A1%E7%89%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4698" target="_blank" rel="noopener">BZOJ4698</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题目中说道相同的子串，也就提示我们用后缀数组了。（这是套路）<br>把所有字符拼在一起，中间加一个不会出现的字符（这也是套路）<br>两个子串差一个固定的数，我们可以使用差分，求出相邻两个字符串的差，就转化为很裸的字符串相等了。（这还是套路）</p><p>构建后缀数组和lcp，二分答案，假设当前判断x是否可行。<br>从前向后扫描后缀数组，所有height大于等于x的后缀会把sa分成很多段。统计是否有一段出现了所有n个字符串。<br>统计的过程中可以使用v数组加时间戳维护，先处理出每个字符属于n个字符串中的哪个，统计过程中每遇到一个新的段就tim++，v数组在每次check开始时清就可以了，这样可以保证时间复杂度为O(nlogn)</p><p>最后二分出来的相同长度+1就是答案，之所以要加一是因为前面差分时去掉了第一个。</p><p>注意点：</p><ul><li>后缀数组的模板实在容易写错啊！！</li><li>统计时开启新的一段要把当前位置的这个字符算在里面（包括cnt=1和维护v）</li><li>拼在一起时加的那个字符最好不一样，至于为什么我还没有搞清楚，但最开始我放一样的字符似乎总有问题</li><li>差分的时候为了防止负数出现，要一起加一个值，最好是所有字符的max值</li></ul><p>总之就是一道很套路的题吧。<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s[N], t1[N], t2[N], sa[N], height[N], rankk[N], len, c[N], v[N], bel[N];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>][<span class="number">110</span>], mm[<span class="number">1010</span>], mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_sa</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *x = t1, *y = t2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) c[x[i] = s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) sa[--c[x[i]]] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - k; i &lt; n; i++) y[p++] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(sa[i] &gt;= k) y[p++] = sa[i] - k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) c[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) c[x[y[i]]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) sa[--c[x[y[i]]]] = y[i];</span><br><span class="line"></span><br><span class="line">swap(x, y);</span><br><span class="line">p = <span class="number">1</span>; x[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">x[sa[i]] = y[sa[i]] == y[sa[i<span class="number">-1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i<span class="number">-1</span>] + k] ? p - <span class="number">1</span> : p++;</span><br><span class="line"><span class="keyword">if</span>(p &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">m = p;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) rankk[sa[i]] = i;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!rankk[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(k) k--;</span><br><span class="line"><span class="keyword">int</span> j = sa[rankk[i] - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(s[i + k] == s[j + k]) k++;</span><br><span class="line">height[rankk[i]] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line"><span class="keyword">int</span> tim = <span class="number">1</span>, cnt = <span class="number">1</span>; v[bel[sa[<span class="number">0</span>]]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(height[i] &lt; x) &#123;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt;= len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">tim++; cnt = <span class="number">1</span>; v[bel[sa[i]]] = tim;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s[sa[i]] &gt; mx + mx) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(tim != v[bel[sa[i]]]) cnt++;</span><br><span class="line">v[bel[sa[i]]] = tim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mm[i]); r = max(r, mm[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mm[i]; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]), mx = max(mx, a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= mm[i]; j++) </span><br><span class="line">bel[len] = i, s[len++] = a[i][j] - a[i][j<span class="number">-1</span>] + mx;</span><br><span class="line">s[len++] = mx + i + mx;</span><br><span class="line">&#125;</span><br><span class="line">swap(n, len);</span><br><span class="line">get_sa(mx + len + mx + <span class="number">2</span>); </span><br><span class="line">get_height();</span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l = mid; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
          <category> 后缀数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案 </tag>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSOI冬令营D2 题</title>
      <link href="/2019/01/28/JSOI%E5%86%AC%E4%BB%A4%E8%90%A5D2-%E9%A2%98/"/>
      <url>/2019/01/28/JSOI%E5%86%AC%E4%BB%A4%E8%90%A5D2-%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>这场比赛真是不难啊不难，但是我还是只会写暴力啊暴力~~~</p><!-- toc --><ul><li><a href="#t1-箱子">T1 箱子</a></li><li><a href="#t2-准备">T2 准备</a></li><li><a href="#t3-回忆">T3 回忆</a></li></ul><!-- tocstop --><a id="more"></a><h1><span id="t1-箱子">T1 箱子</span></h1><p>考试时想了各种方法，什么dp、网络流、数据结构，总觉得昨天那么难，今天不可能只出一道贪心。结果谁知道，就是一道极水极水的小贪心。</p><p>$a \le b$ 的那部分显然按照a递增排序。</p><p>$a &gt; b$ 的部分按b递减排序。证明如下：<br>假设$ b_x &gt; b_y $<br>若x排在y的前面不合法，也就是$ sumV+b_x-a_x &lt; a_y $<br>则易得$ sumV + b_y - a_y &lt; a_x $<br>也就是说y排在x的前面也一定不合法。<br>所以x排在前面一定不会更差。<br>因此把b较大的x排在前面。</p><p>my代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f * res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> v;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span>&#123;</span> <span class="keyword">int</span> a, b; &#125;p[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(P x, P y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.a &lt; x.b) </span><br><span class="line"><span class="keyword">if</span>(y.a &lt; y.b) <span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">if</span>(y.a &lt;= y.b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x.b &gt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"a.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"a.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> T; T = read();</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line">n = read(); v = read(); <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i].a = read(), p[i].b = read();</span><br><span class="line">sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(v - p[i].a &lt; <span class="number">0</span>) &#123; flag = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">v -= p[i].a; v += p[i].b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="t2-准备">T2 准备</span></h1><p>事实上这题我在考场上想到正解了，只是最后没有调出来而已。后来发现有一个地方写错了一个字母。唉~。</p><p>考虑用已经计算过的答案得到下一次的答案，也就是维护。容易看出，只要知道每一次有多少个负数就可以$ O(1) $转移了。</p><p>而每一次有多少个负数实际上是内定了的，也就是根据$ a[i] $可以预处理出来。考虑每个$ a[i] $对他的贡献，也就是这个a何时会变成负的。所有这样的时刻都是区间，可以用差分实现。</p><p>代码实现时要注意差分的位置，我第一也在这个地方晕了。<br>其他没有什么难的。关键注意从不同角度思考问题吧。</p><p>my代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4000020</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f * res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[N+N], n, ans = <span class="number">1e16</span>;</span><br><span class="line">ll s[N+N], b[N+N], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"b.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"b.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(a[i] &lt; i) s[<span class="number">1</span>]++, s[i+<span class="number">1</span>-a[i]]--;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i+<span class="number">1</span>]++, s[i + n - a[i] + <span class="number">1</span>]--;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = b[i<span class="number">-1</span>] + s[i];</span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; b[i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res += <span class="built_in">abs</span>(a[i] - i);</span><br><span class="line">ans = min(ans, res);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">res -= b[i<span class="number">-1</span>];</span><br><span class="line">res += n - b[i<span class="number">-1</span>];</span><br><span class="line">res -= a[i<span class="number">-1</span>];</span><br><span class="line">res += <span class="built_in">abs</span>(a[i<span class="number">-1</span>] - n);</span><br><span class="line">ans = min(ans, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="t3-回忆">T3 回忆</span></h1><p>其实我考试时也想到用线段树维护了，但但但，没有想到只要单点修改就可以。</p><p>我感觉这题就巧妙在这里，我们很容易想到用两个线段树分别维护$ l[i] - r[i] $和$ l[i] + r[i] $，但在哪些点上维护？有在哪个区间查询？</p><p>我们按l从小到大处理每个区间，把每个已处理过的区间的右端点在线段树上单点更新。查询时，不包含情况是查询$ [l,r] $，包含的情况查询$ [r, +\infty] $，这真巧妙，非常棒地区分了两种情况，还十分简洁。以后要记住这种方法。</p><p>细节部分脑补一下就可以了，别忘了离散化。</p><p>my代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f * res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans, refl[N+N], num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intv</span>&#123;</span> <span class="keyword">int</span> l, r; &#125;p[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(intv x, intv y)</span> </span>&#123; <span class="keyword">return</span> x.l == y.l ? x.r &gt; y.r : x.l &lt; y.l; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tr1[N*<span class="number">40</span>], tr2[N*<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> *tr, <span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    tr[p] = inf;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(tr, p*<span class="number">2</span>, l, mid); build(tr, p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> *tr, <span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    tr[p] = min(tr[p], x);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) change(tr, p*<span class="number">2</span>, l, mid, pos, x);</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; mid) change(tr, p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, pos, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> *tr, <span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[p];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = inf;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) res = min(res, query(tr, p*<span class="number">2</span>, l, mid, L, R));</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) res = min(res, query(tr, p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"c.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"c.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">n = read(); <span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i].l = read(), p[i].r = read(), refl[++num] = p[i].l, refl[++num] = p[i].r;</span><br><span class="line">sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp);</span><br><span class="line">    sort(refl + <span class="number">1</span>, refl + <span class="number">1</span> + num);</span><br><span class="line">    num = unique(refl + <span class="number">1</span>, refl + <span class="number">1</span> + num) - refl - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i].l = lower_bound(refl + <span class="number">1</span>, refl + <span class="number">1</span> + num, p[i].l) - refl, </span><br><span class="line">                                p[i].r = lower_bound(refl + <span class="number">1</span>, refl + <span class="number">1</span> + num, p[i].r) - refl;</span><br><span class="line">build(tr1, <span class="number">1</span>, <span class="number">1</span>, num); build(tr2, <span class="number">1</span>, <span class="number">1</span>, num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">tmp = query(tr1, <span class="number">1</span>, <span class="number">1</span>, num, p[i].l, p[i].r);</span><br><span class="line">        ans = max(ans, refl[p[i].r] + refl[p[i].l] - tmp);</span><br><span class="line">        tmp = query(tr2, <span class="number">1</span>, <span class="number">1</span>, num, p[i].r, num);</span><br><span class="line">        ans = max(ans, refl[p[i].l] - refl[p[i].r] - tmp);</span><br><span class="line">        change(tr1, <span class="number">1</span>, <span class="number">1</span>, num, p[i].r, refl[p[i].l] + refl[p[i].r]);</span><br><span class="line">        change(tr2, <span class="number">1</span>, <span class="number">1</span>, num, p[i].r, refl[p[i].l] - refl[p[i].r]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>明天再接再厉，不信做不出来水题。</p>]]></content>
      
      
      <categories>
          
          <category> 集训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搞 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSOI冬令营D1 题</title>
      <link href="/2019/01/28/JSOI%E5%86%AC%E4%BB%A4%E8%90%A5D1-%E9%A2%98/"/>
      <url>/2019/01/28/JSOI%E5%86%AC%E4%BB%A4%E8%90%A5D1-%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#t1-小l的占卜">T1 小L的占卜</a></li><li><a href="#t2-小f的星术">T2 小F的星术</a></li><li><a href="#t3-小x的咒语">T3 小X的咒语</a></li></ul><!-- tocstop --><a id="more"></a><h1><span id="t1-小l的占卜">T1 小L的占卜</span></h1><p>首先发现，T = 1时，问的就是区间异或和，因为偶数个数的异或和为0，剩下的只是奇数了。</p><p>当T = 2时，可以求出区间内所有出现过的数的异或和（每种数只算一次），然后异或掉区间异或和就可以了。<br>那么考虑怎么每种数只算一次。考虑离线操作。<br>把所有的操作按照左端点排序。先把每种数第一次出现的位置在树状数组上使能（也就是异或这个位置的数），然后从前往后扫描每一个询问，L向后推移，把L之前的数在树状数组上的贡献去掉，同时使能它下一次出现的位置。查询R的前缀异或和就可以了。</p><p>听说这是一个很套路的方法，但我真不会套路啊，学习了。</p><p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">1</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f ? -res : res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s[N], a[N], tmp[N], c[N], ans[N], p[N], num, na[N];</span><br><span class="line"><span class="keyword">int</span> nxt[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = p; p &lt;= n; p += p&amp;-p) c[p] ^= a[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p -= p&amp;-p) res ^= c[p];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span> <span class="keyword">int</span> i, l, r, t; &#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Q x, Q y)</span> </span>&#123; <span class="keyword">return</span> x.l &lt; y.l; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"augury.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"augury.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> kase; kase = read();</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), p[++num] = a[i];</span><br><span class="line">    sort(p + <span class="number">1</span>, p + <span class="number">1</span> + num);</span><br><span class="line">    num = unique(p + <span class="number">1</span>, p + <span class="number">1</span> + num) - p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) na[i] = lower_bound(p + <span class="number">1</span>, p + <span class="number">1</span> + num, a[i]) - p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i<span class="number">-1</span>] ^ a[i];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) q[i].l = read(), q[i].r = read(), q[i].t = read(), q[i].i = i;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[na[i]]) add(i), v[na[i]] = i; </span><br><span class="line">        <span class="keyword">else</span> nxt[v[na[i]]] = i, v[na[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ll = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(ll &lt; q[i].l) add(ll), add(nxt[ll]), ll++;</span><br><span class="line">        ans[q[i].i] = s[q[i].r] ^ s[q[i].l - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(q[i].t == <span class="number">1</span>) ans[q[i].i] ^= query(q[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="t2-小f的星术">T2 小F的星术</span></h1><p>数学期望 + 树形dp，我们都知道，但怎么做呢，我连链的情况都没写出来~。</p><p>要先想到<br>$$<br>E(x) = P(x\ge 1) + P(x\ge 2) + P(x\ge 3) + …<br>$$<br>其中x为正整数。</p><p>也就是说，我们只要求出<strong>找到K条不相交路径的方案数</strong>，把他们加起来，在乘以$ \frac{n(n+1)}2 $的逆元就可以了。</p><p>这个和第二天讲的一道树形dp题一样。<br>用$ dp[i][j][0/1/2] $表示以i为根的子树，j条路径，i不取、i取且路径未结束、i取且路径无法向上延伸的方案数。</p><p>然后考虑状态转移，假设我们当前处于pos节点的儿子x处，dp[pos]记录的是x之前的信息，我们要把x的信息也合并进去。分类讨论。</p><p>这里情况比较繁琐，我看了很久才看懂标程，就不重新写一遍了，直接贴标程如下，转移写的很清楚:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(T &amp;x, T y)</span> </span>&#123;x = max(x, y); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(T &amp;x, T y)</span> </span>&#123;x = min(x, y); &#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = -f;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">9</span>) write(x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeln</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">write(x);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, sz[MAXN], dp[MAXN][MAXN][<span class="number">3</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x += y;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= P) x -= P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">sz[pos] = <span class="number">1</span>;</span><br><span class="line">dp[pos][<span class="number">1</span>][<span class="number">0</span>] = dp[pos][<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : a[pos])</span><br><span class="line"><span class="keyword">if</span> (x != fa) &#123;</span><br><span class="line">work(x, pos);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> res[MAXN][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz[pos] + sz[x]; i++)</span><br><span class="line">res[i][<span class="number">0</span>] = res[i][<span class="number">1</span>] = res[i][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sz[pos]; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sz[x]; j++) &#123;</span><br><span class="line">update(res[i + j][<span class="number">0</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">0</span>] * dp[x][j][<span class="number">0</span>] % P);</span><br><span class="line"><span class="keyword">if</span> (i + j) update(res[i + j - <span class="number">1</span>][<span class="number">1</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">0</span>] * dp[x][j][<span class="number">0</span>] % P);</span><br><span class="line">update(res[i + j][<span class="number">0</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">0</span>] * dp[x][j][<span class="number">1</span>] % P);</span><br><span class="line"><span class="keyword">if</span> (i + j) update(res[i + j - <span class="number">1</span>][<span class="number">1</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">0</span>] * dp[x][j][<span class="number">1</span>] % P);</span><br><span class="line">update(res[i + j][<span class="number">0</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">0</span>] * dp[x][j][<span class="number">2</span>] % P);</span><br><span class="line"></span><br><span class="line">update(res[i + j][<span class="number">1</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">1</span>] * dp[x][j][<span class="number">0</span>] % P);</span><br><span class="line"><span class="keyword">if</span> (i + j) update(res[i + j - <span class="number">1</span>][<span class="number">2</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">1</span>] * dp[x][j][<span class="number">0</span>] % P);</span><br><span class="line">update(res[i + j][<span class="number">1</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">1</span>] * dp[x][j][<span class="number">1</span>] % P);</span><br><span class="line"><span class="keyword">if</span> (i + j) update(res[i + j - <span class="number">1</span>][<span class="number">2</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">1</span>] * dp[x][j][<span class="number">1</span>] % P);</span><br><span class="line">update(res[i + j][<span class="number">1</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">1</span>] * dp[x][j][<span class="number">2</span>] % P);</span><br><span class="line"></span><br><span class="line">update(res[i + j][<span class="number">2</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">2</span>] * dp[x][j][<span class="number">0</span>] % P);</span><br><span class="line">update(res[i + j][<span class="number">2</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">2</span>] * dp[x][j][<span class="number">1</span>] % P);</span><br><span class="line">update(res[i + j][<span class="number">2</span>], <span class="number">1l</span>l * dp[pos][i][<span class="number">2</span>] * dp[x][j][<span class="number">2</span>] % P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz[pos] + sz[x]; i++) &#123;</span><br><span class="line">dp[pos][i][<span class="number">0</span>] = res[i][<span class="number">0</span>];</span><br><span class="line">dp[pos][i][<span class="number">1</span>] = res[i][<span class="number">1</span>];</span><br><span class="line">dp[pos][i][<span class="number">2</span>] = res[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">sz[pos] += sz[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = power(x, y / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (y % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1l</span>l * tmp * tmp % P;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1l</span>l * tmp * tmp % P * x % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"astrology.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"astrology.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> num; read(num); read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y; read(x), read(y);</span><br><span class="line">a[x].push_back(y);</span><br><span class="line">a[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">work(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>, tot = ((dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">2</span>]) % P + dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) % P;</span><br><span class="line"><span class="keyword">int</span> fac = <span class="number">1</span>, frac = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">fac = <span class="number">1l</span>l * fac * i % P;</span><br><span class="line">frac = <span class="number">1l</span>l * frac * tot % P;</span><br><span class="line"><span class="keyword">int</span> now = ((dp[<span class="number">1</span>][i][<span class="number">1</span>] + dp[<span class="number">1</span>][i][<span class="number">2</span>]) % P + dp[<span class="number">1</span>][i][<span class="number">0</span>]) % P;</span><br><span class="line">update(ans, <span class="number">1l</span>l * now * fac % P * power(frac, P - <span class="number">2</span>) % P);</span><br><span class="line">&#125;</span><br><span class="line">writeln(ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="t3-小x的咒语">T3 小X的咒语</span></h1><p>组合数学毒瘤题，推公式，要能够清晰地运用容斥原理，很难了。</p><img src="/2019/01/28/JSOI冬令营D1-题/1.JPG"><img src="/2019/01/28/JSOI冬令营D1-题/2.JPG"><img src="/2019/01/28/JSOI冬令营D1-题/3.jpg"><p>my proud code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line">ll c[N][N], fac[N+N], rev[N], p, n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"abracadabra.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"abracadabra.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> kase; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;kase);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;p);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++) fac[i] = fac[i<span class="number">-1</span>] * i % p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) c[i][j] = (c[i<span class="number">-1</span>][j<span class="number">-1</span>] + c[i<span class="number">-1</span>][j]) % p;</span><br><span class="line">    rev[<span class="number">0</span>] = <span class="number">1</span>; rev[<span class="number">1</span>] = (p + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) rev[i] = rev[i<span class="number">-1</span>] * rev[<span class="number">1</span>] % p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k + j &lt;= n; k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + j + k &lt;= n; i++) &#123;</span><br><span class="line">                ll tmp = c[n][j] * c[n-j][k] % p * c[n-j-k][i] % p</span><br><span class="line">                     * c[j+k][j] % p * rev[j+k] % p * rev[k] % p * fac[j] % p * fac[<span class="number">2</span>*k+i] % p;</span><br><span class="line">                <span class="keyword">if</span>((i + j) % <span class="number">2</span> == <span class="number">0</span>) ans = (ans + tmp) % p;</span><br><span class="line">                <span class="keyword">else</span> ans = (ans + tmp * (p<span class="number">-1</span>) % p) % p;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 集训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 树形dp </tag>
            
            <tag> 搞 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 数学期望 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSOI冬令营D2 课</title>
      <link href="/2019/01/28/JSOI%E5%86%AC%E4%BB%A4%E8%90%A5D2-%E8%AF%BE/"/>
      <url>/2019/01/28/JSOI%E5%86%AC%E4%BB%A4%E8%90%A5D2-%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1><span id="树形动态规划">树形动态规划</span></h1><p>一些关于树和dp的题，比较有难度，请谨慎<br><a id="more"></a></p><hr><blockquote><p>给定一个图G，求两点之间最短距离的最大值<br>G是普通图<br>G是树<br>G是基环树</p></blockquote><p>基环树情况：<br>先不考虑环，每一棵树求一个到根的最长路径。这棵树就没用了。然后把环拆成链，单调队列维护dp就可以。</p><hr><blockquote><p>给定一棵树T，求k条不想交的路径的方案数（点构成的路径）</p></blockquote><p>k = 2：<br>考虑树上的一条链有一个lca，这两条链的lca会有一个lca。<br>如果他们位于大lca的不同子树，则求出每个子树的大小，答案贡献为$<br>\sum_{u\not =v}C_{u+1}^2C_{v+1}^2<br>$<br>其中u、v为两棵子树，但这样需要$ O(n^2) $枚举，太慢了，变形为$(\sum_uC_{u+1}^2)^2-\sum_u(C_{u+1}^2)^2$<br>这样就可以$ O(n) $了<br>如果大lca就是其中一点，枚举另一点位置，另外一条链在这棵树剩下部分（也就是砍掉那棵子树），用组合数算就可以了。</p><p>k 任意<br>用$dp[i][j][0/1/2]$表示以i为根的子树，j条链，i取且其链继续向上扩展、i取但这条链已结束、i不取的方案数。<br>树形+背包dp<br>状态转移尚未搞懂，回头再说</p><hr><blockquote><p>给定一棵数，求最小点覆盖</p></blockquote><p>$ dp[i][0/1] $表示以i为根子树，i去或不取的最小点覆盖。<br>$ dp[i][0] = \sum_{fa[j] = i}dp[j][1] $<br>$ dp[i][1] = \sum_{fa[j] = i}max(dp[j][0], dp[j][1]) $</p><hr><blockquote><p>给定一棵树T，求所有简单路径边权积的和取模<br>SPOJ MTREE</p></blockquote><p>$ f[i] $表示从i往下的链积的和。可以维护出来$ f[i] $<br>然后枚举lca，求出$ \sum_{x\not=y}f[x] <em> w_x </em> f[y] * w[y] $，x、y为lca的子树，化简同上。</p><hr><blockquote><p>给定一个树T，在T上寻找两条严格不想交的路径，使其长度之积最大，求这个积。<br>SPOJ TWOPATHS</p></blockquote><p>分两种情况</p><ol><li>一条路径就是直径，另一条是其他路径中最大的</li><li>两条路径都只包含直径的一部分，枚举直径上相邻的两个点即可</li></ol><hr><blockquote><p>给定一棵树T，在T上先去掉一条边，再加上一条树边，重新构成一棵树T’，要使T’的直径最小，求一种方案。<br>SPOJ treecst</p></blockquote><p>加边时一定是加在两棵树直径的中点上。从根开始dfs枚举砍掉的边，维护两个直径，更新答案。</p><hr><blockquote><p>给定一棵树T，以及起点X终点Y，T上每一个节点都以给定的概率向其相邻的节点走，允许重复经过同一个点，求从X到Y的期望步数。<br>SPOJ GS</p></blockquote><p>以Y为根。<br>令$ f[i] $表示从i走到i的父亲的期望步数，$ p_i $表示i走向父亲的概率，$ p_{ij} $表示i走向第j个儿子的概率。<br>$ f[i] = p_i * 1 + \sum_{j=1}^kp_{ij}(1+f[son[i][j]] + f[i]) $ ，其中k为i的子树个数。<br>这事实上是一个方程，$ f[i] $为未知数，其他都是已求或已知的常量。手动求解即可。</p><hr><blockquote><p>给定一棵树或者基环树，以相等的概率选择一个起点，每一步等概率地走向未经过得点，求期望的移动步数<br>PS:给定的基环树中，环长不超过20<br>NOI2012 Day2 T1 迷失游乐园</p></blockquote><p>$ up[i] $表示从i向上走的期望步数。<br>$ down[i] $表示从i向下走的期望步数。<br>一遍dfs可以求出down，再一遍求出up，树的情况解决了。</p><p>基环树时，先对每个数向上面一样求down。<br>预处理出$ p[i][j][0/1] $表示从i顺/逆时针到j的概率。<br>之后dfs统计up，计算答案。</p><hr><blockquote><p>给定一棵带权无根树T，先选一点作为树根，然后每一步操作可以任选一点u，将树边$ (u,fa(u)), (fa(u), fa(fa(u))) $一起覆盖。同时，所有操作要满足，每条树边只被覆盖至多一次，求所有被覆盖的树边总长度的最大值。<br>APIO2014 T3 连珠线</p></blockquote><p>$ dp[i][0/1] $表示以i为根的子树，i是不是中间点，最大被覆盖边权<br>任选一个根，$ O(n) $求出所有dp值<br>然后考虑换根，选当前根的一个儿子作为新的根，对dp数组进行维护，可以$ O(1) $做到，多记录一些信息，和之前的转移是一样的。<br>取最大值即可。</p>]]></content>
      
      
      <categories>
          
          <category> 集训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数学整理集锦</title>
      <link href="/2019/01/23/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86%E9%9B%86%E9%94%A6/"/>
      <url>/2019/01/23/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#排列的生成">排列的生成</a><ul><li><a href="#按字典序思想生成下一个排列">按字典序思想生成下一个排列</a></li></ul></li><li><a href="#排列和组合的计数">排列和组合的计数</a><ul><li><a href="#基本组合恒等式">基本组合恒等式</a></li><li><a href="#两种特殊的排列组合技术公式">两种特殊的排列组合技术公式</a><ul><li><a href="#catalan数">Catalan数</a><ul><li><a href="#公式">公式</a></li><li><a href="#应用">应用</a></li><li><a href="#操练">操练</a></li></ul></li><li><a href="#bell数">Bell数</a></li><li><a href="#stirling数">Stirling数</a></li></ul></li><li><a href="#多重集的排列组合">多重集的排列组合</a><ul><li><a href="#多重集的排列">多重集的排列</a></li><li><a href="#多重集的组合">多重集的组合</a></li></ul></li></ul></li><li><a href="#容斥原理与鸽笼原理">容斥原理与鸽笼原理</a><ul><li><a href="#鸽笼原理">鸽笼原理</a></li><li><a href="#容斥原理">容斥原理</a><ul><li><a href="#计算并集元素个数">计算并集元素个数</a></li><li><a href="#计算错排的方案数">计算错排的方案数</a></li></ul></li><li><a href="#ramsey定理">Ramsey定理</a><ul><li><a href="#ramsey数">Ramsey数</a></li></ul></li></ul></li><li><a href="#波利亚定理">波利亚定理</a><ul><li><a href="#定义们">定义们</a></li><li><a href="#bornside引理">Bornside引理</a></li><li><a href="#波利亚定理-1">波利亚定理</a></li></ul></li><li><a href="#递推与生成函数">递推与生成函数</a><ul><li><a href="#k阶常系数线性齐次递推关系">k阶常系数线性齐次递推关系</a></li><li><a href="#生成函数">生成函数</a></li></ul></li></ul><!-- tocstop --><a id="more"></a><h1><span id="排列的生成">排列的生成</span></h1><h2><span id="按字典序思想生成下一个排列">按字典序思想生成下一个排列</span></h2><p>设当前序列为$ (p) = p_1p_2p_3…p_n $，按字典序思想生成下一个排列方法如下：</p><ol><li>从右向左，计算最后一个<strong>増序</strong>的尾元素的下标i，即$ i = max{j\ |\ p_{j-1} &lt; p_j,\ p_j \ge p_{j+1} } $</li><li>从右向左找到$p_{i-1}$后面比$p_{i-1}$大的最后一个元素的下标j，即$j = max{ k\ |\ k \ge i,\ p_{i-1} &lt; p_k }$</li><li>交换$p_{i-1}$与$p_j$，得到$p_1…p_{i-2}p_jp_ip_{i+1}…p_{j-1}p_{i-1}p_{j+1}…p_n$</li><li>翻转新的$p_j$后面的元素，使其递增（也就是说原来是递减的），得到$p_1…p_{i-2}p_jp_n…p_{j+1}p_{i-1}p_{j-1}…p_{i+1}p_i$</li></ol><p>原理想想就明白啦，下面有一道题：</p><blockquote><p><a href="http://poj.org/problem?id=1146" target="_blank" rel="noopener">POJ1146 ID Codes</a></p></blockquote><p>就是一道很裸的题，直接来代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str) &amp;&amp; <span class="built_in">strcmp</span>(str, <span class="string">"#"</span>)) &#123; </span><br><span class="line">        len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i<span class="number">-1</span>] &lt; str[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt;= i; j--) <span class="keyword">if</span>(str[i<span class="number">-1</span>] &lt; str[j]) &#123; swap(str[i<span class="number">-1</span>], str[j]); <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= len - (j - i + <span class="number">1</span>); j++) swap(str[j], str[len - (j - i + <span class="number">1</span>)]);</span><br><span class="line">                <span class="built_in">puts</span>(str); flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="built_in">puts</span>(<span class="string">"No Successor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再说一句，要注意看清楚流程中的大于号和大于等于号，另外就是当找不到时代表已经找完了，这就是最后一个，算法结束。</p><h1><span id="排列和组合的计数">排列和组合的计数</span></h1><h2><span id="基本组合恒等式">基本组合恒等式</span></h2><p>$$<br>\sum_{i=0}^{n} {n \choose i} = 2 ^ n $$$$<br> \sum_{i=0}^{n} {i \choose x} = {n+1 \choose x+1} $$$$<br> \sum_{i=0}^{n} {k+i \choose i} = {k+n+1 \choose n} $$$$<br> \sum_{i=0}^{m} {m \choose i} {n-m \choose m-i} = {n \choose m}<br>$$</p><h2><span id="两种特殊的排列组合技术公式">两种特殊的排列组合技术公式</span></h2><h3><span id="catalan数">Catalan数</span></h3><h4><span id="公式">公式</span></h4><blockquote><p>Catalan数是序列｛C｝，其中 $ C_0=1,\ C_1=1,$$$C_n = C_0C_{n-1}+C_1C_{n-2}+…+C_{n-1}C_0,\ n\ge2. $$</p></blockquote><p>在定义中就已经给出了它最一般的递推式，下面还有几个计算是很常用的：</p><blockquote><p>变形递推式$$ C_n = \frac{4n-2}{n+1}\times C_{n-1}, n &gt; 1 $$</p></blockquote><blockquote><p>通项公式$$ C_n = \frac{C(2n, n)}{n+1}, n = 0, 1, 2… $$$$C_n=C(2n,n)-C(2n,n+1),n=0,1,2…$$</p></blockquote><p>酌情使用，方便为上<br>要注意卡特兰数的下标从0开始，不要随意改，会出现意想不到的问题。</p><h4><span id="应用">应用</span></h4><ol><li><p>由n个1和n个0构成2n项满足所有前缀中1比0多的序列个数等于第n个Catalan数。<br>证明：我们先求出所有的序列，然后减去不合法的序列即是答案。所有序列个数直接根据组合数的定义为$C(n,2n)$，现在要证明满足存在一个结论中所说的序列与n+1个0与n-1个1构成的01序列构成一个双射，即11对应关系，因为很显然，后者的数量为$C(n−1,2n)$。<br>对前者，很显然可以找到一个位置为$2p+1$的前缀，使得其中有$p+1$个1和$p$个0，好的我们把它取反，即得到了后者。对后者，同理。于是得到了上述第二个通项公式。<br>&emsp;</p></li><li><p>我们可以将应用1变换形式：将1看成右括号，0看成左括号，就变成了左括号和右括号各有n个时，合法括号表达式的个数。比如2个左括号和2个右括号组成的合法表达式有种，是()()和(())。<br>&emsp;</p></li><li><p>n个节点构造二叉树的所有可能形态数为$C_n$。<img src="http://daybreakcx.is-programmer.com/user_files/daybreakcx/Image/Catalan_number_binary_tree_example.png" alt=""><br>考虑随便取一个节点作为根，那么他左边和右边的儿子节点个数就确定了，假定根节点标号为x，那么左子树的标号就是从1到x-1,共x-1个，右子树的标号就是从x+1到n，共n-x个，那么将x从1取到n，就获得了所有的情况数。得到的为定义递推式。<br>&emsp;</p></li><li><p>n个非叶节点的满二叉树的形态数（对称后得到的二叉树除非自己本身对称，否则算是不同）。对于满二叉树，实际上就是将应用4中的每个子节点的空儿子上都加上叶子，就形成了对应的满二叉树，那么n个非叶节点形成的满二叉树的形态数即为$C_n$<br>&emsp;</p></li><li><p>对于一个n*n的正方形网格，每次只能向右或者向上移动一格，那么从左下角到右上角所有在副对角线右下方的路径总数为$C_n$。<img src="http://daybreakcx.is-programmer.com/user_files/daybreakcx/Image/450px-Catalan_number_4x4_grid_example.svg.png" alt=""><br>可以将一条水平边记为+1,垂直边记为-1,那么就组成了一个n个+1和n个-1的序列，并且保证前k步中水平边数不小于垂直边数，换句话说前k个元素的和非负。<br>&emsp;</p></li><li><p>对凸n+2边形进行不同的三角形分割（只连接顶点对形成n个三角形）数为$C_n$<br><img src="http://daybreakcx.is-programmer.com/user_files/daybreakcx/Image/400px-Catalan-Hexagons-example.svg.png" alt=""><br>&emsp;</p></li><li><p>n个数入栈后的出栈的排列总数是$C_n$。例如1,2,3入栈的出栈排序有123，132，213，231和321五种<br>&emsp;</p></li><li><p>n层的阶梯切割为n个矩形的切法数也是。如下图所示：<img src="http://daybreakcx.is-programmer.com/user_files/daybreakcx/Image/400px-Catalan_stairsteps_4.svg.png" alt=""><br>考虑先绘制如下图片，即n为5的时候的阶梯：<br><img src="http://daybreakcx.is-programmer.com/user_files/daybreakcx/Image/stairs.png" alt=""><br>注意到每个切割出来的矩形都必需包括一块标示为*的小正方形，那么此时枚举每个*与#标示的两角作为矩形，剩下的两个小阶梯就是我们的两个更小的子问题了。</p></li></ol><p>&emsp;<br>事实上，从应用中我们也可以看到很多证明通项公式的方法。</p><h4><span id="操练">操练</span></h4><p>给道题目吧：</p><blockquote><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2822" target="_blank" rel="noopener">BZOJ2822: [AHOI2012]树屋阶梯</a></p></blockquote><p>卡特兰数+高精度，比较裸，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;l = a[<span class="number">0</span>]; <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;</span><br><span class="line">        a[i] = a[i] * x + left;</span><br><span class="line">        left = a[i] / mod;</span><br><span class="line">        a[i] = a[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left) a[++l] = left % mod, left /= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;l = a[<span class="number">0</span>]; <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i; i--)&#123;</span><br><span class="line">        a[i] += left * mod;</span><br><span class="line">        left = a[i] % x;</span><br><span class="line">        a[i] /= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!a[l]) l--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = a[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[l]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l - <span class="number">1</span>; i; i--) <span class="built_in">printf</span>(<span class="string">"%04d"</span>, a[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    a[<span class="number">0</span>] = a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) mul(a, i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) div(a, i);</span><br><span class="line">    div(a, n + <span class="number">1</span>);</span><br><span class="line">    print(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="bell数">Bell数</span></h3><blockquote><p>Bell数是集合的划分数，也是一个集合上的等价关系的数目；Bell数{B}, 其中$B_n$是包含n个元素的集合的划分方法的数目。显然，$B_0=1, B_1=1, B_2=2, B_3=5$$$B_{n+1} = \sum_{k=0}^nC(n, k)B_k $$</p></blockquote><p>很简单吧</p><h3><span id="stirling数">Stirling数</span></h3><blockquote><p>第一类Stirling数是将n个不同元素放入m个环排列的数目。其中，$S(n, 0)=0,\ S(1,1)=1$$$S(n, m) = S(n-1, k-1) + (n-1)*S(n-1, m)$$</p></blockquote><img src="/2019/01/23/组合数学整理集锦/stirling1.jpg"><p>生成函数:<br>$$<br>\begin{aligned}<br>&amp; x^{\overline{n}} = \sum_{i=0}^{n} \begin{bmatrix} n \ i \end{bmatrix} x^i \<br>&amp; x^{\underline{n}}= \sum_{i=0}^{n} (-1)^{n-i} \begin{bmatrix} n \ i \end{bmatrix} x^i<br>\end{aligned}<br>$$</p><blockquote><p>第二类Stirling数是将n个元素的集合划分为k个不为空的子集的方式的个数，其中$S(n, n) = S(n, 1) = 1 $$$S(n, m) = S(n-1, m-1) + k * S(n-1, m) $$</p></blockquote><img src="/2019/01/23/组合数学整理集锦/stirling2.jpg"><p>生成函数:</p><p>$$<br>\begin{aligned}<br>&amp; x^n = \sum_{i=0}^{n} {n \brace i} x^{\underline{i}} \<br>&amp; m!{n \brace m} = \sum_{i=0}^{m} (-1)^{m-i} {m \choose i} i^n<br>\end{aligned}<br>$$</p><h2><span id="多重集的排列组合">多重集的排列组合</span></h2><blockquote><p>多重集是可重复出现的元素组成的集合。若多重集中不同元素个数为k，称该多重集为k元多重集。多重集中元素$a_i$出现的次数$n_i$称为元素$ai$的重数。若有限多重集S有$a_1, a_2, …, a_k$共k个不同元素，且ai的重数为ni，则S可记为：${ n_1•a_1, n_2•a_2, ……, n_k•a_k }$。</p></blockquote><img src="/2019/01/23/组合数学整理集锦/multi.jpg"><h3><span id="多重集的排列">多重集的排列</span></h3><blockquote><p>设有限多重集$S={ n_1•a_1, n_2•a_2, …, n_k•a_k }$，且$n=n_1+n_2+ ……+n_k$，从S中有序选取r个元素称为S的一个r-排列$(r\le|S|=n)$，当$r=n$时，称为S的一个全排列。</p></blockquote><p>从k元多重集$S= { \infty•a_1,  \infty•a_2, …,  \infty•a_k }$中有序选取r个元素我们也称为S的一个r-排列。</p><blockquote><p>设k元多重集$S= { \infty•a_1, \infty•a_2, …, \infty•a_k }$，则S的r-排列数是$k^r$。</p></blockquote><p>证明太简单，不写了。</p><h3><span id="多重集的组合">多重集的组合</span></h3><blockquote><p>设多重集$S={ n_1•a_1, n_2•a_2, ……, n_k•a_k }$，（这里$n_i$可以是有限也可以是无限的）。S的含有r个元素的子多重集称为S的r-组合。</p></blockquote><blockquote><p>设k元多重集$S= { \infty•a_1, \infty•a_2, …, \infty•a_k }$，设$r\le n_i(\forall i \in [1, k])$则S的r-组合数是$$C_{k+r-1}^r$$</p></blockquote><p>证明：<br>原问题等价于统计下列集合的数量：$ { x_1\cdot a_1, x_2\cdot a_2,…,x_k\cdot a_k } $，其中，$ \sum_{i=1}^k x_i = r $并且$x_i\le n_i$，故原问题等价于r个0，k-1个1构成的全排列数——k-1个1把r个0分成k组，每组的0的数量对应$x_i$。而多重集${ r\cdot 0, (k-1)\cdot 1 }$的全排列数为$$ \frac{(r+k-1)!}{r!(k-1)!} = C_{k+r-1}^r = C_{k+r-1}^{k-1} $$</p><p>对于更为一般的r的情况，需要用到下面的容斥原理，之后再说，敬请期待。</p><h1><span id="容斥原理与鸽笼原理">容斥原理与鸽笼原理</span></h1><h2><span id="鸽笼原理">鸽笼原理</span></h2><img src="/2019/01/23/组合数学整理集锦/cage.jpg"><p>应用鸽笼原理解题的一般步骤：</p><ul><li>分析题意，分清什么是“元素”，什么是“集合”；也就是说，什么可以作为“元素”，什么可以作为“集合”。</li><li>构造集合。这是关键的一步。根据题目条件和结论，结合有关的数学知识，抓住最基本的数量关系，设计和确定解决问题所需的集合及其个数，为应用鸽笼原理奠定基础。<br>应用鸽笼原理解题。</li></ul><p>有一道题目，比较巧妙，巧妙在思路上，代码并不复杂</p><blockquote><p><a href="http://poj.org/problem?id=2356" target="_blank" rel="noopener">POJ2356 Find a multiple</a></p></blockquote><img src="/2019/01/23/组合数学整理集锦/solution1.jpg"><p>鸽笼原理主要还是在于能不能想得到，解决的题目往往令人惊叹，比如这一题，结合起算法中常用的前缀和，就非常非常巧妙。还是要灵活运用啊。</p><h2><span id="容斥原理">容斥原理</span></h2><img src="/2019/01/23/组合数学整理集锦/capdefine.jpg"><p>定义就是这样，开启我们的练习吧——</p><h3><span id="计算并集元素个数">计算并集元素个数</span></h3><blockquote><p><a href="https://vjudge.net/problem/URAL-1091" target="_blank" rel="noopener">Ural 1091 Tmutarakan Exams</a> (这是vjudge上的网址哦)</p></blockquote><img src="/2019/01/23/组合数学整理集锦/solution2.jpg"><p>AC代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, s, p[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, c[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s; i++) <span class="keyword">if</span>(x % i == <span class="number">0</span> &amp;&amp; !p[i] &amp;&amp; !p[x / i] &amp;&amp; i != x / i) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s; i++) c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>] + c[i<span class="number">-1</span>][j];</span><br><span class="line">    p[<span class="number">0</span>] = p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s; i++) <span class="keyword">if</span>(!p[i]) <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= s; j += i) p[j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p[i]) &#123; </span><br><span class="line">            ans += c[(s - i) / i + <span class="number">1</span>][k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(judge(i)) ans -= c[(s - i) / i + <span class="number">1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; min(ans, (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">10000</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一道难一点的</p><blockquote><p><a href="https://vjudge.net/problem/ZOJ-3638" target="_blank" rel="noopener">ZOJ3638 Fruit Ninja</a></p></blockquote><p>下面是我的不知为何没有AC的代码，segment falt，但样例至少是可以过得，一般这种时候我就认为它对了，总之贴出来吧（不过话说这题的输入格式好恶心啊）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">100000007</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, gr, le[<span class="number">20</span>], cnt, num[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line">ll c[<span class="number">10000100</span>][<span class="number">20</span>], ans;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000</span>], tmp1[<span class="number">1000</span>], ty[<span class="number">1000</span>], tmp2[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">17</span>); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j; j -= j&amp;-j) num[i]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1e7</span>+<span class="number">20</span>; i++) c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e7</span>+<span class="number">20</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">18</span>; j++) c[i][j] = (c[i<span class="number">-1</span>][j<span class="number">-1</span>] + c[i<span class="number">-1</span>][j]) % mod;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) == <span class="number">2</span> &amp;&amp; (n || m != <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        ans = gr = cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*getchar();</span></span><br><span class="line"><span class="comment">       while(1) &#123;</span></span><br><span class="line"><span class="comment">            getline(cin, str);</span></span><br><span class="line"><span class="comment">            strcpy(s, str.c_str());</span></span><br><span class="line"><span class="comment">            if(!strcmp(s, "")) break;</span></span><br><span class="line"><span class="comment">            sscanf(s, "%s%s%s%d", tmp1, ty, tmp2, &amp;x);</span></span><br><span class="line"><span class="comment">            if(ty[0] == 'g') gr += x + 1;</span></span><br><span class="line"><span class="comment">            else if(ty[0] == 'l') le[cnt++] = x;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        gets(s);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!gets(s)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(s) &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">sscanf</span>(s,<span class="string">"%s %s %s %d"</span>,tmp1,ty,tmp2,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(ty[<span class="number">0</span>] == <span class="string">'g'</span>) gr += x + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> le[cnt++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; cnt); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)) cur += le[j];</span><br><span class="line">            <span class="keyword">if</span>(n + m - gr - cur - <span class="number">1</span> &gt;= <span class="number">0</span>) ans = (ans + <span class="number">1l</span>l * (num[i] % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>) * c[n + m - gr - cur - <span class="number">1</span>][n - <span class="number">1</span>] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;<br>还记得在上面讲多重集的时候说，r任意的情况要使用容斥原理讨论吗，事实上，上一题已经利用了这一方法。这里再系统讲一下。</p><blockquote><p>设多重集$  $。对于任意整数$  $，从S中取出r个元素组成一个多重集(不考虑顺序)，产生的不同的多重集的数量为$$<br> C_{k+r-1}^{k-1}- \sum_{i=1}^kC_{k+r-n_i-2}^{k-1} + \sum_{1\le i &lt; j \le k}C_{k+r-n_i-n_j-3}^{k-1} - …+(-1)^kC_{k+r-\sum_{i=1}^kn_i-(k+1)}^{k-1}$$</p></blockquote><p><em>证明</em>：<br>不考虑$n_i$的限制，从S中任选r个元素，相当于上一节讨论过的情况，方法数为$C_{k+r-1}^{k-1}$。<br>设$S_i(1\le i\le k)$表示至少包含$n_i+1$个$a_i$的多重集。我们先从S中取出$n_i+1$个$a_i$，然后在任选$r-n_i-1$个元素，即可构成$S_i$。与上面同理，可以构成的不同的$S_i$的数量为$C_{k+r-n_i-2}^{k-1}$<br>进一步地，先从S中取出$n_i+1$个$a_i$和$n_j+1$个$a_j$，然后在任选$r-n_i-n_j-2$个元素，即可构成$S_i\cap S_j$，方法数为$C_{k+r-n_i-n_j-3}^{k-1}$。<br>根据容斥原理，至少有一种$a_i$选取的数量超过$n_i$限制的多重集共有：$$ \begin{vmatrix} \bigcup_{i=1}^kS_i\end{vmatrix} = \sum_{i=1}^kC_{k+r-n_i-2}^{k-1} - \sum_{1\le i &lt; j \le k}C_{k+r-n_i-n_j-3}^{k-1} + …-(-1)^kC_{k+r-\sum_{i=1}^kn_i-(k+1)}^{k-1}  $$<br>故所有满足限制的合法多重集个数即为上述结论。<br><em>证毕</em>。<br>&emsp;<br>总结一下：<br>从上面的应用也可以发现，使用容斥原理时常常使用补集转换思想，先求出题目所要求的补集，它往往是很多子集的并集，可以用容斥原理轻松解决。在这个过程中，“至少”，“有”，“存在”等字眼应相当重视，往往涉及到思路是否清晰。</p><h3><span id="计算错排的方案数">计算错排的方案数</span></h3><img src="/2019/01/23/组合数学整理集锦/otherway.jpg"><p>递推法:<br>设n个元素$a_1, a_2, …, a_n$，错排数目为$D_n$。任取其中一个元素，错排产生有两种情况：<br>情况1：$a_i$与其它$n-1$个元素之一互换，其余$n-2$个元素错排。根据乘法原理，共产生$(n-1) D_{n-2}$个错排；<br>情况2：$a_i$以外的$n-1$个元素先错排，然后$a——i$与其中每个元素互换。根据乘法原理，共产生$(n-1) D_{n-1}$个错排；<br>使用加法原理综合上述情况，可得出递推式：<br>$D_1=0；D_2=1；D_n=(n-1)(D_{n-2}+ D_{n-1})$，其中$n&gt;2$。<br>注意：当$n$较大时，错排数可能会超过任何整数类型允许的范围。在这种情况下一般采用高精度运算，以避免数据溢出。</p><p>依旧一道水题练练手</p><blockquote><p><a href="https://vjudge.net/problem/UVA-10497" target="_blank" rel="noopener">UVA10497 Sweet Child Makes Trouble</a></p></blockquote><p>错排裸题+高精，水题不解释，代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">810</span>][<span class="number">10010</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">800</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10000</span>; j++) f[i][j] += f[i<span class="number">-1</span>][j] + f[i<span class="number">-2</span>][j], f[i][j+<span class="number">1</span>] += f[i][j] / <span class="number">10000</span>, f[i][j] %= <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10000</span>; j++) f[i][j] *= i - <span class="number">1</span>, f[i][j] += x, x = f[i][j] / <span class="number">10000</span>, f[i][j] %= <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">while</span>(!f[n][i] &amp;&amp; i) i--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n][i--]);</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%04lld"</span>, f[n][i--]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="ramsey定理">Ramsey定理</span></h2><blockquote><p>对于任何一个具有6个节点的简单图，要么它包含一个三角形，要么它的补图包含一个三角形。</p></blockquote><p><em>证明：</em><br>设6个节点的简单图为G。考察G中的任意一个节点a，那么，另外5个节点中的任何一个节点，要么在G中与a邻接，要么在G’（G的补图）中与a邻接。这样，就可以把5个节点分成两类：在G中与a邻接，或在G’中与a邻接。<br>因此，根据鸽笼原理，必有一类至少含有3个节点，不妨假设其中的3个节点b, c, d与a邻接。<br>如果b, c, d间有边相连，则命题成立；否则在补图中b, c, d任意两点间有边相连，命题成立。</p><blockquote><p>Ramsey定理  6个人中至少存在3人相互认识或者相互不认识。</p></blockquote><h3><span id="ramsey数">Ramsey数</span></h3><blockquote><p>对于正整数a和b，对应于一个整数r，使得r个人中或有a个人相互认识，或有b个人互不认识；或有a个人互不认识，或有b个人相互认识。这个数r的最小值用R(a, b)来表示。<br>R(3, 3)=6。<br>Ramsey数还有若干推论：R(3, 4)=9，R(4, 4)=18。</p></blockquote><blockquote><p>Ramsey数有如下性质。<br>$R(a, b)= R(b, a)；R(a, 2)=2$。<br>对任意的整数$a, b \ge 2$，$R(a, b)$存在。<br>对任意的整数$a, b，R(a, b)\le R(a-1, b)+ R(a, b-1)$；<br>如果$a, b \ge 2，且R(a-1, b)$和$R(a, b-1)$是偶数，则<br>$$R(a, b)\le R(a-1, b)+ R(a, b-1)-1。<br>R(a, b)\le C(a+b-2, a-1)。$$</p></blockquote><p>说了那么多，其实很简单的burnside引理：</p><ul><li><strong>所有置换写成循环节的形式<br>每个循环节看成一样的，求出染色方案数<br>把所有置换这样求出的方案数算平均数<br>就好了</strong></li></ul><p>根据这一句话，所有类似问题都可以解决了，不用纠结定义，也不用背波利亚定理</p><h1><span id="波利亚定理">波利亚定理</span></h1><p>终于写到这了，首先要介绍群论：</p><h2><span id="定义们">定义们</span></h2><p>群的定义</p><blockquote><p>一个群是一个集合G和一个在集合G上被称为G的群法则的操作，这一操作将任意两个元素a和b合成为一个新元素，标志为a * b或ab。(G, *)满足下述4个条件。<br>[1] 封闭性；对于任意$a, b\in G，a<em>b\in G$。<br>[2] 结合律；对于任意$a, b, c\in G，(a</em>b)<em>c = a</em>(b<em>c)$。<br>[3] 存在单位元素；在G中存在一个元素e，使得对于任意$a\in G，e</em>a = a<em>e = a$。<br>[4] 存在逆元素；对于任意$a\in G$，在G中存在元素$b$，使得$a</em>b = b*a = e$，其中$e$是单位元素。</p></blockquote><p>置换的定义：</p><blockquote><p>设集合A由n个不同元素$a_1, a_2, …, a_n$组成。A中的元素之间的一个置换是$a_1$被A中的某个元素$b_1$所取代，$a_2$被A中的某个元素$b_2$所取代，…，$a_n$ 被A中的某个元素$b_n$；并且$b_1, b_2, …, b_n$互不相同。</p></blockquote><p>置换群：</p><blockquote><p>一个置换群是一个群(G, *)，其元素是${a_1, a_2, ……, a_n}$的置换，而*是置换的合成。<br>也就是说，置换群的元素是置换，操作是置换的合成。Pólya计数公式基于置换群。</p></blockquote><img src="/2019/01/23/组合数学整理集锦/xunhuan.jpg"><p>例如，{1, 2, 3, 4}的所有置换<br>$S_4＝{(1)(2)(3)(4), (12), (13), (14), (23), (24), (34),$<br>$ (123), (124), (132), (134), (142), (143), (234), (243), $<br>$(1234), (1243), (1324), (1342), (1423), (1432), $<br>$(12)(34), (13)(24), (14)(23)}$。</p><img src="/2019/01/23/组合数学整理集锦/xunhuan2.jpg"><p>在$S_4$中，具有相同格式的置换所示如下：<br>$(1)^0(2)^2(3)^0(4)^0$，也就是$(2)^2$，有3个置换：<br>$(12)(34)，(13)(24)$和$(14)(23)$；<br>$(1)^1(3)^1$有8个置换：$(123)，(124)，(132)，(134)，(142)，(143)，(234)$和$(243)$；<br>$(1)^2(2)^1$有6个置换：<br>$(12)，(13)，(14)，(23)，(24)$和$(34)$；<br>$(1)^4$只有1个置换：<br>$(1)(2)(3)(4)$；<br>$(4)^1$有6个置换：<br>$(1234)，(1243)，(1324)，(1342)，(1423)$和$(1432)$。</p><p>共轭类以及其计算定理：<br><img src="/2019/01/23/组合数学整理集锦/共轭类.jpg"></p><p>K不动置换类：</p><blockquote><p>设$K$是${1, 2, …, n}$中的一个数。$G$中使$K$保持不变的置换全体，记为$Z_K$，叫做$G$中使$K$不动的置换类，或简称K不动置换类。</p></blockquote><p>例如，$G={e, (1 2), (3 4), (1 2)(3 4)}。Z_1={e, (3 4)}；Z_2={e, (3 4)}；Z_3={e, (1 2)}；Z_4＝{e, (1 2)}。e$是单位元。显然，$Z_K$是$G$的子群，$K$是${1, 2, 3, 4}$中的一个数。对于$G$，在这一置换下，1可以置换为2，2可以置换为1；3可以置换为4，4可以置换为3。但1或2不可能置换为3或4，而且3或4也不可能置换为1或2。所以，1和2在一个等价类中，3和4在另一个等价类中。</p><p>等价类：</p><blockquote><p>设G是${1, 2, …, n}$的置换群，K是${1, 2, …, n}$中的一个数。在这一置换下，${1, 2, …, n}$可以被划分为若干等价类，K所属的等价类记为$E_K$。</p></blockquote><p>例如，$G={e, (1 2), (3 4), (1 2)(3 4)}$。1和2在一个等价类中，3和4在另一个等价类中。$E_1=E_2={1, 2}，E_3=E_4={3, 4}$。<br>因此，对于数$K，1\le K\le 4$，置换群G有对应的等价类$E_K$和不动置换类$Z_K$。</p><p>长舒一口气，终于介绍完定义了。<br>下面，最关键部分来了。</p><h2><span id="bornside引理">Bornside引理</span></h2><p>一个小结论，但很重要：</p><blockquote><p>设G是${1, 2, …, n}$的置换群，K是${1, 2, …, n}$中的一个数，则$|E_K|*|Z_K| = |G|$。</p></blockquote><p>例如，$G={e, (1 2), (3 4), (1 2) (3 4)}$；<br>$E_1=E_2={1, 2}，E_3=E_4={3, 4}$;<br>$|E_1|=|E_2|=|E_3|=|E_4|=2$；<br>$Z_1＝Z_2＝{e, (3 4)}，Z_3＝Z_4＝{e, (1 2)}$；<br>$ |Z_1|=|Z_2|=|Z_3|=|Z_4|=2$。<br>则$|E_1|* |Z_1|=|E_2|* |Z_2|=|E_3|* |Z_3|=|E_4|*|Z_4|=4=|G|$</p><p>设$G={\alpha_1, \alpha_2, …, \alpha_m}$是一个在${1, 2, …, n}$上的置换群，其中$\alpha_1=e$；$\alpha_k$可以被记为一个若干循环节的乘积，$c_1(\alpha_k)$是置换$\alpha_k$中1阶循环节的个数，$k=1, 2, …, m$。</p><p>要到一个小高潮了</p><img src="/2019/01/23/组合数学整理集锦/burnside.jpg"><p>可以利用上面的结论进行证明：<br>不妨设$ N={ 1, 2, …n } $中共有$L$个等价类，$ N=E_1+E_2+…+E_n $<br>$$<br>\sum_{k=1}^n|Z_k| = \sum_{i=1}^L\sum_{k\in E_i}|Z_k| = \sum_{i=1}^L|E_i|\cdot |Z_i| = L\cdot |G|<br>$$<br>L就是我们要求的等价类数，于是，<br>$$<br>L = \frac{1}{|G|}\sum_{k=1}^n|Z_k| = \frac{1}{|G|}\sum_{j=1}^s|C(\alpha_j)|<br>$$</p><img src="/2019/01/23/组合数学整理集锦/square.jpg"><img src="/2019/01/23/组合数学整理集锦/squ2.jpg"><img src="/2019/01/23/组合数学整理集锦/squ3.jpg"><img src="/2019/01/23/组合数学整理集锦/squ4.jpg"><p>下面，最主要的部分，波利亚定理，闪亮登场</p><h2><span id="波利亚定理">波利亚定理</span></h2><img src="/2019/01/23/组合数学整理集锦/polya.jpg"><p>可以做题了</p><blockquote><p><a href="http://poj.org/problem?id=1286" target="_blank" rel="noopener">POJ 1286 Necklace of Beads</a></p></blockquote><img src="/2019/01/23/组合数学整理集锦/solution4.jpg"><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">30</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= y; i++) res *= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">1</span>; n &lt;= <span class="number">25</span>; n++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans[n] += <span class="built_in">pow</span>(<span class="number">3</span>, gcd(i, n));</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>) ans[n] += <span class="built_in">pow</span>(<span class="number">3</span>, n / <span class="number">2</span> + <span class="number">1</span>) * n;</span><br><span class="line">        <span class="keyword">else</span> ans[n] += <span class="built_in">pow</span>(<span class="number">3</span>, n / <span class="number">2</span>) * n / <span class="number">2</span> + <span class="built_in">pow</span>(<span class="number">3</span>, n / <span class="number">2</span> + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">        ans[n] /= <span class="number">2</span> * n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="递推与生成函数">递推与生成函数</span></h1><h2><span id="k阶常系数线性齐次递推关系">k阶常系数线性齐次递推关系</span></h2><p>$ h_n-a_ih_{n-1}-a_2h_{n-2}-…-a_kh_{n-k} = 0 $ … …(1)<br>求解形如$ q^n $的解，得q是下面方程的根（需要同时约去$ q^{n-k} $）<br>$ x^b-a_1x^{k-1}-a_2x^{k-2}-…-a_{k-1}x-a_k = 0 $ … …(2)<br>称(2)为(1)的特征方程（耳熟）<br>称(2)的k个根为(1)的特征根</p><p>若$ p\not=q $是(1)的特征根，则$ c_1p^n+c_2q^n $是(1)的解<br>若$q$是(2)的重根，则$ nq^n $是(1)的解</p><p>求解$ c_1, c_2 $时可以有已知的几项列方程组求解<br>可以证明一定只要有k个不一样的根，方程(1)一定有解。(使用范德蒙矩阵)。</p><p>也就是说，最后一定会有k个特征根（可以相同），通项里就一定有k项（可以合并），分别为每个特征根的n次方。<br>（这是我提炼出来的，意思差不多~）</p><p>举例：对于递推关系$ h_n - 5h_{n-1} + 6h_{n-2}，h_1 = 4, h_2 = 5 $，求通项。<br>解：通项一定形如$ h_n = c_1\cdot 2^n + c_2\cdot 3^n $<br>列方程求出$ c_1, c_2 $，做完了。</p><p>一般情况（跟我想的一样）：<br>对于线性常系数齐次递推关系<br>$ h_n + a_1h_{n-1} + a_2h_{n-2} + … + a_kh_{n-k} = 0$<br>它的k个特征根为$ q_1, q_2, …, q_k $，它们的重数为$ r_1, r_2, …, r_k $，且<br>$ r_1 + r_2 + .. + r_k = k $<br>那么，通项为<br>$ h_n = c_1r_1q_1^n + c_2r_2q_2^n + … + c_kr_kq_k^n $<br>$ c_1, c_2, …, c_k $为常数，可以由已知的前几项解出来。<br>完美。</p><p>叠加原理：<br>设$ x_1, x_2, …, x_k $满足递推关系<br>$ h_n + a_1h_{n-1} + … + a_kh_{n-k} = f(n) $<br>$ y_1, y_2, …, y_k $满足递推关系<br>$ h_n + a_1h_{n-1} + … + a_kh_{n-k} = g(n) $<br>则$ x_1+y_1, x_2+y_2, …, x_k+y_k $满足递推关系<br>$ h_n + a_1h_{n-1} + … + a_kh_{n-k} = f(n) + g(n) $<br>一个重要的应用，有他可知<br>(1)的<strong>通解</strong> + (2)的<strong>特解</strong> = (2)的<strong>通解</strong><br>这样可以求带有常数项的通项公式了，<br>例如$h_n = 2h_{n-1} + 1$ （汉诺塔步数）<br>$ h_n - 2h_{n-1} = 0 $ … …(1)<br>$ h_n - 2h_{n-1} = 1 $ … …(2)<br>(1)的通解可以轻松求出为$ h_n = 2^n $<br>(2)有特解-1<br>因此(2)通解为$ h_n = 2^n - 1 $</p><p>特解求法<br>定理:（未完）<br>待定系数法吧</p><p>转移矩阵与递推关系有相同的特征多项式<br>（转移矩阵就是矩阵优化里那个搭配快速幂的东西）</p><h2><span id="生成函数">生成函数</span></h2><p>数列$ h_1, h_2, h_3, … $对应的生成函数定义为<br>$ g(x) = h_0 + h_1x + h_2x^2 + h_3x^3 … $<br>有限数列$ h_n $可补零变成无限</p><p>例：无限序列$ h_n = 1 $的生成函数是<br>$ g(x) = 1 + x + x^2 + x^3 + … $<br>在$ |x|&lt;1 $时，上式为$ g(x) = \frac{1}{1-x} $</p><p>$$ \frac{1}{1-x} = 1 + x + x^2 + x^3 + … \<br> \frac{1}{(1-x)^2} = 1 + 2x + 3x^2 + … \<br>\frac{1}{(1-x)^k} = \sum_{n=0}^{+\infty}C_{k+n-1}^{k-1}x^n \<br>e^x = 1 + \frac{x}{1!} + \frac{x^2}{2!} + \frac{x^2}{3!} $$</p><p>多重集组合可以使用生成函数</p><p>例：2个1袋的苹果无限，5个1提的香蕉无限，4个散橘子，1个梨子，求从中组合出n个水果的方案数<br>解：$ h_n = (\sum_{a=0}^{+\infty}x^{2a})\cdot (\sum_{b=0}^{+\infty}x^{5b})\cdot (\sum_{c=0}^4x^c)\cdot (\sum_{d=0}^1x^c)  \ = (1 + x^2 + x^4 + …)(1 + x^5 + x^{10} + …)(1 + x + x^2 + x^3 + x^4)(1 + x) \ = \frac{1}{1-x^2}\cdot \frac{1}{1-x^5}\cdot (1+x+x^2+x^3+x^4)(1+x) \ = \frac{1}{(1-x)(1+x)}\cdot\frac{1}{(1+x+x^2+x^3+x^4)(1-x)}\cdot(1+x+x^2+x^3+x^4)\cdot(1+x)\ = \frac{1}{(1-x)^2} $<br>的n次项系数<br>答案为$ n + 1 $</p><p>泰勒展开公式<br>$ f(x) = f(0) + \frac{f’(0)}{1!}x + \frac{f’’(0)}{2!}x^2 + \frac{f’’’(0)}{3!}x^3 + … $<br>哇喔</p><p>求卷积：<br>求卷积利用生成函数具有天然的优势<br>原数列生成函数的平方做多项式乘法，$x^n$前的系数，就是n的卷积</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 组合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1001 狼抓兔子</title>
      <link href="/2019/01/22/BZOJ1001-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90/"/>
      <url>/2019/01/22/BZOJ1001-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1001" target="_blank" rel="noopener">BZOJ1001</a></p></blockquote><h1><span id="solution">Solution</span></h1><h2><span id="解法一网络流">解法一：网络流</span></h2><p>很容易想到题目让求的就是最小割，利用最小割最大流定理，就是一道求最大流的裸题。<br>说几点Dinic的注意点：</p><ul><li>tot初始化为1</li><li>当发现一条路无法增光时，将d数组设为0，表示该点不可能继续增广，可以大大提速</li><li>路径是双向边，再加上反向边，总共是4条边</li><li>模板尽可能背的准一点吧，我<del>默写</del>的时候出来很多小问题</li></ul><h2><span id="解法二耦合图">解法二：耦合图</span></h2><p>这个解法就巧妙多了。<br><a id="more"></a></p><h1><span id="code">Code</span></h1><h2><span id="解法一">解法一</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, head[N*N], ver[N*N*<span class="number">12</span>], Next[N*N*<span class="number">12</span>], edge[N*N*<span class="number">12</span>], tot = <span class="number">1</span>, d[N*N], maxflow, f, s, t;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">    ver[++tot] = x, edge[tot] = z, Next[tot] = head[y], head[y] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    d[s] = <span class="number">1</span>; q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(edge[i] &amp;&amp; !d[ver[i]]) &#123;</span><br><span class="line">            d[ver[i]] = d[x] + <span class="number">1</span>;</span><br><span class="line">            q.push(ver[i]);</span><br><span class="line">            <span class="keyword">if</span>(ver[i] == t) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> k, rest = flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i &amp;&amp; rest; i = Next[i]) </span><br><span class="line">        <span class="keyword">if</span>(edge[i] &amp;&amp; d[ver[i]] == d[x] + <span class="number">1</span>) &#123;</span><br><span class="line">            k = dinic(ver[i], min(rest, edge[i]));</span><br><span class="line">            <span class="keyword">if</span>(!k) d[ver[i]] = <span class="number">0</span>;</span><br><span class="line">            rest -= k;</span><br><span class="line">            edge[i] -= k;</span><br><span class="line">            edge[i ^ <span class="number">1</span>] += k;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); </span><br><span class="line">    <span class="keyword">int</span> z; s = <span class="number">1</span>, t = n * m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;z), add(i*m+j, i*m+j+<span class="number">1</span>, z), add(i*m+j+<span class="number">1</span>, i*m+j, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;z), add(i*m+j, i*m+m+j, z), add(i*m+m+j, i*m+j, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;z), add(i*m+j, i*m+m+j+<span class="number">1</span>, z), add(i*m+m+j+<span class="number">1</span>, i*m+j, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(bfs()) <span class="keyword">while</span>(f = dinic(s, inf)) maxflow += f;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxflow &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 网络流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 对偶图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ2434 阿狸的打字机</title>
      <link href="/2019/01/22/BZOJ2434-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA/"/>
      <url>/2019/01/22/BZOJ2434-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2434" target="_blank" rel="noopener">BZOJ2434</a></p></blockquote><h1><span id="solution">Solution</span></h1><h2><span id="40分做法">40分做法</span></h2><p>第一想法，AC自动机，记录每个字符串以及它们在Trie上的哪个节点结束，直接匹配（好暴力啊）。<br>事实上，这种做法，仅仅是记录所有的字符串都会超时超内存，都轮不到匹配的事。但可以作为一个模板题写写嘛。</p><h3><span id="100分做法">100分做法</span></h3><p>这道题作为一道NOI题，非常巧妙地运用了AC自动机的一系列扩展性质。<br>我们考虑构建自动机之后做了什么，无非是在fail数组上跳来跳去来寻找匹配。而每一个节点有唯一的fail节点，这让我们联想到一棵新的树，“fail树”，它以fail数组为边。<br>于是，惊喜地发现，要想出现字符串x，就要出现在x的尾节点在“fail树”上的子树中。<br>要发现，<strong>若字符串x在字符串y中出现，则y所在Trie的节点会出现在x对应在“fail树”上的子树中，出现的次数即为匹配数</strong><br>因此，题目就转化为，搞出AC自动机，搞出“fail树”，求出x的子树，求出y在Trie上的链，回答他们有多少公共节点。<br>但如果对于每个询问都这样求一边，依旧是40分，因此我们考虑一起计算。这里在代码实现上比较巧妙。子树可以用dfs序变成区间问题，而对于链，我们可以只用一遍dfs，进入一个节点时把他+1，出来时-1，<br><a id="more"></a></p><h1><span id="code">Code</span></h1><h2><span id="40分代码">40分代码</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n, m, ch[N][<span class="number">30</span>], pos[N], nxt[N], tot = <span class="number">1</span>, s[N], tail;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dic[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tail; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ch[cur][s[i]]) ch[cur][s[i]] = ++tot;</span><br><span class="line">        cur = ch[cur][s[i]]; </span><br><span class="line">    &#125; pos[++n] = cur;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tail; i++) dic[n].push_back(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) ch[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(<span class="number">1</span>); nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ch[x][i]) ch[x][i] = ch[nxt[x]][i];</span><br><span class="line">            <span class="keyword">else</span> q.push(ch[x][i]), nxt[ch[x][i]] = ch[nxt[x]][i];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> pa, <span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dic[pa].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = dic[pa][i], k = ch[cur][c];</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res += pos[son] == k;</span><br><span class="line">            k = nxt[k];</span><br><span class="line">        &#125;</span><br><span class="line">        cur = ch[cur][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str); <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'P'</span>) insert();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'B'</span> &amp;&amp; tail) tail--;</span><br><span class="line">        <span class="keyword">else</span> s[++tail] = str[i] - <span class="string">'a'</span> + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, find(y, x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="100分代码">100分代码</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> n, m, ch[N][<span class="number">30</span>], fa[N], nxt[N], tot = <span class="number">1</span>, ans[N], ch1[N][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> pos[N], bel[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dic[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ver[N+N], Next[N+N], edgetot;</span><br><span class="line"><span class="keyword">int</span> fir[N], sec[N], nod[N+N], pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++edgetot] = y, Next[edgetot] = head[x], head[x] = edgetot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span> <span class="keyword">int</span> i, x, y; &#125;q[N];</span><br><span class="line"><span class="keyword">int</span> ql[N], qr[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Q a, Q b)</span> </span>&#123; <span class="keyword">return</span> a.y &lt; b.y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N+N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pplus</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; p &lt;= pool; p += p&amp;-p) c[p] += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p -= p&amp;-p) res += c[p];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) ch[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(<span class="number">1</span>); nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ch[x][i]) ch[x][i] = ch[nxt[x]][i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                q.push(ch[x][i]);</span><br><span class="line">                nxt[ch[x][i]] = ch[nxt[x]][i];</span><br><span class="line">                add(ch[x][i], ch[nxt[x]][i]);</span><br><span class="line">                add(ch[nxt[x]][i], ch[x][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdfn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fir[x] = ++pool;</span><br><span class="line">    nod[pool] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != f) getdfn(ver[i], x);</span><br><span class="line">    sec[x] = ++pool;</span><br><span class="line">    nod[pool] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    pplus(fir[x], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(bel[x] &amp;&amp; ql[bel[x]]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ql[bel[x]]; i &lt;= qr[bel[x]]; i++)</span><br><span class="line">            ans[q[i].i] = query(sec[pos[q[i].x]]) - query(fir[pos[q[i].x]] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) <span class="keyword">if</span>(ch1[x][i]) dfs(ch1[x][i]);</span><br><span class="line">    pplus(fir[x], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str); <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, u = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'P'</span>) bel[u] = ++n, pos[n] = u;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'B'</span>) u = fa[u];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> c = str[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ch[u][c]) u = ch[u][c];</span><br><span class="line">            <span class="keyword">else</span> ch[u][c] = ++tot, fa[ch[u][c]] = u, u = tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(ch1, ch, <span class="keyword">sizeof</span>(ch));</span><br><span class="line">    bfs(); getdfn(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].x, &amp;q[i].y), q[i].i = i;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, pos = <span class="number">1</span>; i &lt;= m; i = pos) &#123;</span><br><span class="line">        ql[q[i].y] = i;</span><br><span class="line">        <span class="keyword">while</span>(q[i].y == q[pos].y) pos++;</span><br><span class="line">        qr[q[i].y] = pos - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
          <category> AC自动机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1926 粟粟的书架</title>
      <link href="/2019/01/22/BZOJ1926-%E7%B2%9F%E7%B2%9F%E7%9A%84%E4%B9%A6%E6%9E%B6/"/>
      <url>/2019/01/22/BZOJ1926-%E7%B2%9F%E7%B2%9F%E7%9A%84%E4%B9%A6%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1926" target="_blank" rel="noopener">BZOJ1926</a></p></blockquote><h1><span id="solution">Solution</span></h1><h2><span id="前50的数据">前50%的数据</span></h2><p>注意到P不大于1000，因此可以预处理出与P有关的数组。<br>val[i][j][k]表示(i, j)左上方的子矩阵中大于等于k的数的总和<br>num[i][j][k]表示(i, j)左上方的子矩阵中大于等于k的数的个数<br>然后就可以<code>二分答案</code>了，二分k，求矩阵前缀和，判定一下OK。</p><h2><span id="后50的数据">后50%的数据</span></h2><p>沿用前面的二分思路，但预处理时间和空间都会爆。<del>这里可以用比较暴力的方法乱搞，但我们要追求高效嘛。</del> 因此想到前缀和就要想到主席树，可以大大节省时间空间。<br>具体来说，对每个前缀维护一个线段树，节点(l, r)维护两个信息：<br>P处于l、r之间的数的总和…(1)<br>P处于l、r之间的数的个数…(2)<br>(就和上面的前缀和意义一样)。<br>对这个线段树可持久化，得到一棵<code>主席树</code>。查询时，在要求的区间的线段树上用(1)判断左走还是右走，用(2)计算答案。</p><h2><span id="注意点">注意点：</span></h2><ul><li><strong>一个区间可能有很多相同的数，只要取其中的一部分</strong>，计算得到要取多少，具体看代码。</li><li>前缀和左端点-1</li><li>递归到头后控制返回</li><li>为了防止混淆，我在代码中把两种解法放在不同的命名空间里。<a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r, c, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> easy &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line">    <span class="keyword">int</span> p[N][N], num[N][N][P], x1, x2, y1, y2;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val[N][N][P], h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val[x2][y2][k] - val[x1<span class="number">-1</span>][y2][k] - val[x2][y1<span class="number">-1</span>][k] + val[x1<span class="number">-1</span>][y1<span class="number">-1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i][j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1000</span>; k++) &#123;</span><br><span class="line">                    val[i][j][k] = val[i<span class="number">-1</span>][j][k] + val[i][j<span class="number">-1</span>][k] - val[i<span class="number">-1</span>][j<span class="number">-1</span>][k];</span><br><span class="line">                    num[i][j][k] = num[i<span class="number">-1</span>][j][k] + num[i][j<span class="number">-1</span>][k] - num[i<span class="number">-1</span>][j<span class="number">-1</span>][k];</span><br><span class="line">                    <span class="keyword">if</span>(k &lt;= p[i][j]) val[i][j][k] += p[i][j], num[i][j][k]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%lld"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;h);</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(calc(mid) &gt;= h) l = mid; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Poor QLW\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num[x2][y2][l+<span class="number">1</span>] - num[x1<span class="number">-1</span>][y2][l+<span class="number">1</span>] - num[x2][y1<span class="number">-1</span>][l+<span class="number">1</span>] + num[x1<span class="number">-1</span>][y1<span class="number">-1</span>][l+<span class="number">1</span>] </span><br><span class="line">                    + (h - calc(l+<span class="number">1</span>) + l - <span class="number">1</span>) / l);</span><br><span class="line">                    <span class="comment">//此处要考虑重复的部分到底选几个，肯定是达到要求的前提下选的越少越好</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hard &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line">    <span class="keyword">int</span> lc[N*<span class="number">32</span>], rc[N*<span class="number">32</span>], num[N*<span class="number">32</span>], p[N], rt[N], tot;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val[N*<span class="number">32</span>], h;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = ++tot;</span><br><span class="line">        lc[p] = lc[pre], rc[p] = rc[pre], val[p] = val[pre] + x, num[p] = num[pre] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) lc[p] = build(lc[pre], l, mid, x);</span><br><span class="line">        <span class="keyword">else</span> rc[p] = build(rc[pre], mid + <span class="number">1</span>, r, x);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> lp, <span class="keyword">int</span> rp, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> (x + l - <span class="number">1</span>) / l;</span><br><span class="line">            <span class="comment">//这里跟上面一样，要考虑相同的部分。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, y = val[rc[rp]] - val[rc[lp]];</span><br><span class="line">        <span class="keyword">if</span>(y &gt;= x) <span class="keyword">return</span> query(rc[lp], rc[rp], mid + <span class="number">1</span>, r, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(lc[lp], lc[rp], l, mid, x - y) + num[rc[rp]] - num[rc[lp]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]), rt[i] = build(rt[i<span class="number">-1</span>], <span class="number">1</span>, <span class="number">1000</span>, p[i]);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, t1, t2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%lld"</span>, &amp;t1, &amp;l, &amp;t2, &amp;r, &amp;h);</span><br><span class="line">            <span class="keyword">int</span> ans = query(rt[l<span class="number">-1</span>], rt[r], <span class="number">1</span>, <span class="number">1000</span>, h);</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; r - l + <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Poor QLW\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;r, &amp;c, &amp;m);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">1</span>) hard::work();</span><br><span class="line">    <span class="keyword">else</span> easy::work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 可持久化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案 </tag>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ1070 修车</title>
      <link href="/2019/01/17/BZOJ1070-%E4%BF%AE%E8%BD%A6/"/>
      <url>/2019/01/17/BZOJ1070-%E4%BF%AE%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1070" target="_blank" rel="noopener">BZOJ1070</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>对于像这样的对应匹配的问题，一般可以使用网络流求解，即构建二分图，大部分时候求最大匹配（当然也不仅是匹配）。本题中一次维修要消耗一定的时间，因此需要使用最小费用最大流。</p><p>最原始的思路是，左部工人，右部客户的二部图，但本题的特殊之处在于排在后面的人会有更长的等待时间。我们仍需保持这是一个二分图，因此需要对点或边进行一些调整。</p><p>首先，要使用一个重要的思想，考虑每辆车对总等待时间的贡献，即<strong>不计算每个顾客等多久，而计算他让别人等了多久</strong></p><p>每一个工人一个车一个车的修，每修一辆车会让后面的人多等一会儿。</p><p>此时就可以想到拆点。把每一个工人节点k拆成个N点，等同于正在修他将要修的倒数第i辆车，向另外一部j点连边即代表他这个修的是j号车， 费用为$a[j][k]*i$，乘以i是因为后面的i辆车都要等待这个时间。</p><p>事实上本题的构图体现了一个<strong>阶段化拆点</strong>的思想，一个点拆成它的不同阶段，相互独立。</p><p>至于二部图的网络流构图法就不累述了，这里说几个注意点：</p><ol><li>边编号要从2开始计</li><li>不要忘记建反向边，容量0，费用-w</li><li>清空数组神马的别忘了<a id="more"></a></li></ol><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">1010</span>, E = <span class="number">200010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, tot = <span class="number">1</span>, head[V], ver[E], Next[E], cap[E], cost[E], a[<span class="number">20</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> s, t, pe[V], pv[V], maxflow, mincost, d[V], v[V];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, cap[tot] = c, cost[tot] = w;</span><br><span class="line">    Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">        q.push(s); d[s] = <span class="number">0</span>; v[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">            v[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(cap[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = ver[i];</span><br><span class="line">                <span class="keyword">if</span>(d[y] &gt; d[x] + cost[i]) &#123;</span><br><span class="line">                    d[y] = d[x] + cost[i]; pv[y] = x; pe[y] = i;</span><br><span class="line">                    <span class="keyword">if</span>(!v[y]) v[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d[t] == inf) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> flow = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pv[i]) flow = min(flow, cap[pe[i]]);</span><br><span class="line">        maxflow += flow;</span><br><span class="line">        mincost += flow * d[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pv[i]) cap[pe[i]] -= flow, cap[pe[i] ^ <span class="number">1</span>] += flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    s = n * m + n + <span class="number">1</span>, t = s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[j][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) </span><br><span class="line">                add(i * n + j, m * n + k, <span class="number">1</span>, a[i+<span class="number">1</span>][k] * j), </span><br><span class="line">                add(n * m + k, i * n + j, <span class="number">0</span>, -a[i+<span class="number">1</span>][k] * j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++) add(s, i, <span class="number">1</span>, <span class="number">0</span>), add(i, s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n * m + <span class="number">1</span>; i &lt;= n * m + n; i++) add(i, t, <span class="number">1</span>, <span class="number">0</span>), add(t, i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf"</span>, (<span class="keyword">double</span>)mincost / n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 网络流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ3994 约数个数和</title>
      <link href="/2019/01/13/BZOJ3994-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/"/>
      <url>/2019/01/13/BZOJ3994-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3994" target="_blank" rel="noopener">BZOJ3994</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>首先，要先介绍一个可爱的结论：<br>$$ d(ij) = \sum_{x|i}\sum_{y|j}[gcd(x, y) = 1] $$<br>简单证明一下：<br>当$(i, j)=1$时，结果显然为i的约数个数乘j的约数个数。<br>否则，会有一部分重复，因为i*j的某一个因数可以有不同方式得到。怎样得到另一种方式呢？比如现在有$x|i,\ y|j,\ xy|ij,\ d|x$此时让x除以d，y乘以d，得到新的$xy|ij$，而这样做合法的前提是d同时是i和j的因数，或者说$gcd(x, yd)\ne 1$，当有这样的一对约数时，把结果减1，就可以得到这个式子。</p><p>结合其他几道题目，可以发现反演似乎非常青睐gcd，所有的数论函数都要尽量往最大公约数上面靠，然后再开始套路。</p><p>之后就是一道比较经典的反演题目了，总之就是推式子吧。求$$ \sum_{i=1}^N\sum_{j=1}^M\sum_{x|i}\sum_{y|j}[gcd(x, y) = 1] $$<br>相同的x, y枚举了很多次，因此先枚举x, y，贡献可以直接计算得到，原式即<br>$$\sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[gcd(i, j) = 1]$$<br>我们令$$ f(n) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[gcd(i, j) = n] $$$$ F(d) = \sum_{d|n}f(n) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[d\ |\ gcd(i, j)] $$此处可以开心得去掉gcd，用漂亮的除法代替，枚举i和j分别是d的多少倍，得到$$ F(x) = \sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\lfloor\frac{N}{id}\rfloor\lfloor\frac{M}{jd}\rfloor$$<br>这时就可以使用<code>莫比乌斯反演</code>了，因为可以看到我们已经消去了gcd，也就是说式子里不存在数论函数了，于是<br>$$ f(d) = \sum_{d|n}\mu(\frac{n}{d})F(n) $$得到答案为$$ ans = f(1) = \sum_{d=1}^{min(N, M)}\mu(d)F(d) =<br>\sum_{d=1}^{min(N, M)}\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\mu(d)\lfloor\frac{N}{id}\rfloor\lfloor\frac{M}{jd}\rfloor $$<br>现在讨论代码实现，暴力需要三层循环，因此需要用<code>线性筛</code>预处理，对于每一个x，处理出$s[x] = \sum_{i=1}^x\lfloor\frac{x}{i}\rfloor$，未来查询$s[\frac{N}{d}]$，因此只需要枚举d这一个变量。<br>再利用<code>整除分块</code>，$\lfloor\frac{N}{d}\rfloor$且$\lfloor\frac{M}{d}\rfloor$相同的部分只计算一次，就可以在$O(\sqrt{n})$的时间完成一次询问，总复杂度$O(T\sqrt{n})$</p><p>关于$\mu$的计算最好作为一个模板记下啦。<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">int</span> miu[N], smiu[N], v[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) miu[i] = <span class="number">1</span>, v[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v[i]) <span class="keyword">continue</span>;</span><br><span class="line">        miu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)&#123;</span><br><span class="line">            v[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>((j / i) % i == <span class="number">0</span>) miu[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> miu[j] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) smiu[i] = smiu[i<span class="number">-1</span>] + miu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= i; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = i / (i / l);</span><br><span class="line">            s[i] += <span class="number">1l</span>l * (r - l + <span class="number">1</span>) * (i / l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(<span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; m) swap(n, m);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>)&#123;</span><br><span class="line">            j = min(n / (n / i), m / (m / i));</span><br><span class="line">            ans += <span class="number">1l</span>l * (smiu[j] - smiu[i - <span class="number">1</span>]) * s[n / i] * s[m / i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 莫比乌斯反演 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>施工结束</title>
      <link href="/2019/01/13/%E7%BA%AA%E5%BF%B5%E6%97%A5/"/>
      <url>/2019/01/13/%E7%BA%AA%E5%BF%B5%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1><span id="博客建成日">博客建成日</span></h1><p>2019年1月13日，该博客基本搭建搭建完成。<br><a id="more"></a><br>话说步入OI也有将近一年的时间了，之前从来没有写过博客。曾经搜题解时看到别人的博客常常是一番羡慕，但不知什么原因，或许是太懒了，一直没有为自己搭建一个blog。从昨晚起，忙碌（<del>玩</del>）了几个小时，心里还是非常有成就感的。从今天起，我应该会养成写题解、发博客的习惯，这应当是有深远意义的。<br>这篇博客主要是为了一个纪念，就像古代人建了一座房子还要写一篇序一样，我如今也是有blog的人了，不仅一番激动。<br>但愿未来这个博客会充实起来，像很多大佬一样有几十篇来自各个OJ的题解。<br>博客界面开不是很满意，未来会慢慢润色的。</p>]]></content>
      
      
      <categories>
          
          <category> 纪念日 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
