<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ1001 狼抓兔子]]></title>
    <url>%2F2019%2F01%2F22%2FBZOJ1001-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ1001 Description现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：左上角点为(1,1),右下角点为(N,M)(上图中N=4,M=5).有以下三种类型的道路1:(x,y)&lt;\==&gt;(x+1,y)2:(x,y)&lt;\==&gt;(x,y+1)3:(x,y)&lt;\==&gt;(x+1,y+1)道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的. 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角(1,1)的窝里，现在它们要跑到右下解(N,M)的窝中去，狼王开始伏击这些兔子.当然为了保险起见，如果一条道路上最多通过的兔子数为K，狼王需要安排同样数量的K只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦. Input第一行为N,M.表示网格的大小，N,M均小于等于1000.接下来分三部分第一部分共N行，每行M-1个数，表示横向道路的权值.第二部分共N-1行，每行M个数，表示纵向道路的权值.第三部分共N-1行，每行M-1个数，表示斜向道路的权值.输入文件保证不超过10M Output输出一个整数，表示参与伏击的狼的最小数量. Sample Input3 45 6 44 3 17 5 35 6 7 88 7 6 55 5 56 6 6 Sample Output14 Solution解法一：网络流很容易想到题目让求的就是最小割，利用最小割最大流定理，就是一道求最大流的裸题。说几点Dinic的注意点： tot初始化为1 当发现一条路无法增光时，将d数组设为0，表示该点不可能继续增广，可以大大提速 路径是双向边，再加上反向边，总共是4条边 模板尽可能背的准一点吧，我默写的时候出来很多小问题 解法二：耦合图这个解法就巧妙多了。 Code解法一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010, inf = 0x3f3f3f3f;int n, m, head[N*N], ver[N*N*12], Next[N*N*12], edge[N*N*12], tot = 1, d[N*N], maxflow, f, s, t;queue&lt;int&gt; q;void add(int x, int y, int z) &#123; ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot; ver[++tot] = x, edge[tot] = z, Next[tot] = head[y], head[y] = tot;&#125;bool bfs() &#123; while(q.size()) q.pop(); memset(d, 0, sizeof(d)); d[s] = 1; q.push(s); while(q.size()) &#123; int x = q.front(); q.pop(); for(int i = head[x]; i; i = Next[i]) if(edge[i] &amp;&amp; !d[ver[i]]) &#123; d[ver[i]] = d[x] + 1; q.push(ver[i]); if(ver[i] == t) return true; &#125; &#125; return false;&#125;int dinic(int x, int flow) &#123; if(x == t) return flow; int k, rest = flow; for(int i = head[x]; i &amp;&amp; rest; i = Next[i]) if(edge[i] &amp;&amp; d[ver[i]] == d[x] + 1) &#123; k = dinic(ver[i], min(rest, edge[i])); if(!k) d[ver[i]] = 0; rest -= k; edge[i] -= k; edge[i ^ 1] += k; &#125; return flow - rest;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); int z; s = 1, t = n * m; for(int i = 0; i &lt; n; i++) for(int j = 1; j &lt; m; j++) scanf("%d", &amp;z), add(i*m+j, i*m+j+1, z), add(i*m+j+1, i*m+j, 0); for(int i = 0; i &lt; n - 1; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;z), add(i*m+j, i*m+m+j, z), add(i*m+m+j, i*m+j, 0); for(int i = 0; i &lt; n - 1; i++) for(int j = 1; j &lt; m; j++) scanf("%d", &amp;z), add(i*m+j, i*m+m+j+1, z), add(i*m+m+j+1, i*m+j, 0); while(bfs()) while(f = dinic(s, inf)) maxflow += f; cout &lt;&lt; maxflow &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>网络流-最大流</tag>
        <tag>耦合图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2434 阿狸的打字机]]></title>
    <url>%2F2019%2F01%2F22%2FBZOJ2434-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ2434 Description 阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有28个按键，分别印有26个小写英文字母和’B’、’P’两个字母。经阿狸研究发现，这个打字机是这样工作的：输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。按一下印有’B’的按键，打字机凹槽中最后一个字母会消失。按一下印有’P’的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。例如，阿狸输入aPaPBbP，纸上被打印的字符如下：aaaab我们把纸上打印出来的字符串从1开始顺序编号，一直到n。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数(x,y)（其中1≤x,y≤n），打字机会显示第x个打印的字符串在第y个打印的字符串中出现了多少次。阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？ Input输入的第一行包含一个字符串，按阿狸的输入顺序给出所有阿狸输入的字符。第二行包含一个整数m，表示询问个数。接下来m行描述所有由小键盘输入的询问。其中第i行包含两个整数x, y，表示第i个询问为(x, y)。 Output 输出m行，其中第i行包含一个整数，表示第i个询问的答案。 Sample InputaPaPBbP31 21 32 3 Sample Output210 HINT对于100%的数据，n&lt;=100000,m&lt;=100000,第一行总长度&lt;=100000。 Solution40分做法第一想法，AC自动机，记录每个字符串以及它们在Trie上的哪个节点结束，直接匹配（好暴力啊）。事实上，这种做法，仅仅是记录所有的字符串都会超时超内存，都轮不到匹配的事。但可以作为一个模板题写写嘛。 Code40分代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;char str[N];int n, m, ch[N][30], pos[N], nxt[N], tot = 1, s[N], tail;vector&lt;int&gt; dic[N];void insert() &#123; int cur = 1; for(int i = 1; i &lt;= tail; i++) &#123; if(!ch[cur][s[i]]) ch[cur][s[i]] = ++tot; cur = ch[cur][s[i]]; &#125; pos[++n] = cur; for(int i = 1; i &lt;= tail; i++) dic[n].push_back(s[i]);&#125;void bfs() &#123; for(int i = 1; i &lt;= 26; i++) ch[0][i] = 1; queue&lt;int&gt; q; q.push(1); nxt[1] = 0; while(q.size()) &#123; int x = q.front(); q.pop(); for(int i = 1; i &lt;= 26; i++) &#123; if(!ch[x][i]) ch[x][i] = ch[nxt[x]][i]; else q.push(ch[x][i]), nxt[ch[x][i]] = ch[nxt[x]][i]; &#125; &#125;&#125;int find(int pa, int son) &#123; int cur = 1, res = 0; for(int i = 0; i &lt; dic[pa].size(); i++) &#123; int c = dic[pa][i], k = ch[cur][c]; while(k &gt; 1) &#123; res += pos[son] == k; k = nxt[k]; &#125; cur = ch[cur][c]; &#125; return res;&#125;int main()&#123; scanf("%s", str); int len = strlen(str); for(int i = 0; i &lt; len; i++) &#123; if(str[i] == 'P') insert(); else if(str[i] == 'B' &amp;&amp; tail) tail--; else s[++tail] = str[i] - 'a' + 1; &#125; bfs(); scanf("%d", &amp;m); while(m--)&#123; int x, y; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", find(y, x)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1926 粟粟的书架]]></title>
    <url>%2F2019%2F01%2F22%2FBZOJ1926-%E7%B2%9F%E7%B2%9F%E7%9A%84%E4%B9%A6%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ1926 Description幸福幼儿园B29班的粟粟是一个聪明机灵、乖巧可爱的小朋友，她的爱好是画画和读书，尤其喜欢Thomas H. Cormen的文章。粟粟家中有一个R行C列的巨型书架，书架的每一个位置都摆有一本书，上数第i行、左数第j列摆放的书有Pi,j页厚。 粟粟每天除了读书之外，还有一件必不可少的工作就是摘苹果，她每天必须摘取一个指定的苹果。粟粟家果树上的苹果有的高、有的低，但无论如何凭粟粟自己的个头都难以摘到。不过她发现，如果在脚下放上几本书，就可以够着苹果；她同时注意到，对于第i天指定的那个苹果，只要她脚下放置书的总页数之和不低于Hi，就一定能够摘到。 由于书架内的书过多，父母担心粟粟一天内就把所有书看完而耽误了上幼儿园，于是每天只允许粟粟在一个特定区域内拿书。这个区域是一个矩形，第i天给定区域的左上角是上数第x1i行的左数第y1i本书，右下角是上数第x2i行的左数第y2i本书。换句话说，粟粟在这一天，只能在这﹙x2i－x1i＋1﹚×﹙y2i－y1i＋1﹚本书中挑选若干本垫在脚下，摘取苹果。 粟粟每次取书时都能及时放回原位，并且她的书架不会再撤下书目或换上新书，摘苹果的任务会一直持续M天。给出每本书籍的页数和每天的区域限制及采摘要求，请你告诉粟粟，她每天至少拿取多少本书，就可以摘到当天指定的苹果。 Input第一行是三个正整数R，C，M。接下来是一个R行C列的矩阵，从上到下、从左向右依次给出了每本书的页数Pi，j。接下来M行，第i行给出正整数x1i，y1i，x2i，y2i，Hi，表示第i天的指定区域是﹙x1i，y1i﹚与﹙x2i，y2i﹚间的矩形，总页数之和要求不低于Hi。保证1≤x1i≤x2i≤R，1≤y1i≤y2i≤C。 Output有M行，第i 行回答粟粟在第 i 天时为摘到苹果至少需要 拿取多少本书。如果即使取走所有书都无法摘到苹果，则在该行输出“Poor QLW” （不含引号）。 Sample Input5 5 714 15 9 26 5358 9 7 9 3238 46 26 43 3832 7 9 50 288 41 9 7 171 2 5 3 1393 1 5 5 3993 3 4 5 914 1 4 1 331 3 5 4 1853 3 4 3 233 1 3 3 108 Sample Output6152Poor QLW913 HINT对于 10%的数据，满足 R, C≤10；对于 20%的数据，满足 R, C≤40；对于 50%的数据，满足 R, C≤200，M≤200,000；另有 50%的数据，满足 R＝1，C≤500,000，M≤20,000；对于 100%的数据，满足 1≤Pi,j≤1,000，1≤Hi≤2,000,000,000 Solution前50%的数据注意到P不大于1000，因此可以预处理出与P有关的数组。val[i][j][k]表示(i, j)左上方的子矩阵中大于等于k的数的总和num[i][j][k]表示(i, j)左上方的子矩阵中大于等于k的数的个数然后就可以二分答案了，二分k，求矩阵前缀和，判定一下OK。 后50%的数据沿用前面的二分思路，但预处理时间和空间都会爆。这里可以用比较暴力的方法乱搞，但我们要追求高效嘛。 因此想到前缀和就要想到主席树，可以大大节省时间空间。具体来说，对每个前缀维护一个线段树，节点(l, r)维护两个信息：P处于l、r之间的数的总和…(1)P处于l、r之间的数的个数…(2)(就和上面的前缀和意义一样)。对这个线段树可持久化，得到一棵主席树。查询时，在要求的区间的线段树上用(1)判断左走还是右走，用(2)计算答案。 注意点： 一个区间可能有很多相同的数，只要取其中的一部分，计算得到要取多少，具体看代码。 前缀和左端点-1 递归到头后控制返回 为了防止混淆，我在代码中把两种解法放在不同的命名空间里。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int P = 1010;int r, c, m;namespace easy &#123; const int N = 210; int p[N][N], num[N][N][P], x1, x2, y1, y2; long long val[N][N][P], h; long long calc(int k)&#123; return val[x2][y2][k] - val[x1-1][y2][k] - val[x2][y1-1][k] + val[x1-1][y1-1][k]; &#125; void work() &#123; for(int i = 1; i &lt;= r; i++) for(int j = 1; j &lt;= c; j++) &#123; scanf("%d", &amp;p[i][j]); for(int k = 0; k &lt;= 1000; k++) &#123; val[i][j][k] = val[i-1][j][k] + val[i][j-1][k] - val[i-1][j-1][k]; num[i][j][k] = num[i-1][j][k] + num[i][j-1][k] - num[i-1][j-1][k]; if(k &lt;= p[i][j]) val[i][j][k] += p[i][j], num[i][j][k]++; &#125; &#125; while(m--)&#123; scanf("%d%d%d%d%lld", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;h); int l = 0, r = 1000; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(calc(mid) &gt;= h) l = mid; else r = mid - 1; &#125; if(l == 0) printf("Poor QLW\n"); else printf("%d\n", num[x2][y2][l+1] - num[x1-1][y2][l+1] - num[x2][y1-1][l+1] + num[x1-1][y1-1][l+1] + (h - calc(l+1) + l - 1) / l); //此处要考虑重复的部分到底选几个，肯定是达到要求的前提下选的越少越好 &#125; &#125;&#125;namespace hard &#123; const int N = 500010; int lc[N*32], rc[N*32], num[N*32], p[N], rt[N], tot; long long val[N*32], h; int build(int pre, int l, int r, int x) &#123; int p = ++tot; lc[p] = lc[pre], rc[p] = rc[pre], val[p] = val[pre] + x, num[p] = num[pre] + 1; if(l == r) return p; int mid = (l + r) &gt;&gt; 1; if(x &lt;= mid) lc[p] = build(lc[pre], l, mid, x); else rc[p] = build(rc[pre], mid + 1, r, x); return p; &#125; int query(int lp, int rp, int l, int r, int x) &#123; if(l == r) &#123; return (x + l - 1) / l; //这里跟上面一样，要考虑相同的部分。 &#125; int mid = (l + r) &gt;&gt; 1, y = val[rc[rp]] - val[rc[lp]]; if(y &gt;= x) return query(rc[lp], rc[rp], mid + 1, r, x); else return query(lc[lp], lc[rp], l, mid, x - y) + num[rc[rp]] - num[rc[lp]]; &#125; void work() &#123; for(int i = 1; i &lt;= c; i++) scanf("%d", &amp;p[i]), rt[i] = build(rt[i-1], 1, 1000, p[i]); while(m--)&#123; int l, r, t1, t2; scanf("%d%d%d%d%lld", &amp;t1, &amp;l, &amp;t2, &amp;r, &amp;h); int ans = query(rt[l-1], rt[r], 1, 1000, h); if(ans &gt; r - l + 1) printf("Poor QLW\n"); else printf("%d\n", ans); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;r, &amp;c, &amp;m); if(r == 1) hard::work(); else easy::work(); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1070 修车]]></title>
    <url>%2F2019%2F01%2F17%2FBZOJ1070-%E4%BF%AE%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[题目链接BZOJ1070 Description 同一时刻有N位车主带着他们的爱车来到了汽车维修中心。维修中心共有M位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这M位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。 说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。 Input 第一行有两个m,n，表示技术人员数与顾客数。 接下来n行，每行m个整数。第i+1行第j个数表示第j位技术人员维修第i辆车需要用的时间T。 Output 最小平均等待时间，答案精确到小数点后2位。 Sample Input2 23 21 4 Sample Output1.50 HINT数据范围: (2&lt;=M&lt;=9,1&lt;=N&lt;=60), (1&lt;=T&lt;=1000) Solution对于像这样的对应匹配的问题，一般可以使用网络流求解，即构建二分图，大部分时候求最大匹配（当然也不仅是匹配）。本题中一次维修要消耗一定的时间，因此需要使用最小费用最大流。 最原始的思路是，左部工人，右部客户的二部图，但本题的特殊之处在于排在后面的人会有更长的等待时间。我们仍需保持这是一个二分图，因此需要对点或边进行一些调整。 首先，要使用一个重要的思想，考虑每辆车对总等待时间的贡献，即不计算每个顾客等多久，而计算他让别人等了多久 每一个工人一个车一个车的修，每修一辆车会让后面的人多等一会儿。 此时就可以想到拆点。把每一个工人节点k拆成个N点，等同于正在修他将要修的倒数第i辆车，向另外一部j点连边即代表他这个修的是j号车， 费用为$a[j][k]*i$，乘以i是因为后面的i辆车都要等待这个时间。 事实上本题的构图体现了一个阶段化拆点的思想，一个点拆成它的不同阶段，相互独立。 至于二部图的网络流构图法就不累述了，这里说几个注意点： 边编号要从2开始计 不要忘记建反向边，容量0，费用-w 清空数组神马的别忘了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int V = 1010, E = 200010, inf = 0x3f3f3f3f;int n, m, tot = 1, head[V], ver[E], Next[E], cap[E], cost[E], a[20][100];int s, t, pe[V], pv[V], maxflow, mincost, d[V], v[V];void add(int x, int y, int c, int w)&#123; ver[++tot] = y, cap[tot] = c, cost[tot] = w; Next[tot] = head[x], head[x] = tot;&#125;void solve() &#123; queue&lt;int&gt; q; while(1) &#123; memset(v, 0, sizeof(v)); memset(d, 0x3f, sizeof(d)); while(q.size()) q.pop(); q.push(s); d[s] = 0; v[s] = 1; while(q.size()) &#123; int x = q.front(); q.pop(); v[x] = 0; for(int i = head[x]; i; i = Next[i]) if(cap[i]) &#123; int y = ver[i]; if(d[y] &gt; d[x] + cost[i]) &#123; d[y] = d[x] + cost[i]; pv[y] = x; pe[y] = i; if(!v[y]) v[y] = 1, q.push(y); &#125; &#125; &#125; if(d[t] == inf) break; int flow = inf; for(int i = t; i != s; i = pv[i]) flow = min(flow, cap[pe[i]]); maxflow += flow; mincost += flow * d[t]; for(int i = t; i != s; i = pv[i]) cap[pe[i]] -= flow, cap[pe[i] ^ 1] += flow; &#125;&#125;int main() &#123; scanf("%d%d", &amp;m, &amp;n); s = n * m + n + 1, t = s + 1; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf("%d", &amp;a[j][i]); for(int i = 0; i &lt; m; i++) for(int j = 1; j &lt;= n; j++) for(int k = 1; k &lt;= n; k++) add(i * n + j, m * n + k, 1, a[i+1][k] * j), add(n * m + k, i * n + j, 0, -a[i+1][k] * j); for(int i = 1; i &lt;= n * m; i++) add(s, i, 1, 0), add(i, s, 0, 0); for(int i = n * m + 1; i &lt;= n * m + n; i++) add(i, t, 1, 0), add(t, i, 0, 0); solve(); printf("%.2lf", (double)mincost / n); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>网络流-费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3994 约数个数和]]></title>
    <url>%2F2019%2F01%2F13%2FBZOJ3994-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目链接： BZOJ3994 Description 设d(x)为x的约数个数，给定N、M，求$\sum_{i=1}^N\sum_{j=1}^Md(ij)$ Input输入文件包含多组测试数据。 第一行，一个整数T，表示测试数据的组数。接下来的T行，每行两个整数N、M。 Output T行，每行一个整数，表示你所求的答案。 Sample Input27 45 6 Sample Output110121 HINT1&lt;=N, M&lt;=500001&lt;=T&lt;=50000 Solution首先，要先介绍一个可爱的结论：$$ d(ij) = \sum_{x|i}\sum_{y|j}[gcd(x, y) = 1] $$简单证明一下：当$(i, j)=1$时，结果显然为i的约数个数乘j的约数个数。否则，会有一部分重复，因为i*j的某一个因数可以有不同方式得到。怎样得到另一种方式呢？比如现在有$x|i,\ y|j,\ xy|ij,\ d|x$此时让x除以d，y乘以d，得到新的$xy|ij$，而这样做合法的前提是d同时是i和j的因数，或者说$gcd(x, yd)\ne 1$，当有这样的一对约数时，把结果减1，就可以得到这个式子。 结合其他几道题目，可以发现反演似乎非常青睐gcd，所有的数论函数都要尽量往最大公约数上面靠，然后再开始套路。 之后就是一道比较经典的反演题目了，总之就是推式子吧。求$$ \sum_{i=1}^N\sum_{j=1}^M\sum_{x|i}\sum_{y|j}[gcd(x, y) = 1] $$相同的x, y枚举了很多次，因此先枚举x, y，贡献可以直接计算得到，原式即$$\sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[gcd(i, j) = 1]$$我们令$$ f(n) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[gcd(i, j) = n] $$$$ F(d) = \sum_{d|n}f(n) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[d\ |\ gcd(i, j)] $$此处可以开心得去掉gcd，用漂亮的除法代替，枚举i和j分别是d的多少倍，得到$$ F(x) = \sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\lfloor\frac{N}{id}\rfloor\lfloor\frac{M}{jd}\rfloor$$这时就可以使用莫比乌斯反演了，因为可以看到我们已经消去了gcd，也就是说式子里不存在数论函数了，于是$$ f(d) = \sum_{d|n}\mu(\frac{n}{d})F(n) $$得到答案为$$ ans = f(1) = \sum_{d=1}^{min(N, M)}\mu(d)F(d) =\sum_{d=1}^{min(N, M)}\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\mu(d)\lfloor\frac{N}{id}\rfloor\lfloor\frac{M}{jd}\rfloor $$现在讨论代码实现，暴力需要三层循环，因此需要用线性筛预处理，对于每一个x，处理出$s[x] = \sum_{i=1}^x\lfloor\frac{x}{i}\rfloor$，未来查询$s[\frac{N}{d}]$，因此只需要枚举d这一个变量。再利用整除分块，$\lfloor\frac{N}{d}\rfloor$且$\lfloor\frac{M}{d}\rfloor$相同的部分只计算一次，就可以在$O(\sqrt{n})$的时间完成一次询问，总复杂度$O(T\sqrt{n})$ 关于$\mu$的计算最好作为一个模板记下啦。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 50010;int miu[N], smiu[N], v[N];long long s[N];void init(int n)&#123; for(int i = 1; i &lt;= n; i++) miu[i] = 1, v[i] = 0; for(int i = 2; i &lt;= n; i++)&#123; if(v[i]) continue; miu[i] = -1; for(int j = i + i; j &lt;= n; j += i)&#123; v[j] = 1; if((j / i) % i == 0) miu[j] = 0; else miu[j] *= -1; &#125; &#125; for(int i = 1; i &lt;= n; i++) smiu[i] = smiu[i-1] + miu[i]; for(int i = 1; i &lt;= n; i++) &#123; for(int l = 1, r; l &lt;= i; l = r + 1) &#123; r = i / (i / l); s[i] += 1ll * (r - l + 1) * (i / l); &#125; &#125;&#125;int main()&#123; init(50000); int T; scanf("%d", &amp;T); while(T--)&#123; int n, m; scanf("%d%d", &amp;n, &amp;m); if(n &gt; m) swap(n, m); long long ans = 0; for(int i = 1, j; i &lt;= n; i = j + 1)&#123; j = min(n / (n / i), m / (m / i)); ans += 1ll * (smiu[j] - smiu[i - 1]) * s[n / i] * s[m / i]; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[施工结束]]></title>
    <url>%2F2019%2F01%2F13%2F%E7%BA%AA%E5%BF%B5%E6%97%A5%2F</url>
    <content type="text"><![CDATA[博客建成日2019年1月13日，该博客基本搭建搭建完成。话说步入OI也有将近一年的时间了，之前从来没有写过博客。曾经搜题解时看到别人的博客常常是一番羡慕，但不知什么原因，或许是太懒了，一直没有为自己搭建一个blog。从昨晚起，忙碌（玩）了几个小时，心里还是非常有成就感的。从今天起，我应该会养成写题解、发博客的习惯，这应当是有深远意义的。这篇博客主要是为了一个纪念，就像古代人建了一座房子还要写一篇序一样，我如今也是有blog的人了，不仅一番激动。但愿未来这个博客会充实起来，像很多大佬一样有几十篇来自各个OJ的题解。博客界面开不是很满意，未来会慢慢润色的。]]></content>
      <categories>
        <category>纪念日</category>
      </categories>
  </entry>
</search>
