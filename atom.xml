<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ratexxxx</title>
  
  <subtitle>a pimping OIer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ratexxxx.github.io/"/>
  <updated>2019-09-09T12:56:59.652Z</updated>
  <id>http://ratexxxx.github.io/</id>
  
  <author>
    <name>Ratexxxx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ1129 [POI2008]Per</title>
    <link href="http://ratexxxx.github.io/2019/09/09/BZOJ1129-POI2008-Per/"/>
    <id>http://ratexxxx.github.io/2019/09/09/BZOJ1129-POI2008-Per/</id>
    <published>2019-09-09T12:09:08.000Z</published>
    <updated>2019-09-09T12:56:59.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1129" target="_blank" rel="noopener">BZOJ1129</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>如果没有重复元素，直接一位一位计数即可<br>有相同元素仍然是一位一位计数，考虑从后往前，假设当前前i-1个是固定的，数在第i位开始小于给定的序列的方案数<br>设原数列为$a$，可以变动的中，不同的元素分别是$b_1, b_2, b_3, …, b_k$，个数分别为$c_1, c_2, c_3…, c_k$个，则答案为<br>$$<br>\sum_{b_j&lt; a_i}\frac{(n-i)!}{\Pi_{k!=j} b_k\cdot(b_j-1) }<br>$$<br>硬算是$O(n^2)$的，可以用树状数组优化<br>分别维护分母和分子，每次i–时有一个新的元素加进来，某一个b会+1，分母会乘以新的b</p><p>关键是这个模数的问题，他不是质数，要质因数分解，分别求答案，然后用CRT合并<br>逆元需要用扩展欧几里得来算</p><p>还有比较麻烦的，如果乘以或除以的数是当前处理的模数对应的那个质因子的倍数，那么需要把这个数所有该因数除掉，同时记录去掉了几个这个因数<br>最后要把这些去掉的因数再快速幂乘回来<br>这是因为求逆元时要求与模数互质，因此必须先去掉，求完逆元再乘回来</p><p>任意模数的逆元的处理方式要记笔记。。。</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, mod, a[maxn], m, pr[maxn], b[maxn], pb[maxn], cnt, v[maxn], mx;</span><br><span class="line">ll c[maxn], res[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b) &#123; x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="keyword">int</span> d = exgcd(b, a % b, y, x);</span><br><span class="line">y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r, y;</span><br><span class="line">exgcd(x, p, r, y);</span><br><span class="line"><span class="keyword">return</span> (r % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p -= p&amp;-p) res = (res + c[p]) % mod; </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(; p &lt;= mx; p += p&amp;-p) c[p] = (c[p] + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line">ll pwp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mx; i++) c[i] = <span class="number">0</span>, v[i] = <span class="number">0</span>;</span><br><span class="line">ll p1 = <span class="number">0</span>, a1 = <span class="number">1</span>, aa, pp;</span><br><span class="line">res[k] = <span class="number">1</span>;</span><br><span class="line">pwp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pwp[i] = pwp[i<span class="number">-1</span>] * pr[k] % mod;</span><br><span class="line">v[a[n]]++; add(a[n]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) &#123;</span><br><span class="line">v[a[i]]++; add(a[i]);</span><br><span class="line"><span class="keyword">for</span>(aa = n - i, pp = <span class="number">0</span>; aa % pr[k] == <span class="number">0</span>; aa /= pr[k], pp++);</span><br><span class="line">a1 = a1 * aa % mod; p1 += pp;</span><br><span class="line"><span class="keyword">for</span>(aa = v[a[i]], pp = <span class="number">0</span>; aa % pr[k] == <span class="number">0</span>; aa /= pr[k], pp++);</span><br><span class="line">a1 = a1 * inv(aa, mod) % mod; p1 -= pp;</span><br><span class="line">res[k] = (res[k] + a1 % mod * query(a[i] - <span class="number">1</span>) % mod * pwp[p1] % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; res[k] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"> <span class="keyword">int</span> sm = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), mx = max(mx, a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= m; i++) <span class="keyword">if</span>(m % i == <span class="number">0</span>) &#123;</span><br><span class="line">pr[++cnt] = i; pb[cnt] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(m % i == <span class="number">0</span>) m /= i, b[cnt]++, pb[cnt] *= pr[cnt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(m != <span class="number">1</span>) pr[++cnt] = m, b[cnt] = <span class="number">1</span>, pb[cnt] = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) mod = pb[i], solve(i);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> M = sm / pb[i];</span><br><span class="line">ans = (ans + res[i] * M % sm * inv(M, pb[i]) % sm) % sm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1129&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1129&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;如果没有重复元素，直接一位一位计数即可&lt;br&gt;有相同元素仍然是一位一位计数，考虑从后往前，假设当前前i-1个是固定的，数在第i位开始小于给定的序列的方案数&lt;br&gt;设原数列为$a$，可以变动的中，不同的元素分别是$b_1, b_2, b_3, …, b_k$，个数分别为$c_1, c_2, c_3…, c_k$个，则答案为&lt;br&gt;$$&lt;br&gt;\sum_{b_j&amp;lt; a_i}\frac{(n-i)!}{\Pi_{k!=j} b_k\cdot(b_j-1) }&lt;br&gt;$$&lt;br&gt;硬算是$O(n^2)$的，可以用树状数组优化&lt;br&gt;分别维护分母和分子，每次i–时有一个新的元素加进来，某一个b会+1，分母会乘以新的b&lt;/p&gt;
&lt;p&gt;关键是这个模数的问题，他不是质数，要质因数分解，分别求答案，然后用CRT合并&lt;br&gt;逆元需要用扩展欧几里得来算&lt;/p&gt;
&lt;p&gt;还有比较麻烦的，如果乘以或除以的数是当前处理的模数对应的那个质因子的倍数，那么需要把这个数所有该因数除掉，同时记录去掉了几个这个因数&lt;br&gt;最后要把这些去掉的因数再快速幂乘回来&lt;br&gt;这是因为求逆元时要求与模数互质，因此必须先去掉，求完逆元再乘回来&lt;/p&gt;
&lt;p&gt;任意模数的逆元的处理方式要记笔记。。。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数据结构" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="组合" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"/>
    
      <category term="树状数组" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="树状数组" scheme="http://ratexxxx.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="组合数学" scheme="http://ratexxxx.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1113 [Poi2008]海报PLA</title>
    <link href="http://ratexxxx.github.io/2019/09/09/BZOJ1113-Poi2008-%E6%B5%B7%E6%8A%A5PLA/"/>
    <id>http://ratexxxx.github.io/2019/09/09/BZOJ1113-Poi2008-海报PLA/</id>
    <published>2019-09-09T12:01:00.000Z</published>
    <updated>2019-09-09T12:08:26.631Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1113" target="_blank" rel="noopener">BZOJ1113</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>海报个数减少的机会就是两个矩阵高度相同，且他们之间的矩阵都比他们高</p><p>这样用一个单调栈就可以了，维护一个上升的高度，每个矩阵只有在弹出一个和他高度相同的矩阵时才不增加答案。<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, sta[<span class="number">250010</span>], tp, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">while</span>(tp &amp;&amp; sta[tp] &gt;= y) &#123;</span><br><span class="line"><span class="keyword">if</span>(sta[tp] &gt; y) ans++;</span><br><span class="line">tp--;</span><br><span class="line">&#125;</span><br><span class="line">sta[++tp] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans + tp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1113&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1113&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;海报个数减少的机会就是两个矩阵高度相同，且他们之间的矩阵都比他们高&lt;/p&gt;
&lt;p&gt;这样用一个单调栈就可以了，维护一个上升的高度，每个矩阵只有在弹出一个和他高度相同的矩阵时才不增加答案。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="单调栈" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    
      <category term="单调栈" scheme="http://ratexxxx.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1098 [POI2007]办公楼biu</title>
    <link href="http://ratexxxx.github.io/2019/09/09/BZOJ1098-POI2007-%E5%8A%9E%E5%85%AC%E6%A5%BCbiu/"/>
    <id>http://ratexxxx.github.io/2019/09/09/BZOJ1098-POI2007-办公楼biu/</id>
    <published>2019-09-09T11:32:40.000Z</published>
    <updated>2019-09-09T11:53:31.143Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1098" target="_blank" rel="noopener">BZOJ1098</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意：将一个图的点分成尽可能多的集合，任意两个属于不同集合的点都有边相连</p><p>换句话说，求补图的联通块数</p><p>然而补图的边数是$ O(n^2) $的，连边都连不了，并查集不行啊<br>我们回归到原始，考虑bfs或dfs时需要做什么<br>其实就是在每个点的时候，快速找到所有与他相连的未标记的点。</p><blockquote><p>对于一个点，可以$O(n)$找到所有与他相连的点（废话）</p></blockquote><blockquote><p>如果使用bfs的话，每个点只需要被这样找到一次（不是废话）</p></blockquote><p>因为一个点被找到之后，就可以入队然后找他的连边的点了，之后就算他再一次被找到，他们也已经被标记在同一个联通块里了，所以再一次找到他一次就没有必要了<br>因此在找到一个点后，入队之余把他删除掉就好了，这个用一个链表就解决了</p><p>实质上相当于把每个连通块简化成了一个bfs树，所有其他边都是没有必要的，边数就是$O(n)$的，然后就很好搞了</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>, maxm = <span class="number">4000010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxm], Next[maxm], tot, n, m, v[maxn], nxt[maxn], pre[maxn], col[maxn], tim, dd[maxn], sz[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">nxt[pre[x]] = nxt[x];</span><br><span class="line">pre[nxt[x]] = pre[x];</span><br><span class="line">dd[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s); col[s] = tim; del(s);</span><br><span class="line"><span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = nxt[<span class="number">0</span>]; i; i = nxt[i]) v[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(!dd[ver[i]]) v[ver[i]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = nxt[<span class="number">0</span>]; i; i = nxt[i]) <span class="keyword">if</span>(!v[i] &amp;&amp; !dd[i]) col[i] = tim, del(i), q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) nxt[i] = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pre[i] = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!col[i]) tim++, bfs(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tim);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sz[col[i]]++;</span><br><span class="line">sort(sz + <span class="number">1</span>, sz + <span class="number">1</span> + tim);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tim; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, sz[i]); <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1098&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1098&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题意：将一个图的点分成尽可能多的集合，任意两个属于不同集合的点都有边相连&lt;/p&gt;
&lt;p&gt;换句话说，求补图的联通块数&lt;/p&gt;
&lt;p&gt;然而补图的边数是$ O(n^2) $的，连边都连不了，并查集不行啊&lt;br&gt;我们回归到原始，考虑bfs或dfs时需要做什么&lt;br&gt;其实就是在每个点的时候，快速找到所有与他相连的未标记的点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一个点，可以$O(n)$找到所有与他相连的点（废话）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果使用bfs的话，每个点只需要被这样找到一次（不是废话）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为一个点被找到之后，就可以入队然后找他的连边的点了，之后就算他再一次被找到，他们也已经被标记在同一个联通块里了，所以再一次找到他一次就没有必要了&lt;br&gt;因此在找到一个点后，入队之余把他删除掉就好了，这个用一个链表就解决了&lt;/p&gt;
&lt;p&gt;实质上相当于把每个连通块简化成了一个bfs树，所有其他边都是没有必要的，边数就是$O(n)$的，然后就很好搞了&lt;/p&gt;
    
    </summary>
    
      <category term="图论" scheme="http://ratexxxx.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="补图" scheme="http://ratexxxx.github.io/categories/%E5%9B%BE%E8%AE%BA/%E8%A1%A5%E5%9B%BE/"/>
    
    
      <category term="搞" scheme="http://ratexxxx.github.io/tags/%E6%90%9E/"/>
    
      <category term="bfs" scheme="http://ratexxxx.github.io/tags/bfs/"/>
    
      <category term="链表" scheme="http://ratexxxx.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1065 [NOI2008]奥运物流</title>
    <link href="http://ratexxxx.github.io/2019/08/31/BZOJ1065-NOI2008-%E5%A5%A5%E8%BF%90%E7%89%A9%E6%B5%81/"/>
    <id>http://ratexxxx.github.io/2019/08/31/BZOJ1065-NOI2008-奥运物流/</id>
    <published>2019-08-31T09:10:24.000Z</published>
    <updated>2019-09-09T11:30:39.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1065" target="_blank" rel="noopener">BZOJ1065</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>有一颗有根树，根节点还有一个父亲，每个点的可靠性与儿子们相关。</p><p>考虑如果是一棵纯正的树，那么答案应为<br>$$<br>\sum_{i=1}^nk^{dep[i]}C_i<br>$$<br>当出现环后，也就出现了一个方程，解这个方程即可，设1号点的后继为t<br>$$<br>ans = \sum_{i=1}^nk^{dep[i]}C_i + ans\times k^{dep[x]} \\<br>ans = \frac{\sum_{i=1}^nk^{dep[i]}C_i}{1 - k^{dep[x]}}<br>$$<br>容易发现每个修改后继的点，后继一定修改成了1号节点，这样最优<br>枚举1号点的后继的深度，分母也就确定了，就可以不用考虑环了</p><p>于是就是在树上dp，用$f[i][j]$表示以i为根的子树中，j个点接到1的下面，最大的稳定度<br>但问题是转移时稳定度需要用深度来算啊，这样的状态无法转移<br>因此再加一维记录深度，用$f[i][j][k]$表示以i为根的子树中，i的深度为k，有j个点接到1的下面，最大的稳定度<br>这样转移时每个点u可以考虑是否接到1的下面</p><ol><li><p>如果u后继改为1，那么儿子的深度要么是1（也改了），要么是2（没改）<br>转移如下（设v是u的儿子）<br>$$<br>f[u][i][j] = C_u\times k + max(f[v][k][1], f[v][k][2])<br>$$<br>有限制条件，$\sum k = i - 1$，所以后面一项要用背包dp来做</p></li><li><p>如果u后继不改，那么儿子深度为$j + 1$或1<br>可以同理得到这样的转移<br>$$<br>f[u][i][j] = C_u \times k^j + max(f[v][k][1], f[v][k][j + 1])<br>$$<br>限制相同，用同样的背包dp做</p></li></ol><p>代码中背包dp部分的$g[i][j]$表示的是考虑前i个儿子，j个点后继改为1的最大值，实际上就是套路的背包dp</p><p>关于上面说的枚举1后继的深度，实际上可以在1的后继到1号点这条链上枚举每一个点，将他的后继改为1，dp更新答案之后再改回去，这样比较容易实现</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">70</span>;</span><br><span class="line"><span class="keyword">int</span> v[maxn], F, s[maxn], dep[maxn], sz[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">double</span> k, c[maxn], pk[maxn], f[maxn][maxn][maxn], g[maxn][maxn], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) f[i][j][k] = <span class="number">-1e18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dpbag</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sz[x]; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) g[i][j] = <span class="number">-1e18</span>;</span><br><span class="line">g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">2</span>, i = <span class="number">0</span>; y &lt;= n; y++) <span class="keyword">if</span>(s[y] == x) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k++) g[i+<span class="number">1</span>][j] = max(g[i+<span class="number">1</span>][j], g[i][k] + f[y][j-k][d]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">sz[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span>(s[i] == x) sz[x]++, dep[i] = dep[x] + <span class="number">1</span>, dfs(i);</span><br><span class="line">dpbag(x, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) f[x][j][i] = c[x] * k + g[sz[x]][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dpbag(x, i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) f[x][j][i] = max(f[x][j][i], g[sz[x]][j] + c[x] * pk[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"trans.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"trans.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;n, &amp;m, &amp;k); m = min(m, n - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;F); s[<span class="number">1</span>] = F;</span><br><span class="line">pk[<span class="number">0</span>] = <span class="number">1.0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) pk[i] = pk[i<span class="number">-1</span>] * k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), s[i] = x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;c[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = s[<span class="number">1</span>]; i != <span class="number">1</span>; i = s[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = s[i]; s[i] = <span class="number">1</span>;</span><br><span class="line">init();</span><br><span class="line">dfs(<span class="number">1</span>); ans = max(ans, f[<span class="number">1</span>][m - (tmp == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>)][<span class="number">0</span>] / (<span class="number">1</span> - pk[dep[F] + <span class="number">1</span>]));</span><br><span class="line">s[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1065&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1065&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;有一颗有根树，根节点还有一个父亲，每个点的可靠性与儿子们相关。&lt;/p&gt;
&lt;p&gt;考虑如果是一棵纯正的树，那么答案应为&lt;br&gt;$$&lt;br&gt;\sum_{i=1}^nk^{dep[i]}C_i&lt;br&gt;$$&lt;br&gt;当出现环后，也就出现了一个方程，解这个方程即可，设1号点的后继为t&lt;br&gt;$$&lt;br&gt;ans = \sum_{i=1}^nk^{dep[i]}C_i + ans\times k^{dep[x]} \\&lt;br&gt;ans = \frac{\sum_{i=1}^nk^{dep[i]}C_i}{1 - k^{dep[x]}}&lt;br&gt;$$&lt;br&gt;容易发现每个修改后继的点，后继一定修改成了1号节点，这样最优&lt;br&gt;枚举1号点的后继的深度，分母也就确定了，就可以不用考虑环了&lt;/p&gt;
&lt;p&gt;于是就是在树上dp，用$f[i][j]$表示以i为根的子树中，j个点接到1的下面，最大的稳定度&lt;br&gt;但问题是转移时稳定度需要用深度来算啊，这样的状态无法转移&lt;br&gt;因此再加一维记录深度，用$f[i][j][k]$表示以i为根的子树中，i的深度为k，有j个点接到1的下面，最大的稳定度&lt;br&gt;这样转移时每个点u可以考虑是否接到1的下面&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果u后继改为1，那么儿子的深度要么是1（也改了），要么是2（没改）&lt;br&gt;转移如下（设v是u的儿子）&lt;br&gt;$$&lt;br&gt;f[u][i][j] = C_u\times k + max(f[v][k][1], f[v][k][2])&lt;br&gt;$$&lt;br&gt;有限制条件，$\sum k = i - 1$，所以后面一项要用背包dp来做&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果u后继不改，那么儿子深度为$j + 1$或1&lt;br&gt;可以同理得到这样的转移&lt;br&gt;$$&lt;br&gt;f[u][i][j] = C_u \times k^j + max(f[v][k][1], f[v][k][j + 1])&lt;br&gt;$$&lt;br&gt;限制相同，用同样的背包dp做&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码中背包dp部分的$g[i][j]$表示的是考虑前i个儿子，j个点后继改为1的最大值，实际上就是套路的背包dp&lt;/p&gt;
&lt;p&gt;关于上面说的枚举1后继的深度，实际上可以在1的后继到1号点这条链上枚举每一个点，将他的后继改为1，dp更新答案之后再改回去，这样比较容易实现&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树形dp" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2dp/"/>
    
      <category term="背包dp" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85dp/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ1064 [Noi2008]假面舞会</title>
    <link href="http://ratexxxx.github.io/2019/08/31/BZOJ1064-Noi2008-%E5%81%87%E9%9D%A2%E8%88%9E%E4%BC%9A/"/>
    <id>http://ratexxxx.github.io/2019/08/31/BZOJ1064-Noi2008-假面舞会/</id>
    <published>2019-08-31T06:58:15.000Z</published>
    <updated>2019-08-31T09:08:31.128Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1064" target="_blank" rel="noopener">BZOJ1064</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>对于每条信息连一条边权为1的正向边和一条边权为-1的反向边，然后染色问题，dfs一遍为每个点分配编号。若出现矛盾直接退出，否则得到这个连通块的最大可能数。<br>对每个联通的结果求gcd，就得到了整体的最大可能数<br>最小值就是最大值的第一个大于等于3的因数<br>注意小于3为无解<br>正确性显然，关键是正向反向的边权和染色<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>, maxm = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, head[maxn], ver[maxm], edge[maxm], Next[maxm], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123; ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> col[maxn], cir[maxm], cnt, v[maxn], cmx = <span class="number">1</span>, cmn = <span class="number">1</span>, len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cur, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">col[x] = cur; v[x] = <span class="number">1</span>;</span><br><span class="line">cmn = min(cmn, col[x]), cmx = max(cmx, col[x]);</span><br><span class="line"><span class="comment">// cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; cur &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(i != pa) &#123;</span><br><span class="line"><span class="keyword">if</span>(v[ver[i]]) cir[++cnt] = <span class="built_in">abs</span>(col[ver[i]] - (cur + edge[i]));</span><br><span class="line"><span class="keyword">else</span> dfs(ver[i], cur + edge[i], i ^ <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> y ? gcd(y, x % y) : x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen("2.in", "r", stdin);</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y, <span class="number">1</span>), add(y, x, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(!v[i]) dfs(i, <span class="number">1</span>, <span class="number">0</span>), len += cmx - cmn + <span class="number">1</span>, cmx = cmn = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// for(int i = 1; i &lt;= cnt; i++) cout &lt;&lt; cir[i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) mx = gcd(mx, cir[i]);</span><br><span class="line"><span class="keyword">if</span>(mx == <span class="number">1</span> || mx == <span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(mx == <span class="number">0</span>)&#123; </span><br><span class="line"><span class="keyword">if</span>(len &lt; <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, len, <span class="number">3</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mn;</span><br><span class="line"><span class="keyword">for</span>(mn = <span class="number">3</span>; mn &lt;= mx; mn++) <span class="keyword">if</span>(mx % mn == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, mx, mn); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1064&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1064&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;对于每条信息连一条边权为1的正向边和一条边权为-1的反向边，然后染色问题，dfs一遍为每个点分配编号。若出现矛盾直接退出，否则得到这个连通块的最大可能数。&lt;br&gt;对每个联通的结果求gcd，就得到了整体的最大可能数&lt;br&gt;最小值就是最大值的第一个大于等于3的因数&lt;br&gt;注意小于3为无解&lt;br&gt;正确性显然，关键是正向反向的边权和染色&lt;br&gt;
    
    </summary>
    
      <category term="图论" scheme="http://ratexxxx.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="染色" scheme="http://ratexxxx.github.io/categories/%E5%9B%BE%E8%AE%BA/%E6%9F%93%E8%89%B2/"/>
    
    
      <category term="染色" scheme="http://ratexxxx.github.io/tags/%E6%9F%93%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1063 [Noi2008]道路设计</title>
    <link href="http://ratexxxx.github.io/2019/08/31/BZOJ1063-Noi2008-%E9%81%93%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <id>http://ratexxxx.github.io/2019/08/31/BZOJ1063-Noi2008-道路设计/</id>
    <published>2019-08-31T06:03:06.000Z</published>
    <updated>2019-08-31T06:55:49.160Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1063" target="_blank" rel="noopener">BZOJ1063</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意：给定一棵有根树，可以将任意条路径上的边打上标记，每个点的“不便利度”为其到根的路径上未标记边的条数，要求最小化所有点不便利度的最大值，并求方案数</p><p>树形dp，用$ f[i][0/1] $表示以i为根的子树中，i连向父亲的边是否标记，最小的不便利度<br>考试时，我直接二分f值，实际上也可以递推，方法类似下面要说的g</p><p>这里有一个非常有用的性质<br>考虑树链剖分时的轻重链的划分，可以发现不便利度也就是轻边个数，因此有方法使不便利度最大不会超过$ log_2n $，这样就可以进一步设计状态了</p><p>用$ g[i][0/1/2][j] $表示以i为根的子树中，i连向子树的边标记了0或1或2条，不便利度为j的方案数<br>然后背包dp转移即可<br>至于为什么这里开了3个，f只开了2个，因为算f时由贪心策略，每个点连出去的边一定有一条标记，但算方案数时就不一定了</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, mod, head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot, N;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">2</span>], q[maxn];</span><br><span class="line">ll g[maxn][<span class="number">3</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa, <span class="keyword">int</span> mid, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[ver[i]][<span class="number">0</span>] + <span class="number">1</span> &lt;= mid) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(f[ver[i]][<span class="number">1</span>] &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt; lim) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) dp(ver[i], x);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(valid(x, pa, mid, <span class="number">1</span>)) r = mid; <span class="keyword">else</span> l = mid + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">1</span>] = l;</span><br><span class="line">l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(valid(x, pa, mid, <span class="number">2</span>)) r = mid; <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">f[x][<span class="number">0</span>] = l;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; f[x][0] &lt;&lt; ' ' &lt;&lt; f[x][1] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) dfs(ver[i], x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= N; j++) &#123;</span><br><span class="line">g[x][<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) &#123;</span><br><span class="line"><span class="keyword">int</span> y = ver[i];</span><br><span class="line">g[x][<span class="number">2</span>][j] = (g[x][<span class="number">1</span>][j] * g[y][<span class="number">1</span>][j] % mod + (j ? g[x][<span class="number">2</span>][j] * g[y][<span class="number">2</span>][j<span class="number">-1</span>] % mod : <span class="number">0</span>)) % mod;</span><br><span class="line">g[x][<span class="number">1</span>][j] = (g[x][<span class="number">0</span>][j] * g[y][<span class="number">1</span>][j] % mod + (j ? g[x][<span class="number">1</span>][j] * g[y][<span class="number">2</span>][j<span class="number">-1</span>] % mod : <span class="number">0</span>)) % mod;</span><br><span class="line"><span class="keyword">if</span>(j) (g[x][<span class="number">0</span>][j] *= g[y][<span class="number">2</span>][j<span class="number">-1</span>] % mod) %= mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Next[head[x]]) g[x][<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">(g[x][<span class="number">1</span>][j] += g[x][<span class="number">0</span>][j]) %= mod;</span><br><span class="line">(g[x][<span class="number">2</span>][j] += g[x][<span class="number">1</span>][j]) %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for(int i = 0; i &lt;= N; i++) cout &lt;&lt; g[x][2][i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for(int i = 0; i &lt;= N; i++) cout &lt;&lt; g[x][1][i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for(int i = 0; i &lt;= N; i++) cout &lt;&lt; g[x][0][i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("design.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//freopen("design.out", "w", stdout);</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;mod);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line"><span class="keyword">if</span>(m &lt; n - <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">"-1\n-1\n"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">dp(<span class="number">1</span>, <span class="number">0</span>); N = f[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (g[<span class="number">1</span>][<span class="number">2</span>][N]) % mod);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1063&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1063&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题意：给定一棵有根树，可以将任意条路径上的边打上标记，每个点的“不便利度”为其到根的路径上未标记边的条数，要求最小化所有点不便利度的最大值，并求方案数&lt;/p&gt;
&lt;p&gt;树形dp，用$ f[i][0/1] $表示以i为根的子树中，i连向父亲的边是否标记，最小的不便利度&lt;br&gt;考试时，我直接二分f值，实际上也可以递推，方法类似下面要说的g&lt;/p&gt;
&lt;p&gt;这里有一个非常有用的性质&lt;br&gt;考虑树链剖分时的轻重链的划分，可以发现不便利度也就是轻边个数，因此有方法使不便利度最大不会超过$ log_2n $，这样就可以进一步设计状态了&lt;/p&gt;
&lt;p&gt;用$ g[i][0/1/2][j] $表示以i为根的子树中，i连向子树的边标记了0或1或2条，不便利度为j的方案数&lt;br&gt;然后背包dp转移即可&lt;br&gt;至于为什么这里开了3个，f只开了2个，因为算f时由贪心策略，每个点连出去的边一定有一条标记，但算方案数时就不一定了&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树形dp" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2dp/"/>
    
    
      <category term="树形dp" scheme="http://ratexxxx.github.io/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1062 [NOI2008]糖果雨</title>
    <link href="http://ratexxxx.github.io/2019/08/31/BZOJ1062-NOI2008-%E7%B3%96%E6%9E%9C%E9%9B%A8/"/>
    <id>http://ratexxxx.github.io/2019/08/31/BZOJ1062-NOI2008-糖果雨/</id>
    <published>2019-08-31T03:53:56.000Z</published>
    <updated>2019-09-09T10:35:26.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1062" target="_blank" rel="noopener">BZOJ1062</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意：一些线段在左右飘，支持加入和删除线段，多次询问某个时刻某个区间接触的线段个数</p><p>我们把一条线段看成是平面坐标系中横坐标为左端点，纵坐标为线段长度的一个点．同时将横坐标复制一边，代表反方向，这样就变成了标准的循环．</p><p>考虑每个询问可以覆盖的范围，那么也就是求这个范围内的点数</p><p>如果时刻都为０的话，那么每个询问的范围是一个矩形切掉一个角形成的五边形，可以补成一个平行四边形．由于翻倍了，因此是两个</p><p>当时刻不为０时，这两个平行四边形会左右平移，要考虑到有重合部分的边界情况．</p><p>平行四边形不方便处理，可以坐标变换，新的纵坐标为原来的横纵坐标之和或差，对于两个平行四边形有不同的变换方式，要建两个坐标系</p><p>懒得画图了，贴一个<a href="https://oi.men.ci/noi2008-candy/" target="_blank" rel="noopener">写的很清楚的链接</a><br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, len, rev[<span class="number">1000010</span>], X[maxn], Y[maxn], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">2020</span>][<span class="number">4020</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">x++; y++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= <span class="number">2010</span>; i += i&amp;-i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = y; j &lt;= <span class="number">4010</span>; j += j&amp;-j)</span><br><span class="line">c[i][j] += z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">x++; y++;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">2</span> * len) x = <span class="number">2</span> * len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y &gt; <span class="number">4</span> * len) y = <span class="number">4</span> * len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ';</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= i&amp;-i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = y; j; j -= j&amp;-j) res += c[i][j];</span><br><span class="line"><span class="comment">//cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x1 &lt;&lt; ' ' &lt;&lt; y1 &lt;&lt; ' ' &lt;&lt; x2 &lt;&lt; ' ' &lt;&lt; y2 &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> query(x2, y2) - query(x1<span class="number">-1</span>, y2) - query(x2, y1<span class="number">-1</span>) + query(x1<span class="number">-1</span>, y1<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;bit1, bit2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"candy.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"candy.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> o, t, l, r, c, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;o);</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">1</span>) &#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;t, &amp;c, &amp;l, &amp;r, &amp;d);</span><br><span class="line">rev[c] = cnt; </span><br><span class="line">t = (t - d * l + len * <span class="number">2</span>) % (len * <span class="number">2</span>); r = r - l;</span><br><span class="line">bit1.add(t, r + t, <span class="number">1</span>); bit2.add(t, r - t + <span class="number">2</span> * len, <span class="number">1</span>);</span><br><span class="line">X[cnt] = t; Y[cnt] = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;t, &amp;l, &amp;r);</span><br><span class="line"><span class="keyword">int</span> d = (r == len);</span><br><span class="line">t %= (len * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> res = bit1.sum(t, t + l, t + r, <span class="number">4</span> * len) + bit1.sum(<span class="number">0</span>, t + l - <span class="number">2</span> * len, t + r - <span class="number">2</span> * len - d, <span class="number">4</span> * len);</span><br><span class="line"><span class="comment">//cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">res += bit2.sum(t - r, l - t + <span class="number">2</span> * len, t - <span class="number">1</span>, <span class="number">4</span> * len) + bit2.sum(t - r + <span class="number">2</span> * len + d, l - t, <span class="number">2</span> * len, <span class="number">4</span> * len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;l);</span><br><span class="line"><span class="keyword">int</span> i = rev[l];</span><br><span class="line">bit1.add(X[i], Y[i] + X[i], <span class="number">-1</span>); </span><br><span class="line">bit2.add(X[i], Y[i] - X[i] + <span class="number">2</span> * len, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1062&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1062&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题意：一些线段在左右飘，支持加入和删除线段，多次询问某个时刻某个区间接触的线段个数&lt;/p&gt;
&lt;p&gt;我们把一条线段看成是平面坐标系中横坐标为左端点，纵坐标为线段长度的一个点．同时将横坐标复制一边，代表反方向，这样就变成了标准的循环．&lt;/p&gt;
&lt;p&gt;考虑每个询问可以覆盖的范围，那么也就是求这个范围内的点数&lt;/p&gt;
&lt;p&gt;如果时刻都为０的话，那么每个询问的范围是一个矩形切掉一个角形成的五边形，可以补成一个平行四边形．由于翻倍了，因此是两个&lt;/p&gt;
&lt;p&gt;当时刻不为０时，这两个平行四边形会左右平移，要考虑到有重合部分的边界情况．&lt;/p&gt;
&lt;p&gt;平行四边形不方便处理，可以坐标变换，新的纵坐标为原来的横纵坐标之和或差，对于两个平行四边形有不同的变换方式，要建两个坐标系&lt;/p&gt;
&lt;p&gt;懒得画图了，贴一个&lt;a href=&quot;https://oi.men.ci/noi2008-candy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;写的很清楚的链接&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="树状数组" scheme="http://ratexxxx.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="数形转换" scheme="http://ratexxxx.github.io/tags/%E6%95%B0%E5%BD%A2%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1921 [Ctsc2010]珠宝商</title>
    <link href="http://ratexxxx.github.io/2019/08/28/BZOJ1921-Ctsc2010-%E7%8F%A0%E5%AE%9D%E5%95%86/"/>
    <id>http://ratexxxx.github.io/2019/08/28/BZOJ1921-Ctsc2010-珠宝商/</id>
    <published>2019-08-28T13:09:46.000Z</published>
    <updated>2019-08-30T12:25:12.096Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1921" target="_blank" rel="noopener">BZOJ1921</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>本题综合利用后缀自动机的呀</p><p>首先第一想法是怎么写暴力，从每个点为起点开始想下走，同时在SAM上走DAG，对于树上的每走到一个点，把答案加上其SAM对应节点的endpos大小即可，复杂度$ O(n^2) $</p><p>然后看到这种统计路径的题，回想到点分和DSU，先试试点分，那么需要做的是统计以经过某个点x的路径的贡献，假设这条路径是$ u \to x \to v $<br>点分的一般思路，如果可以单独算出$ u \to x $和$ x \to v $，那么拼在一起就好了<br>但是如何拼在一起呢<br>考虑可以在M串上统计，每个u到x在匹配的位置上加一个标记，那么最后的答案就是每个位置 向前匹配的标记和*向后匹配的标记和 之和<br>发现上面说的两种路径其中一种可以变成反串上的另一种，因此只需考虑一种就可以</p><p>然后就要求后缀自动机理解透彻了<br>网上的题解都说要在后缀树上统计$ u \to x $的路径贡献<br>然后我就想，为什么还要搞后缀树，直接在DAG上统计$ x \to v $的贡献不就可以啦，每次在后面加一个字符，方法同第一种暴力一样啊<br>然而在网上找不到这种做法，于是我就手画了好多后缀自动机和后缀树（因为画挂了很多次），然后找到了原因<br>如果我们走DAG来计算贡献，那么走到一个点时，要计入的是以$ x…v $为前缀的串的个数，但在DAG上走到一个位置，这个节点代表的字串可以有在$x…v$前面加了几个字符，然后就不满足要求了，但我们同样会计入答案。也就是说这样会统计多<br>但如果在后缀树上统计$ u \to x $，那么每次是在前面加一个字符，需要向儿子走，但可以保证之后走到的每一个点代表的所有串都是以$ u…x $为后缀的，就是当且仅当的意思，所以可以正确统计<br>这个还是要搞张图看看啊</p><p>后缀自动机一个重要性质：自动机的par树即是其反串的后缀树（所以par树也叫前缀树，前缀树是反串的后缀树，多好）<br>然后建后缀树时记录一下每个点到其儿子走的是哪个字符的转移边</p><p>这样点分的做法就完善了，由于在每个分治点都要在后缀树上将标记推到儿子并统计，复杂度是$ O(nlogn + nm) $，后面一部分成了瓶颈</p><p>前人想出了一个很神仙的操作，我们发现第一个解法（暴力）复杂度与m无关，因此可以考虑当分治的子树大小低于某个值时直接暴力统计即可<br>当这个值设为$ \sqrt n $时最优，复杂度可以控制在$ O((n + m)\sqrt n) $</p><p>写在最后<br>后缀系列算法真的好神啊，后缀自动机和后缀树的坑好深啊<br>主要是有各种各样的性质，互相转换又即为方便<br>然后通过这道题我还练熟了手画自动机[滑稽]</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i(a), i##_ORZ(b); i &lt;= i##_ORZ; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drep(i, a, b) for(int i(a), i##_ORZ(b); i &gt;= i##_ORZ; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">char</span> tr[maxn], eg[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, head[maxn], ver[maxn], Next[maxn], tot, totsz, mn, rt, sz[maxn], v[maxn], B;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> par[maxn], ch[maxn][<span class="number">30</span>], val[maxn], cnt, las, rt;</span><br><span class="line"><span class="keyword">int</span> sz[maxn], pos[maxn], nxt[maxn][<span class="number">30</span>], c[maxn], A[maxn], nod[maxn], sum[maxn];</span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> po)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = las, np = ++cnt; nod[po] = np;</span><br><span class="line">val[np] = val[p] + <span class="number">1</span>; sz[np] = <span class="number">1</span>; pos[np] = po;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line"><span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> q = ch[p][x];</span><br><span class="line"><span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span>(ch[nq]));</span><br><span class="line">par[nq] = par[q];</span><br><span class="line">par[q] = par[np] = nq;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">las = np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cnt = rt = las = <span class="number">1</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, m) extend(S[i] - <span class="string">'a'</span>, i);</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) c[val[i]]++;</span><br><span class="line">rep(i, <span class="number">1</span>, m) c[i] += c[i<span class="number">-1</span>];</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) A[c[val[i]]--] = i;</span><br><span class="line">drep(i, cnt, <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x = A[i];</span><br><span class="line">sz[par[x]] += sz[x]; </span><br><span class="line"><span class="keyword">if</span>(!pos[par[x]]) pos[par[x]] = pos[x];</span><br><span class="line">nxt[par[x]][S[pos[x] - val[par[x]]] - <span class="string">'a'</span>] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) sum[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) sum[A[i]] += sum[par[A[i]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa, <span class="keyword">int</span> cur, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(len == val[cur]) cur = nxt[cur][tr[x] - <span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S[pos[cur] - len] != tr[x]) cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">len++; sum[cur]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]])</span><br><span class="line">match(ver[i], x, cur, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;sam[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">sz[x] = <span class="number">1</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]]) &#123;</span><br><span class="line">getroot(ver[i], x);</span><br><span class="line">sz[x] += sz[ver[i]];</span><br><span class="line">res = max(res, sz[ver[i]]);</span><br><span class="line">&#125;</span><br><span class="line">res = max(res, totsz - sz[x]);</span><br><span class="line"><span class="keyword">if</span>(res &lt; mn) rt = x, mn = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">cur = sam[<span class="number">0</span>].ch[cur][tr[x] - <span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">ans += sam[<span class="number">0</span>].sz[cur];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]])</span><br><span class="line">calc(ver[i], x, cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brute</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">calc(x, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]])</span><br><span class="line">brute(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">sam[<span class="number">0</span>].clear(); sam[<span class="number">1</span>].clear();</span><br><span class="line">sam[<span class="number">0</span>].match(x, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); sam[<span class="number">0</span>].pushdown();</span><br><span class="line">sam[<span class="number">1</span>].match(x, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); sam[<span class="number">1</span>].pushdown();</span><br><span class="line">rep(i, <span class="number">1</span>, m) ans += <span class="number">1l</span>l * sam[<span class="number">0</span>].sum[sam[<span class="number">0</span>].nod[i]] * sam[<span class="number">1</span>].sum[sam[<span class="number">1</span>].nod[m - i + <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">sam[<span class="number">0</span>].clear(); sam[<span class="number">1</span>].clear();</span><br><span class="line">sam[<span class="number">0</span>].match(x, <span class="number">0</span>, sam[<span class="number">0</span>].ch[<span class="number">1</span>][tr[pa] - <span class="string">'a'</span>], <span class="number">1</span>); sam[<span class="number">0</span>].pushdown();</span><br><span class="line">sam[<span class="number">1</span>].match(x, <span class="number">0</span>, sam[<span class="number">1</span>].ch[<span class="number">1</span>][tr[pa] - <span class="string">'a'</span>], <span class="number">1</span>); sam[<span class="number">1</span>].pushdown();</span><br><span class="line">rep(i, <span class="number">1</span>, m) ans -= <span class="number">1l</span>l * sam[<span class="number">0</span>].sum[sam[<span class="number">0</span>].nod[i]] * sam[<span class="number">1</span>].sum[sam[<span class="number">1</span>].nod[m - i + <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsz</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">sz[x] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(!v[ver[i]] &amp;&amp; ver[i] != pa) </span><br><span class="line">getsz(ver[i], x), sz[x] += sz[ver[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(totsz &lt;= B) &#123; brute(x, <span class="number">0</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">Insert(x); v[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(!v[ver[i]]) Delete(ver[i], x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(!v[ver[i]]) &#123;</span><br><span class="line">getsz(ver[i], x);</span><br><span class="line">totsz = mn = sz[ver[i]];</span><br><span class="line">getroot(ver[i], x);</span><br><span class="line">DFS(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line">B = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, tr + <span class="number">1</span>, eg + <span class="number">1</span>);</span><br><span class="line">m = <span class="built_in">strlen</span>(eg + <span class="number">1</span>);</span><br><span class="line">rep(i, <span class="number">1</span>, m) sam[<span class="number">0</span>].S[i] = eg[i], sam[<span class="number">1</span>].S[m - i + <span class="number">1</span>] = eg[i];</span><br><span class="line">sam[<span class="number">0</span>].build(); sam[<span class="number">1</span>].build();</span><br><span class="line">totsz = mn = n; </span><br><span class="line">getroot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">DFS(rt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1921&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1921&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;本题综合利用后缀自动机的呀&lt;/p&gt;
&lt;p&gt;首先第一想法是怎么写暴力，从每个点为起点开始想下走，同时在SAM上走DAG，对于树上的每走到一个点，把答案加上其SAM对应节点的endpos大小即可，复杂度$ O(n^2) $&lt;/p&gt;
&lt;p&gt;然后看到这种统计路径的题，回想到点分和DSU，先试试点分，那么需要做的是统计以经过某个点x的路径的贡献，假设这条路径是$ u \to x \to v $&lt;br&gt;点分的一般思路，如果可以单独算出$ u \to x $和$ x \to v $，那么拼在一起就好了&lt;br&gt;但是如何拼在一起呢&lt;br&gt;考虑可以在M串上统计，每个u到x在匹配的位置上加一个标记，那么最后的答案就是每个位置 向前匹配的标记和*向后匹配的标记和 之和&lt;br&gt;发现上面说的两种路径其中一种可以变成反串上的另一种，因此只需考虑一种就可以&lt;/p&gt;
&lt;p&gt;然后就要求后缀自动机理解透彻了&lt;br&gt;网上的题解都说要在后缀树上统计$ u \to x $的路径贡献&lt;br&gt;然后我就想，为什么还要搞后缀树，直接在DAG上统计$ x \to v $的贡献不就可以啦，每次在后面加一个字符，方法同第一种暴力一样啊&lt;br&gt;然而在网上找不到这种做法，于是我就手画了好多后缀自动机和后缀树（因为画挂了很多次），然后找到了原因&lt;br&gt;如果我们走DAG来计算贡献，那么走到一个点时，要计入的是以$ x…v $为前缀的串的个数，但在DAG上走到一个位置，这个节点代表的字串可以有在$x…v$前面加了几个字符，然后就不满足要求了，但我们同样会计入答案。也就是说这样会统计多&lt;br&gt;但如果在后缀树上统计$ u \to x $，那么每次是在前面加一个字符，需要向儿子走，但可以保证之后走到的每一个点代表的所有串都是以$ u…x $为后缀的，就是当且仅当的意思，所以可以正确统计&lt;br&gt;这个还是要搞张图看看啊&lt;/p&gt;
&lt;p&gt;后缀自动机一个重要性质：自动机的par树即是其反串的后缀树（所以par树也叫前缀树，前缀树是反串的后缀树，多好）&lt;br&gt;然后建后缀树时记录一下每个点到其儿子走的是哪个字符的转移边&lt;/p&gt;
&lt;p&gt;这样点分的做法就完善了，由于在每个分治点都要在后缀树上将标记推到儿子并统计，复杂度是$ O(nlogn + nm) $，后面一部分成了瓶颈&lt;/p&gt;
&lt;p&gt;前人想出了一个很神仙的操作，我们发现第一个解法（暴力）复杂度与m无关，因此可以考虑当分治的子树大小低于某个值时直接暴力统计即可&lt;br&gt;当这个值设为$ \sqrt n $时最优，复杂度可以控制在$ O((n + m)\sqrt n) $&lt;/p&gt;
&lt;p&gt;写在最后&lt;br&gt;后缀系列算法真的好神啊，后缀自动机和后缀树的坑好深啊&lt;br&gt;主要是有各种各样的性质，互相转换又即为方便&lt;br&gt;然后通过这道题我还练熟了手画自动机[滑稽]&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="字符串" scheme="http://ratexxxx.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://ratexxxx.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="后缀树" scheme="http://ratexxxx.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E6%A0%91/"/>
    
      <category term="点分治" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
    
      <category term="后缀自动机" scheme="http://ratexxxx.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="后缀树" scheme="http://ratexxxx.github.io/tags/%E5%90%8E%E7%BC%80%E6%A0%91/"/>
    
      <category term="点分治" scheme="http://ratexxxx.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1920 [Ctsc2010]产品销售</title>
    <link href="http://ratexxxx.github.io/2019/08/28/BZOJ1920-Ctsc2010-%E4%BA%A7%E5%93%81%E9%94%80%E5%94%AE/"/>
    <id>http://ratexxxx.github.io/2019/08/28/BZOJ1920-Ctsc2010-产品销售/</id>
    <published>2019-08-28T13:06:37.000Z</published>
    <updated>2019-08-31T03:05:20.053Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接:<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1920" target="_blank" rel="noopener">BZOJ1920</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>对于30分的部分分，就是建出图后跑最小费用最大流<br>对于100分，就是模拟费用流的过程，中间用数据结构（线段树）维护</p><p>建图方式如下<br>$ s \to i $ 容量为U，费用为P<br>$ i \to i+1$ 容量为$ \infty$，费用为M<br>$ i+1 \to i$ 容量为$ \infty$，费用为C<br>$ i \to t$ 容量为D，费用为0<br>还有他们的反向边</p><p>考虑如何模拟费用流，首先得性质是，源点和汇点都是满流的，并且他们可以不退流，因此可以考虑枚举每个点i，分配他到汇点的流量使之满流<br>可以发现源点到i的流有两种：<br>$ s \to k \to k+1 \to … \to i-1 \to i ……(1)$<br>$ s \to k \to k-1 \to … \to i+1 \to i ……(2)$<br>我们每次选两种决策中费用较少的进行扩流，直到$D[i]$流满为止<br>也就是过程分为三步，<br>一、计算两种决策的代价<br>二、取较优的方式扩流，维护信息，更新答案，直到流满<br>三、从i移动到i+1，维护信息</p><h3><span id="决策2">决策（2）</span></h3><p>由于i是递增枚举的，所以从右到左的流只可能走C的正向边，可以不考虑M的反响边，代价为$ P[k] + sumC[k-1] - sumC[i] $，前面只与k有关，可以先排好序，每次跳过非法的（$k \le i || U[k]==0$）的k就可以直接询问</p><p>扩流的话，流量为$flow = min(U[k], D[i])$，将$[i, k-1]$的区间流量加上$flow$即可</p><h3><span id="决策1">决策（1）</span></h3><p>M的正向边有无限容量，但代价大，C的反向边代价小（为负），但有容量限制，为路径上所有正向边流量的最小值，因此前面每条边的代价有两种情况，$-C $或$ +M$<br>如果可以对C的流量进行维护的话，那么就可以维护正确的代价，进而求最小值<br>这个维护，需要在流量从0边成非0时设置代价为$-C$，在其又退回0后将代价加上$C+M$，可以发现每条边最多在右边时变大，在左边时变小，因此只有这两个过程就够了</p><p>扩流同上</p><p>考虑这个0的维护，如果最开始初值设为0的话，那么很难区分0到底是初值还是后来减回来的，所以一个比较好的办法是初值设为inf<br>在没有用到它的时候默认inf就是初值的0<br>然后会面临在决策（2）的时候，流量被区间加，这时需要先把所有inf设为0，再区间加，可以发现每个inf最多被设为0一次，可以用并查集优化，每次跳到下一个inf的位置即可<br>然后面临在决策（1）时区间减，会出现减到0的情况这标志着要修改代价了，只有在这个时候会真正出现0。修改完代价后我们立刻把0再变回inf，代表它已经没有流量了。之所以他可以改成inf而不会继续对区间的容量有所限制，是因为我们已经修改过费用了，新的容量正好对应着新的费用。<br>这样就完美解决了最棘手的问题。</p><h3><span id="维护的信息">维护的信息</span></h3><p>需要维护C的流量flow，支持区间加减，查询最小值及其位置，以及获得每个0的位置，单点置为某值。<br>还要维护i之前每个点到i的代价（费用）cost，支持区间加减，查询最小值及其位置，单点置为某值<br>实际上操作是类似的，可以写成一个结构体的两个对象</p><p>具体怎么维护</p><p>在$cost[1…i-1] $中查询最小值和位置k，作为决策（1）<br>从排序好的那个序列首取出合法位置k，作为决策（2）<br>判断用那个决策，<br>对于（1）在$ flow[k…i-1] $中查询最小值，和U和D取min，得到流量，将$ flow[k…i-1] $区间减这个流量。在$flow$同样的区间递归找到每个为0的位置j，在$cost[1…j]$中区间加$ C[j]+M[j] $<br>对于（2），取U和D的min作为流量，$flow$区间加流量，加之前跳并查集将inf改为0<br>直到D[i]为0<br>将$cost[1…i]$区间加P[i]（前提是U[i]不为0）<br>将$cost[1…i]$区间加M[i]或-C[i]，取决于C[i]是否有流量，这是i对于前面每个点贡献的费用</p><p>然后终于结束了</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i(a), i##_END(b); i &lt;= i##_END; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drep(i, a, b) for(int i(a), i##_END(b); i &gt;= i##_END; i--);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, D[maxn], U[maxn], P[maxn], M[maxn], C[maxn], fa[maxn], sumC[maxn];</span><br><span class="line">pii rcs[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = get(fa[x]); &#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> mn[maxn * <span class="number">4</span>], pos[maxn * <span class="number">4</span>], tag[maxn * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; mn[p] = x; pos[p] = l; tag[p] = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(p*<span class="number">2</span>, l, mid, x); build(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!tag[p]) <span class="keyword">return</span>; </span><br><span class="line">mn[p*<span class="number">2</span>] += tag[p]; mn[p*<span class="number">2</span>+<span class="number">1</span>] += tag[p];</span><br><span class="line">tag[p*<span class="number">2</span>] += tag[p]; tag[p*<span class="number">2</span>+<span class="number">1</span>] += tag[p];</span><br><span class="line">tag[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123; mn[p] += x; tag[p] += x; <span class="keyword">return</span>; &#125;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) change(p*<span class="number">2</span>, l, mid, L, R, x);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) change(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; mn[p] = x; <span class="keyword">return</span>; &#125;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(u &lt;= mid) change(p*<span class="number">2</span>, l, mid, u, x);</span><br><span class="line"><span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, u, x);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> make_pair(mn[p], pos[p]);</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="function">pii <span class="title">res</span><span class="params">(inf, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) res = min(res, query(p*<span class="number">2</span>, l, mid, L, R));</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) res = min(res, query(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, SegmentTree &amp;tar)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; tar.change(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, l, C[l] + M[l]); mn[p] = inf; <span class="keyword">return</span>; &#125;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid &amp;&amp; mn[p*<span class="number">2</span>] == <span class="number">0</span>) reset(p*<span class="number">2</span>, l, mid, L, R, tar);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid &amp;&amp; mn[p*<span class="number">2</span>+<span class="number">1</span>] == <span class="number">0</span>) reset(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, tar);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;flow, cost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"product.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"product.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); </span><br><span class="line">rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;D[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;U[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;P[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n) fa[i] = i, sumC[i] = sumC[i<span class="number">-1</span>] + C[i], rcs[i] = make_pair(P[i] + sumC[i - <span class="number">1</span>], i);</span><br><span class="line">sort(rcs + <span class="number">1</span>, rcs + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">int</span> rpos = <span class="number">1</span>;</span><br><span class="line">flow.build(<span class="number">1</span>, <span class="number">1</span>, n, inf); cost.build(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">while</span>(D[i]) &#123;</span><br><span class="line">pii lcost = (i &gt; <span class="number">1</span> ? cost.query(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, i - <span class="number">1</span>) : make_pair(inf, <span class="number">0</span>)), rcost;</span><br><span class="line"><span class="keyword">while</span>(rpos &lt;= n &amp;&amp; (rcs[rpos].second &lt; i || !U[rcs[rpos].second])) ++rpos;</span><br><span class="line"><span class="keyword">if</span>(rpos &lt;= n) rcost = rcs[rpos], rcost.first -= sumC[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> rcost = make_pair(inf, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; lcost.second &lt;&lt; ' ' &lt;&lt; rcost.second &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span>(lcost &lt;= rcost) &#123;</span><br><span class="line"><span class="keyword">int</span> k = lcost.second;</span><br><span class="line">pii flowleft = flow.query(<span class="number">1</span>, <span class="number">1</span>, n, k, i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> nflow = min(flowleft.first, min(U[k], D[i]));</span><br><span class="line">flow.change(<span class="number">1</span>, <span class="number">1</span>, n, k, i - <span class="number">1</span>, -nflow);</span><br><span class="line">D[i] -= nflow; U[k] -= nflow;</span><br><span class="line">ans += <span class="number">1l</span>l * nflow * lcost.first;</span><br><span class="line"><span class="keyword">if</span>(!U[k]) cost.change(<span class="number">1</span>, <span class="number">1</span>, n, k, inf);</span><br><span class="line">flow.reset(<span class="number">1</span>, <span class="number">1</span>, n, k, i - <span class="number">1</span>, cost);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> k = rcost.second;</span><br><span class="line"><span class="keyword">int</span> nflow = min(U[k], D[i]);</span><br><span class="line">D[i] -= nflow; U[k] -= nflow;</span><br><span class="line">ans += <span class="number">1l</span>l * nflow * rcost.first;</span><br><span class="line"><span class="keyword">int</span> j = get(i);</span><br><span class="line"><span class="keyword">while</span>(j &lt;= k - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> fy = get(j + <span class="number">1</span>);</span><br><span class="line">flow.change(<span class="number">1</span>, <span class="number">1</span>, n, j, <span class="number">0</span>);</span><br><span class="line">fa[j] = fy; j = get(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k &gt; i) flow.change(<span class="number">1</span>, <span class="number">1</span>, n, i, k - <span class="number">1</span>, nflow);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == n) <span class="keyword">break</span>;</span><br><span class="line">cost.change(<span class="number">1</span>, <span class="number">1</span>, n, i, U[i] ? P[i] : inf);</span><br><span class="line">cost.change(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, i, fa[i] == i ? M[i] : -C[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接:&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1920&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1920&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;对于30分的部分分，就是建出图后跑最小费用最大流&lt;br&gt;对于100分，就是模拟费用流的过程，中间用数据结构（线段树）维护&lt;/p&gt;
&lt;p&gt;建图方式如下&lt;br&gt;$ s \to i $ 容量为U，费用为P&lt;br&gt;$ i \to i+1$ 容量为$ \infty$，费用为M&lt;br&gt;$ i+1 \to i$ 容量为$ \infty$，费用为C&lt;br&gt;$ i \to t$ 容量为D，费用为0&lt;br&gt;还有他们的反向边&lt;/p&gt;
&lt;p&gt;考虑如何模拟费用流，首先得性质是，源点和汇点都是满流的，并且他们可以不退流，因此可以考虑枚举每个点i，分配他到汇点的流量使之满流&lt;br&gt;可以发现源点到i的流有两种：&lt;br&gt;$ s \to k \to k+1 \to … \to i-1 \to i ……(1)$&lt;br&gt;$ s \to k \to k-1 \to … \to i+1 \to i ……(2)$&lt;br&gt;我们每次选两种决策中费用较少的进行扩流，直到$D[i]$流满为止&lt;br&gt;也就是过程分为三步，&lt;br&gt;一、计算两种决策的代价&lt;br&gt;二、取较优的方式扩流，维护信息，更新答案，直到流满&lt;br&gt;三、从i移动到i+1，维护信息&lt;/p&gt;
&lt;h3 id=&quot;决策（2）&quot;&gt;&lt;a href=&quot;#决策（2）&quot; class=&quot;headerlink&quot; title=&quot;决策（2）&quot;&gt;&lt;/a&gt;决策（2）&lt;/h3&gt;&lt;p&gt;由于i是递增枚举的，所以从右到左的流只可能走C的正向边，可以不考虑M的反响边，代价为$ P[k] + sumC[k-1] - sumC[i] $，前面只与k有关，可以先排好序，每次跳过非法的（$k \le i || U[k]==0$）的k就可以直接询问&lt;/p&gt;
&lt;p&gt;扩流的话，流量为$flow = min(U[k], D[i])$，将$[i, k-1]$的区间流量加上$flow$即可&lt;/p&gt;
&lt;h3 id=&quot;决策（1）&quot;&gt;&lt;a href=&quot;#决策（1）&quot; class=&quot;headerlink&quot; title=&quot;决策（1）&quot;&gt;&lt;/a&gt;决策（1）&lt;/h3&gt;&lt;p&gt;M的正向边有无限容量，但代价大，C的反向边代价小（为负），但有容量限制，为路径上所有正向边流量的最小值，因此前面每条边的代价有两种情况，$-C $或$ +M$&lt;br&gt;如果可以对C的流量进行维护的话，那么就可以维护正确的代价，进而求最小值&lt;br&gt;这个维护，需要在流量从0边成非0时设置代价为$-C$，在其又退回0后将代价加上$C+M$，可以发现每条边最多在右边时变大，在左边时变小，因此只有这两个过程就够了&lt;/p&gt;
&lt;p&gt;扩流同上&lt;/p&gt;
&lt;p&gt;考虑这个0的维护，如果最开始初值设为0的话，那么很难区分0到底是初值还是后来减回来的，所以一个比较好的办法是初值设为inf&lt;br&gt;在没有用到它的时候默认inf就是初值的0&lt;br&gt;然后会面临在决策（2）的时候，流量被区间加，这时需要先把所有inf设为0，再区间加，可以发现每个inf最多被设为0一次，可以用并查集优化，每次跳到下一个inf的位置即可&lt;br&gt;然后面临在决策（1）时区间减，会出现减到0的情况这标志着要修改代价了，只有在这个时候会真正出现0。修改完代价后我们立刻把0再变回inf，代表它已经没有流量了。之所以他可以改成inf而不会继续对区间的容量有所限制，是因为我们已经修改过费用了，新的容量正好对应着新的费用。&lt;br&gt;这样就完美解决了最棘手的问题。&lt;/p&gt;
&lt;h3 id=&quot;维护的信息&quot;&gt;&lt;a href=&quot;#维护的信息&quot; class=&quot;headerlink&quot; title=&quot;维护的信息&quot;&gt;&lt;/a&gt;维护的信息&lt;/h3&gt;&lt;p&gt;需要维护C的流量flow，支持区间加减，查询最小值及其位置，以及获得每个0的位置，单点置为某值。&lt;br&gt;还要维护i之前每个点到i的代价（费用）cost，支持区间加减，查询最小值及其位置，单点置为某值&lt;br&gt;实际上操作是类似的，可以写成一个结构体的两个对象&lt;/p&gt;
&lt;p&gt;具体怎么维护&lt;/p&gt;
&lt;p&gt;在$cost[1…i-1] $中查询最小值和位置k，作为决策（1）&lt;br&gt;从排序好的那个序列首取出合法位置k，作为决策（2）&lt;br&gt;判断用那个决策，&lt;br&gt;对于（1）在$ flow[k…i-1] $中查询最小值，和U和D取min，得到流量，将$ flow[k…i-1] $区间减这个流量。在$flow$同样的区间递归找到每个为0的位置j，在$cost[1…j]$中区间加$ C[j]+M[j] $&lt;br&gt;对于（2），取U和D的min作为流量，$flow$区间加流量，加之前跳并查集将inf改为0&lt;br&gt;直到D[i]为0&lt;br&gt;将$cost[1…i]$区间加P[i]（前提是U[i]不为0）&lt;br&gt;将$cost[1…i]$区间加M[i]或-C[i]，取决于C[i]是否有流量，这是i对于前面每个点贡献的费用&lt;/p&gt;
&lt;p&gt;然后终于结束了&lt;/p&gt;
    
    </summary>
    
      <category term="图论" scheme="http://ratexxxx.github.io/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数据结构" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="网络流" scheme="http://ratexxxx.github.io/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="线段树" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
      <category term="费用流" scheme="http://ratexxxx.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="线段树" scheme="http://ratexxxx.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="模拟" scheme="http://ratexxxx.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1919 [Ctsc2010]性能优化</title>
    <link href="http://ratexxxx.github.io/2019/08/28/BZOJ1919-Ctsc2010-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://ratexxxx.github.io/2019/08/28/BZOJ1919-Ctsc2010-性能优化/</id>
    <published>2019-08-28T13:02:06.000Z</published>
    <updated>2019-08-30T12:23:38.250Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1919" target="_blank" rel="noopener">BZOJ1919</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>据说是循环卷积板子题 需要对FFT有深刻的理解（不能只会敲模板）</p><p>FFT本身就是支持循环卷积的，只要把长度定为n就可以<br>令$ A,B,C $分别是点值表示的数组, $ a,b,c $为原数组<br>$$<br>A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\<br>B(\omega_n^k) = \sum_{i=0}^{n-1}b_i\omega_n^{ik} \\<br>C(\omega_n^k) = A(\omega_n^k) \times B(\omega_n^k)<br>= \sum_{i=0}^{n-1}a_i\omega_n^{ik}\sum_{i=0}^{n-1}b_i\omega_n^{ik}<br>$$<br>由于$ \omega_n^{k}=\omega_n^{k+n} $, 所以将其展开可得<br>$$<br>C(\omega_n^k) = \sum_{s=0}^{n-1}T_s\omega_n^{is}\\<br>T_s = \sum_{(i+j)mod(n+1)=s}a_i\cdot b_j<br>$$<br>我们要求的循环卷积$c$也就是$T$<br>所以实际上$C$就是$c$的卷积, 直接逆卷积回去就可以了. 证毕</p><p>然后要解决的问题是如何求任意长度FFT, 因为无法将其补成2的幂, 所以原来的板子行不通了<br>考虑n可以分解成P=2、3、5、7的幂，因此每次分治可以考虑分成P段，而不是单一的2段，但式子要重新搞。下面以3为例推一边，然后给出一个一般式子<br>$$<br>A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\<br>=(a_0\omega_n^k+a_3\omega_n^{3k}+a_6\omega_n^{6k}+…) \\+(a_1\omega_n^k+a_4\omega_n^{3k}+a_7\omega_n^{6k}+…) \\+(a_2\omega_n^k+a_5\omega_n^{3k}+a_8\omega_n^{6k}+…)  \\<br>= A_0(\omega_n^{3k}) + \omega_n^kA_1(\omega_n^{3k}) + \omega_n^{2k}A_2(\omega_n^{3k})<br>$$<br>这里按照3的同余系进行分组，$A_i$代表将a按照膜3的余数分组后递归求出的点值，同理可得<br>$$<br>A(\omega_n^{k+\frac{n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{2k}{3}}A_2(\omega_n^{3k}) \\<br>A(\omega_n^{k+\frac{2n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{2n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{4n}{3}}A_2(\omega_n^{3k}) \\<br>$$<br>然后这三个数就可以一起算了，方法类似FFT<br>对于其他的P，同理有如下式子<br>$$<br>A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_n^{Pk})<br>$$<br>或者写成如下形式更能看出来如何递归子问题<br>$$<br>A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_{\frac{n}{P}}^{k})<br>$$<br>也就是n的规模缩小了$\frac{1}{P}$，递归后每一个对应位置都枚举i，j求一下，需要一个临时数组来备份上一层的结果<br>也可以写非递归的，好像要预处理一下每个位置最后会移到哪里，但是递归也能A，我就没写迭代的（其实是懒）</p><p>最后的问题是FFT复数运算会存在极大精度问题，因为本题要快速幂算C次方，值域极大。<br>所以改成NTT，题目保证n+1是质数，又已经说了n最多4个质因数，因此求一下原根就好，这里在提一下原根求法（这里的n是题目中的n，求的是n+1的原根）<br>从2到n-1枚举g，验证g是原根的条件是：任意p是n的质因数，有<br>$$<br>g^{\frac{n}{p}} \neq 1\quad mod\ (n+1)<br>$$</p><p>为了做这题不得不复习一遍FFT的推导，本来只会敲板子的ε=(´ο｀*)))</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i(a), i##_AWSL(b); i &lt;= i##_AWSL; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drep(i, a, b) for(int i(a), i##_AWSL(b); i &gt;= i##_AWSL; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, C, mod, g, pr[<span class="number">10</span>], cnt;</span><br><span class="line">ll a[maxn], b[maxn], tmp[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getg</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">5</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">7</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span>(g = <span class="number">2</span>; g &lt;= n; g++) &#123;</span><br><span class="line"><span class="keyword">int</span> tag = <span class="number">0</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) <span class="keyword">if</span>(Power(g, n / pr[i]) % mod == <span class="number">1</span>) tag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!tag) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(ll *p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> len = r - l + <span class="number">1</span>, P = <span class="number">2</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) <span class="keyword">if</span>(len % pr[i] == <span class="number">0</span>) P = pr[i];</span><br><span class="line"><span class="keyword">int</span> lp = len / P;</span><br><span class="line">rep(i, <span class="number">0</span>, len - <span class="number">1</span>) tmp[(i % P) * lp + i / P] = p[l + i]; </span><br><span class="line">rep(i, <span class="number">0</span>, len - <span class="number">1</span>) p[l + i] = tmp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i += lp) ntt(p, i, i + lp - <span class="number">1</span>, inv);</span><br><span class="line">ll omega = Power(g, n / len), w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(inv &lt; <span class="number">0</span>) omega = Power(omega, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= l + lp - <span class="number">1</span>; i++, w = w * omega % mod) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= r; j += lp) tmp[j] = p[j];</span><br><span class="line">ll x = w, delta = Power(g, n / P);</span><br><span class="line"><span class="keyword">if</span>(inv &lt; <span class="number">0</span>) delta = Power(delta, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= r; j += lp, x = x * delta % mod) &#123;</span><br><span class="line">ll tim = <span class="number">1</span>; p[j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= r; k += lp, tim = tim * x % mod)</span><br><span class="line">p[j] = (p[j] + tmp[k] * tim % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;C); mod = n + <span class="number">1</span>;</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]);</span><br><span class="line">getg();</span><br><span class="line">ntt(a, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>); ntt(b, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) a[i] = a[i] * Power(b[i], C) % mod;</span><br><span class="line">ntt(a, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">ll tmp = Power(n, mod - <span class="number">2</span>);</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) a[i] = a[i] * tmp % mod;</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1919&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1919&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;据说是循环卷积板子题 需要对FFT有深刻的理解（不能只会敲模板）&lt;/p&gt;
&lt;p&gt;FFT本身就是支持循环卷积的，只要把长度定为n就可以&lt;br&gt;令$ A,B,C $分别是点值表示的数组, $ a,b,c $为原数组&lt;br&gt;$$&lt;br&gt;A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\&lt;br&gt;B(\omega_n^k) = \sum_{i=0}^{n-1}b_i\omega_n^{ik} \\&lt;br&gt;C(\omega_n^k) = A(\omega_n^k) \times B(\omega_n^k)&lt;br&gt;= \sum_{i=0}^{n-1}a_i\omega_n^{ik}\sum_{i=0}^{n-1}b_i\omega_n^{ik}&lt;br&gt;$$&lt;br&gt;由于$ \omega_n^{k}=\omega_n^{k+n} $, 所以将其展开可得&lt;br&gt;$$&lt;br&gt;C(\omega_n^k) = \sum_{s=0}^{n-1}T_s\omega_n^{is}\\&lt;br&gt;T_s = \sum_{(i+j)mod(n+1)=s}a_i\cdot b_j&lt;br&gt;$$&lt;br&gt;我们要求的循环卷积$c$也就是$T$&lt;br&gt;所以实际上$C$就是$c$的卷积, 直接逆卷积回去就可以了. 证毕&lt;/p&gt;
&lt;p&gt;然后要解决的问题是如何求任意长度FFT, 因为无法将其补成2的幂, 所以原来的板子行不通了&lt;br&gt;考虑n可以分解成P=2、3、5、7的幂，因此每次分治可以考虑分成P段，而不是单一的2段，但式子要重新搞。下面以3为例推一边，然后给出一个一般式子&lt;br&gt;$$&lt;br&gt;A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\&lt;br&gt;=(a_0\omega_n^k+a_3\omega_n^{3k}+a_6\omega_n^{6k}+…) \\+(a_1\omega_n^k+a_4\omega_n^{3k}+a_7\omega_n^{6k}+…) \\+(a_2\omega_n^k+a_5\omega_n^{3k}+a_8\omega_n^{6k}+…)  \\&lt;br&gt;= A_0(\omega_n^{3k}) + \omega_n^kA_1(\omega_n^{3k}) + \omega_n^{2k}A_2(\omega_n^{3k})&lt;br&gt;$$&lt;br&gt;这里按照3的同余系进行分组，$A_i$代表将a按照膜3的余数分组后递归求出的点值，同理可得&lt;br&gt;$$&lt;br&gt;A(\omega_n^{k+\frac{n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{2k}{3}}A_2(\omega_n^{3k}) \\&lt;br&gt;A(\omega_n^{k+\frac{2n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{2n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{4n}{3}}A_2(\omega_n^{3k}) \\&lt;br&gt;$$&lt;br&gt;然后这三个数就可以一起算了，方法类似FFT&lt;br&gt;对于其他的P，同理有如下式子&lt;br&gt;$$&lt;br&gt;A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_n^{Pk})&lt;br&gt;$$&lt;br&gt;或者写成如下形式更能看出来如何递归子问题&lt;br&gt;$$&lt;br&gt;A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_{\frac{n}{P}}^{k})&lt;br&gt;$$&lt;br&gt;也就是n的规模缩小了$\frac{1}{P}$，递归后每一个对应位置都枚举i，j求一下，需要一个临时数组来备份上一层的结果&lt;br&gt;也可以写非递归的，好像要预处理一下每个位置最后会移到哪里，但是递归也能A，我就没写迭代的（其实是懒）&lt;/p&gt;
&lt;p&gt;最后的问题是FFT复数运算会存在极大精度问题，因为本题要快速幂算C次方，值域极大。&lt;br&gt;所以改成NTT，题目保证n+1是质数，又已经说了n最多4个质因数，因此求一下原根就好，这里在提一下原根求法（这里的n是题目中的n，求的是n+1的原根）&lt;br&gt;从2到n-1枚举g，验证g是原根的条件是：任意p是n的质因数，有&lt;br&gt;$$&lt;br&gt;g^{\frac{n}{p}} \neq 1\quad mod\ (n+1)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;为了做这题不得不复习一遍FFT的推导，本来只会敲板子的ε=(´ο｀*)))&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="多项式" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
      <category term="多项式" scheme="http://ratexxxx.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="NTT" scheme="http://ratexxxx.github.io/tags/NTT/"/>
    
      <category term="任意长度FFT" scheme="http://ratexxxx.github.io/tags/%E4%BB%BB%E6%84%8F%E9%95%BF%E5%BA%A6FFT/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3672 [Noi2014]购票</title>
    <link href="http://ratexxxx.github.io/2019/07/18/BZOJ3672-Noi2014-%E8%B4%AD%E7%A5%A8/"/>
    <id>http://ratexxxx.github.io/2019/07/18/BZOJ3672-Noi2014-购票/</id>
    <published>2019-07-18T06:56:13.000Z</published>
    <updated>2019-09-09T10:49:33.557Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3672" target="_blank" rel="noopener">BZOJ3672</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>$O(n^2)$的暴力dp很好想<br>$$<br>f[i] = min(f[j] + (dis[i] - dis[j])\times p_i + q_i),\quad dis[i] - dis[j] &lt;= l_i<br>$$<br>如果在一个序列上的话，这应该是一个经典的斜率优化，对于任意$ a &lt; b $，若要求对于i来说决策a比b更优，则<br>$$<br>p_i &lt; \frac{f[b] - f[a]}{dis[b] - dis[a]}<br>$$<br>由于p不具有单调性，因此不能从队头删除元素，而应在队列中二分查找最优的决策<br>再加上对于决策的位置有l的限制，因此还需要用线段树</p><p>那么对于本题，在树上进行转移，就需要树链剖分了<br>剖分后的线段树上每个节点开一个vector，维护这个节点的决策集合，一个原树上的点最多出现在log个vector中，因此空间复杂度是对的<br>一遍dfs进行转移，维护一个根到当前节点的栈，转移时通过跳top将所有满足小于等于$l_x$的点分割成线段树上的区间，在线段树的各个vector上二分查找最优决策，取最小值，得到当前dp值，再在线段树上进行修改，最多修改log个节点，每个节点把队尾不优的决策弹出，再压如新决策<br>网上的题解都把这个方法叫树剖线段树维护凸包</p><p>下面的代码洛谷上可过，BZOJ上会RE<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot, n, fa[maxn];</span><br><span class="line">ll edge[maxn * <span class="number">2</span>], P[maxn], q[maxn], L[maxn], dis[maxn], f[maxn];</span><br><span class="line"><span class="keyword">int</span> son[maxn], top[maxn], seg[maxn], rev[maxn], sz[maxn], cnt, sta[maxn], Tp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[maxn * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll z)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1.0</span> * (f[y] - f[x]) / (dis[y] - dis[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x]) &#123;</span><br><span class="line">        dis[ver[i]] = dis[x] + edge[i];</span><br><span class="line">        dfs1(ver[i]);</span><br><span class="line">        <span class="keyword">if</span>(sz[ver[i]] &gt; sz[son[x]]) son[x] = ver[i];</span><br><span class="line">        sz[x] += sz[ver[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    seg[x] = ++cnt; rev[cnt] = x;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) top[son[x]] = top[x], dfs2(son[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x] &amp;&amp; ver[i] != son[x]) &#123;</span><br><span class="line">        top[ver[i]] = ver[i];</span><br><span class="line">        dfs2(ver[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tail = vec[p].size();</span><br><span class="line">    <span class="keyword">while</span>(tail &gt; <span class="number">1</span> &amp;&amp; slope(rev[pos], vec[p][tail<span class="number">-1</span>]) &lt; slope(vec[p][tail<span class="number">-1</span>], vec[p][tail<span class="number">-2</span>])) tail--, vec[p].pop_back();</span><br><span class="line">    vec[p].push_back(rev[pos]);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) change(p*<span class="number">2</span>, l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = vec[p].size() - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(slope(vec[p][mid], vec[p][mid - <span class="number">1</span>]) &lt; (<span class="keyword">double</span>)P[i]) res = mid, l = mid + <span class="number">1</span>; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> v = vec[p][res];</span><br><span class="line">    <span class="keyword">return</span> f[v] + (dis[i] - dis[v]) * P[i] + q[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> calc(p, i); </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; ll res = inf;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) res = min(res, query(p*<span class="number">2</span>, l, mid, L, R, i));</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) res = min(res, query(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, i));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fly</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = x; x = fa[x];</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[des]) &#123;</span><br><span class="line">        f[X] = min(f[X], query(<span class="number">1</span>, <span class="number">1</span>, n, seg[top[x]], seg[x], X));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    f[X] = min(f[X], query(<span class="number">1</span>, <span class="number">1</span>, n, seg[des], seg[x], X));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sta[++Tp] = x;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = Tp; </span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[x] - dis[mid] &gt; L[x]) l = mid + <span class="number">1</span>; <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        Fly(x, l);</span><br><span class="line">    &#125;</span><br><span class="line">    change(<span class="number">1</span>, <span class="number">1</span>, n, seg[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x]) DFS(ver[i]);</span><br><span class="line">    Tp--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;z); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld%lld%lld"</span>, &amp;fa[i], &amp;z, &amp;P[i], &amp;q[i], &amp;L[i]);</span><br><span class="line">        add(i, fa[i], z), add(fa[i], i, z);</span><br><span class="line">    &#125;</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs1(<span class="number">1</span>); dfs2(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)); f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    DFS(<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3672&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3672&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;$O(n^2)$的暴力dp很好想&lt;br&gt;$$&lt;br&gt;f[i] = min(f[j] + (dis[i] - dis[j])\times p_i + q_i),\quad dis[i] - dis[j] &amp;lt;= l_i&lt;br&gt;$$&lt;br&gt;如果在一个序列上的话，这应该是一个经典的斜率优化，对于任意$ a &amp;lt; b $，若要求对于i来说决策a比b更优，则&lt;br&gt;$$&lt;br&gt;p_i &amp;lt; \frac{f[b] - f[a]}{dis[b] - dis[a]}&lt;br&gt;$$&lt;br&gt;由于p不具有单调性，因此不能从队头删除元素，而应在队列中二分查找最优的决策&lt;br&gt;再加上对于决策的位置有l的限制，因此还需要用线段树&lt;/p&gt;
&lt;p&gt;那么对于本题，在树上进行转移，就需要树链剖分了&lt;br&gt;剖分后的线段树上每个节点开一个vector，维护这个节点的决策集合，一个原树上的点最多出现在log个vector中，因此空间复杂度是对的&lt;br&gt;一遍dfs进行转移，维护一个根到当前节点的栈，转移时通过跳top将所有满足小于等于$l_x$的点分割成线段树上的区间，在线段树的各个vector上二分查找最优决策，取最小值，得到当前dp值，再在线段树上进行修改，最多修改log个节点，每个节点把队尾不优的决策弹出，再压如新决策&lt;br&gt;网上的题解都把这个方法叫树剖线段树维护凸包&lt;/p&gt;
&lt;p&gt;下面的代码洛谷上可过，BZOJ上会RE&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="动态规划" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树链剖分" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="斜率优化" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="线段树" scheme="http://ratexxxx.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="树链剖分" scheme="http://ratexxxx.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="斜率优化" scheme="http://ratexxxx.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4543 [POI2014]Hotel加强版</title>
    <link href="http://ratexxxx.github.io/2019/07/17/BZOJ4543-POI2014-Hotel%E5%8A%A0%E5%BC%BA%E7%89%88/"/>
    <id>http://ratexxxx.github.io/2019/07/17/BZOJ4543-POI2014-Hotel加强版/</id>
    <published>2019-07-17T04:59:42.000Z</published>
    <updated>2019-08-30T12:37:52.665Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4543" target="_blank" rel="noopener">BZOJ4543</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>长链剖分第一题<br>考虑答案只可能后两种情况</p><ol><li>一个点往下三个分支</li><li>一个点往下两个分支，其中一个再往下有两个分支</li></ol><p>考虑都在最上方的LCA处统计，鉴于第二种比较特殊，我们定义两个dp数组</p><p>令$f[i][j]$表示i的子树中与i距离为j的点数<br>令$g[i][j]$表示i的子树中，两个点到其lca距离均为d，且lca到i的距离为$d - j$的点对数</p><p>这样就可以在最上方的LCA由f和g拼接出两种情况，转移方程如下：(v是u的儿子)<br>$$<br>f[u][j] += f[v][j-1]<br>$$$$<br>g[u][j] += g[v][j+1]<br>$$$$<br>ans += f[u][j-1] \times g[v][j] + f[v][j] \times g[u][j+1]<br>$$$$<br>ans += g[u][0]<br>$$<br>这样的做法是$O(n^2)$的<br>可以使用长链剖分优化到$ O(nlogn) $<br>每个点的f和g数组可以由重儿子继承来，再讲请儿子合并进去<br>巧妙的地方在于，合并轻儿子时并不需要枚举满的第二维，只要枚举轻儿子的链长，因为轻儿子向下的最长长度就是链长。因此总共枚举的第二维实际上是$ O(n) $的<br>正是这一点巧妙地保证了时间复杂度。从重儿子继承只是其中必要的一环，优化的关键在于转移是可以与深度有关的。<br>不仅仅是状态与深度有关，转移也要与深度有关</p><p>还有关于如何从重儿子继承的问题，可以直接复制指针，但数组指针无法修改，单单是一个指针的话没有内存是无法下标访问的，因此事先为所有点声明好空间（也是$O(n)$)的。代码中的id变量的作用就是为每个指针预留下足够的空间。<br>具体可以研究代码，是一个新技巧。<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> son[maxn], mx[maxn], *f[maxn], *g[maxn], fa[maxn], tmp[maxn * <span class="number">6</span>], *id = tmp;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">    fa[x] = pa; mx[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) &#123;</span><br><span class="line">        dfs(ver[i], x);</span><br><span class="line">        <span class="keyword">if</span>(mx[ver[i]] + <span class="number">1</span> &gt; mx[x]) son[x] = ver[i], mx[x] = mx[ver[i]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Give</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; f[x] = id; id += mx[x] + <span class="number">1</span>; id += mx[x] + <span class="number">1</span>; g[x] = id; id += mx[x] + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) f[son[x]] = f[x] + <span class="number">1</span>, g[son[x]] = g[x] - <span class="number">1</span>, dp(son[x]);</span><br><span class="line">    f[x][<span class="number">0</span>] = <span class="number">1</span>; ans += g[x][<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x] &amp;&amp; ver[i] != son[x])&#123;</span><br><span class="line">        Give(ver[i]); dp(ver[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mx[ver[i]]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j) ans += f[x][j<span class="number">-1</span>] * g[ver[i]][j];</span><br><span class="line">            ans += g[x][j+<span class="number">1</span>] * f[ver[i]][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mx[ver[i]]; j++) &#123;</span><br><span class="line">            g[x][j+<span class="number">1</span>] += f[x][j+<span class="number">1</span>] * f[ver[i]][j];</span><br><span class="line">            <span class="keyword">if</span>(j) g[x][j<span class="number">-1</span>] += g[ver[i]][j];</span><br><span class="line">            f[x][j+<span class="number">1</span>] += f[ver[i]][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>); Give(<span class="number">1</span>); dp(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=4543&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ4543&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;长链剖分第一题&lt;br&gt;考虑答案只可能后两种情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个点往下三个分支&lt;/li&gt;
&lt;li&gt;一个点往下两个分支，其中一个再往下有两个分支&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;考虑都在最上方的LCA处统计，鉴于第二种比较特殊，我们定义两个dp数组&lt;/p&gt;
&lt;p&gt;令$f[i][j]$表示i的子树中与i距离为j的点数&lt;br&gt;令$g[i][j]$表示i的子树中，两个点到其lca距离均为d，且lca到i的距离为$d - j$的点对数&lt;/p&gt;
&lt;p&gt;这样就可以在最上方的LCA由f和g拼接出两种情况，转移方程如下：(v是u的儿子)&lt;br&gt;$$&lt;br&gt;f[u][j] += f[v][j-1]&lt;br&gt;$$$$&lt;br&gt;g[u][j] += g[v][j+1]&lt;br&gt;$$$$&lt;br&gt;ans += f[u][j-1] \times g[v][j] + f[v][j] \times g[u][j+1]&lt;br&gt;$$$$&lt;br&gt;ans += g[u][0]&lt;br&gt;$$&lt;br&gt;这样的做法是$O(n^2)$的&lt;br&gt;可以使用长链剖分优化到$ O(nlogn) $&lt;br&gt;每个点的f和g数组可以由重儿子继承来，再讲请儿子合并进去&lt;br&gt;巧妙的地方在于，合并轻儿子时并不需要枚举满的第二维，只要枚举轻儿子的链长，因为轻儿子向下的最长长度就是链长。因此总共枚举的第二维实际上是$ O(n) $的&lt;br&gt;正是这一点巧妙地保证了时间复杂度。从重儿子继承只是其中必要的一环，优化的关键在于转移是可以与深度有关的。&lt;br&gt;不仅仅是状态与深度有关，转移也要与深度有关&lt;/p&gt;
&lt;p&gt;还有关于如何从重儿子继承的问题，可以直接复制指针，但数组指针无法修改，单单是一个指针的话没有内存是无法下标访问的，因此事先为所有点声明好空间（也是$O(n)$)的。代码中的id变量的作用就是为每个指针预留下足够的空间。&lt;br&gt;具体可以研究代码，是一个新技巧。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="动态规划" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树形dp" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2dp/"/>
    
      <category term="长链剖分" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"/>
    
    
      <category term="树形dp" scheme="http://ratexxxx.github.io/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
      <category term="长链剖分" scheme="http://ratexxxx.github.io/tags/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1488 [HNOI2009]图的同构</title>
    <link href="http://ratexxxx.github.io/2019/07/15/BZOJ1488-HNOI2009-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84/"/>
    <id>http://ratexxxx.github.io/2019/07/15/BZOJ1488-HNOI2009-图的同构/</id>
    <published>2019-07-15T11:50:59.000Z</published>
    <updated>2019-08-30T12:21:57.010Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://lydsy.com/JudgeOnline/problem.php?id=1488" target="_blank" rel="noopener">BZOJ1488</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意求N个点不同构图的个数<br>显然要用Burnside引理<br>思路就是求出每个置换的循环个数，求2的幂的平均值<br>需要注意求的是<strong>点</strong>置换下的<strong>边</strong>循环<br>分情况讨论：</p><ol><li><p>一个长度为$x$的点的循环内部有$\lfloor\frac{x}{2}\rfloor$个边的循环。</p></li><li><p>两个长度分别为$x$和$y$的点的循环之间有$gcd(x,y)$个边的循环</p></li></ol><p>这个画画图就能明白，对于第一点，实际上是不同“长度”的边，对于第二点，每个循环节的长度一定是lcm，因此个数就是gcd</p><p>但是置换共有$n!$个，无法枚举<br>事实上我们只需要知道每个循环的大小，求出来后乘以方案数即可。因此考虑枚举n的拆分，求出每种拆分的方案数。设共k个循环，长度分别为$a[i]$，每种长度有$c[i]$个，则方案数为：<br>$$<br>\frac{n!}{\Pi a[i]\Pi c[i]！}<br>$$<br>因为长度相同的要除以排列数，每一个循环里会有$a[i]$个是循环相同的，也要除掉</p><p>最后，本题卡常，gcd和逆元都要预处理，少了一个都会TLE（亲身实践）<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">65</span>, mod = <span class="number">997</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn], cnt, fac[maxn], c[maxn], ans, rev[maxn], rfac[maxn], g[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">int</span> res = <span class="number">1</span>; <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod; <span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">if</span>(!x) <span class="keyword">return</span> y; <span class="keyword">return</span> gcd(y % x, x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = fac[n], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c[i]; j++) a[++cnt] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) tmp = tmp * rev[a[i]] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(c[i]) tmp = tmp * rfac[c[i]] % mod;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) num += a[i] / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= cnt; j++) num += g[a[i]][a[j]];</span><br><span class="line">    ans = (ans + tmp * Power(<span class="number">2</span>, num) % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) &#123; c[<span class="number">1</span>] = n - s; calc(); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s + i * x &lt;= n; i++) c[x] = i, dfs(x - <span class="number">1</span>, s + i * x), c[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = fac[i<span class="number">-1</span>] * i % mod, rfac[i] = Power(fac[i], mod - <span class="number">2</span>);</span><br><span class="line">    rev[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) rev[i] = (mod - mod / i) % mod * rev[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) g[i][j] = gcd(i, j);</span><br><span class="line">    dfs(n, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * Power(fac[n], mod - <span class="number">2</span>) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://lydsy.com/JudgeOnline/problem.php?id=1488&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1488&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题意求N个点不同构图的个数&lt;br&gt;显然要用Burnside引理&lt;br&gt;思路就是求出每个置换的循环个数，求2的幂的平均值&lt;br&gt;需要注意求的是&lt;strong&gt;点&lt;/strong&gt;置换下的&lt;strong&gt;边&lt;/strong&gt;循环&lt;br&gt;分情况讨论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个长度为$x$的点的循环内部有$\lfloor\frac{x}{2}\rfloor$个边的循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两个长度分别为$x$和$y$的点的循环之间有$gcd(x,y)$个边的循环&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个画画图就能明白，对于第一点，实际上是不同“长度”的边，对于第二点，每个循环节的长度一定是lcm，因此个数就是gcd&lt;/p&gt;
&lt;p&gt;但是置换共有$n!$个，无法枚举&lt;br&gt;事实上我们只需要知道每个循环的大小，求出来后乘以方案数即可。因此考虑枚举n的拆分，求出每种拆分的方案数。设共k个循环，长度分别为$a[i]$，每种长度有$c[i]$个，则方案数为：&lt;br&gt;$$&lt;br&gt;\frac{n!}{\Pi a[i]\Pi c[i]！}&lt;br&gt;$$&lt;br&gt;因为长度相同的要除以排列数，每一个循环里会有$a[i]$个是循环相同的，也要除掉&lt;/p&gt;
&lt;p&gt;最后，本题卡常，gcd和逆元都要预处理，少了一个都会TLE（亲身实践）&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="组合" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"/>
    
      <category term="Burnside引理" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/Burnside%E5%BC%95%E7%90%86/"/>
    
    
      <category term="组合数学" scheme="http://ratexxxx.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Burnside引理" scheme="http://ratexxxx.github.io/tags/Burnside%E5%BC%95%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2655 calc</title>
    <link href="http://ratexxxx.github.io/2019/07/15/BZOJ2655-calc/"/>
    <id>http://ratexxxx.github.io/2019/07/15/BZOJ2655-calc/</id>
    <published>2019-07-15T09:27:05.000Z</published>
    <updated>2019-08-30T12:29:32.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2655" target="_blank" rel="noopener">BZOJ2655</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>我真是见识到了插值这个东西的好处<br>第一步的想法是直接退出一个式子，这样最好，如果没有两两不同的限制，那么式子很简单就是$[\frac{A(A+1)}{2}]^n$<br>多了不同这个限制，那么容斥就好了，总方案$-$一对相同$+$两对相同$-…$<br>这样写出式子看看<br>$$<br>(\sum_{i=1}^Ai)^n-C_{n-1}^1(\sum_{i=1}^Ai)^{n-2}(\sum_{i=1}^Ai^2)+…<br>$$<br>但是第三项开始就不好写了，因为可能是三连等，也可能有两对分别相同<br>然而我们可以发现不管怎么写，这个式子始终是一个关于A的$2n$次多项式。每一项都是这个次数。<br>然后用插值就好了，根本不用考虑什么烦人的容斥，反正插出来都一样<br>这样A再大都可以被降到2n的级别，考虑暴力做法算$0…2n$的函数值就可以了<br>实在是太神了，感觉什么都没做，就解决了容斥的问题！<br>暴力的部分用dp就可以了，令$f[i][j]$表示j个小于等于i的正整数的所有序列的值得和，则<br>$$<br>f[i][j] = f[i-1][j-1] \times i \times j + f[i-1][j]<br>$$<br>意思是，如果j个数中有i，共有j种情况，每种的值都会乘以i，从f[i-1][j-1]转移，否则和f[i-1][j]相同</p><p>感觉如果发现某题的式子是个多项式，那么这题就可以转化为暴力题了<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll mod, A, n, f[maxn*<span class="number">2</span>][maxn], ans;</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;A, &amp;n, &amp;mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            f[i][j] = (f[i<span class="number">-1</span>][j<span class="number">-1</span>] * i % mod * j % mod + f[i<span class="number">-1</span>][j]) % mod;</span><br><span class="line">    <span class="keyword">if</span>(A &lt;= n * <span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[A][n]); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        ll s1 = <span class="number">1</span>, s2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n * <span class="number">2</span>; j++) <span class="keyword">if</span>(i != j) </span><br><span class="line">            s1 = (A - j + mod) % mod * s1 % mod, s2 = (i - j + mod) % mod * s2 % mod;</span><br><span class="line">        ans = (ans + s1 * f[i][n] % mod * Power(s2, mod - <span class="number">2</span>) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2655&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2655&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;我真是见识到了插值这个东西的好处&lt;br&gt;第一步的想法是直接退出一个式子，这样最好，如果没有两两不同的限制，那么式子很简单就是$[\frac{A(A+1)}{2}]^n$&lt;br&gt;多了不同这个限制，那么容斥就好了，总方案$-$一对相同$+$两对相同$-…$&lt;br&gt;这样写出式子看看&lt;br&gt;$$&lt;br&gt;(\sum_{i=1}^Ai)^n-C_{n-1}^1(\sum_{i=1}^Ai)^{n-2}(\sum_{i=1}^Ai^2)+…&lt;br&gt;$$&lt;br&gt;但是第三项开始就不好写了，因为可能是三连等，也可能有两对分别相同&lt;br&gt;然而我们可以发现不管怎么写，这个式子始终是一个关于A的$2n$次多项式。每一项都是这个次数。&lt;br&gt;然后用插值就好了，根本不用考虑什么烦人的容斥，反正插出来都一样&lt;br&gt;这样A再大都可以被降到2n的级别，考虑暴力做法算$0…2n$的函数值就可以了&lt;br&gt;实在是太神了，感觉什么都没做，就解决了容斥的问题！&lt;br&gt;暴力的部分用dp就可以了，令$f[i][j]$表示j个小于等于i的正整数的所有序列的值得和，则&lt;br&gt;$$&lt;br&gt;f[i][j] = f[i-1][j-1] \times i \times j + f[i-1][j]&lt;br&gt;$$&lt;br&gt;意思是，如果j个数中有i，共有j种情况，每种的值都会乘以i，从f[i-1][j-1]转移，否则和f[i-1][j]相同&lt;/p&gt;
&lt;p&gt;感觉如果发现某题的式子是个多项式，那么这题就可以转化为暴力题了&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="动态规划" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="拉格朗日插值" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
    
      <category term="计数dp" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%AE%A1%E6%95%B0dp/"/>
    
    
      <category term="计数dp" scheme="http://ratexxxx.github.io/tags/%E8%AE%A1%E6%95%B0dp/"/>
    
      <category term="拉格朗日插值" scheme="http://ratexxxx.github.io/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ5339 [TJOI2018]教科书般的亵渎</title>
    <link href="http://ratexxxx.github.io/2019/07/14/BZOJ5339-TJOI2018-%E6%95%99%E7%A7%91%E4%B9%A6%E8%88%AC%E7%9A%84%E4%BA%B5%E6%B8%8E/"/>
    <id>http://ratexxxx.github.io/2019/07/14/BZOJ5339-TJOI2018-教科书般的亵渎/</id>
    <published>2019-07-14T13:11:55.000Z</published>
    <updated>2019-09-09T10:33:48.332Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5339" target="_blank" rel="noopener">BZOJ5339</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题面好难理解啊<br>不过多看几遍，再算算样例，也就懂了<br>可以转化为求$ \sum_{i=1}^ni^m $（n，m不是题面中的）<br>经典的自然数幂和问题，有五种经典算法</p><ul><li>伯努利数</li><li>递推</li><li>差分序列</li></ul><p>我使用了另外两种方法</p><h2><span id="拉格朗日插值">拉格朗日插值</span></h2><p>$m$次自然数幂和是一个$m+1$次多项式，可以举$m=1$的例子，容易发现这一点<br>这样将$x=0…m+1$带进去，得到$m+2$个点，然后插值即可<br>暴力做法$O(m^2)$，但由于取的是等间隔的x，因此可以优化到$O(m)$</p><h2><span id="第二类斯特林数">第二类斯特林数</span></h2><p>下文中加点表示降阶函数，也就是下划线<br>第二类斯特林数有生成函数<br>$$<br>x^n=\sum_{i=0}^n<br>\begin{Bmatrix}<br>n \\<br>i \\<br>\end{Bmatrix}x^{i.}<br>$$<br>因此原式可以这样展开<br>$$<br>\sum_{i=0}^ni^m = \sum_{i=0}^n\sum_{j=0}^m<br>\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}i^{j.}<br>$$<br>$$<br>=\sum_{j=0}^m\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}j!\sum_{i=0}^n\begin{pmatrix}<br>i \\<br>j \\<br>\end{pmatrix}<br>$$<br>$$<br>= \sum_{j=0}^m\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}j!\begin{pmatrix}<br>n + 1 \\<br>j + 1 \\<br>\end{pmatrix}<br>$$<br>$$<br>=\sum_{j=1}^m\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}\frac{(n+1)^{(j+1).}}{j+1}<br>$$<br>然后就可以$O(n^2)$算了<br><a id="more"></a></p><h1><span id="code">Code</span></h1><h2><span id="拉格朗日插值">拉格朗日插值</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">60</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn], pre[maxn], suf[maxn], y[maxn], fac[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    y[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m + <span class="number">1</span>; i++) y[i] = (y[i<span class="number">-1</span>] + Power(i, m)) % mod;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= m + <span class="number">1</span>) <span class="keyword">return</span> y[n];</span><br><span class="line">    pre[<span class="number">0</span>] = n; suf[m + <span class="number">1</span>] = n - m - <span class="number">1</span>; fac[<span class="number">0</span>] = <span class="number">1</span>; suf[m + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) pre[i] = pre[i<span class="number">-1</span>] * (n - i) % mod, fac[i] = fac[i<span class="number">-1</span>] * Power(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i--) suf[i] = suf[i+<span class="number">1</span>] * (n - i) % mod;</span><br><span class="line">    ll res = suf[<span class="number">1</span>] * fac[m + <span class="number">1</span>] % mod * y[<span class="number">0</span>] % mod;</span><br><span class="line">    <span class="keyword">if</span>((m + <span class="number">1</span>) &amp; <span class="number">1</span>) res = (mod - res) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ll tmp = suf[i + <span class="number">1</span>] * pre[i - <span class="number">1</span>] % mod * fac[i] % mod * fac[m + <span class="number">1</span> - i] % mod;</span><br><span class="line">        <span class="keyword">if</span>((m - i + <span class="number">1</span>) &amp; <span class="number">1</span>) tmp = (mod - tmp) % mod;</span><br><span class="line">        res = (res + tmp * y[i] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    ll n, m;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">        a[m + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                ans= (ans + S(a[j] - a[i<span class="number">-1</span>] - <span class="number">1</span>, m + <span class="number">1</span>)) % mod;</span><br><span class="line">                ans = (ans + mod - S(a[j<span class="number">-1</span>] - a[i<span class="number">-1</span>], m + <span class="number">1</span>)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="第二类斯特林数">第二类斯特林数</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">60</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn], pre[maxn], suf[maxn], y[maxn], fac[maxn], s[maxn][maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= m) &#123; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = (res + Power(i, m)) % mod; <span class="keyword">return</span> res; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        ll tmp = s[m][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n - i + <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++) tmp = tmp * j % mod;</span><br><span class="line">        tmp = tmp * Power(i + <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        res = (res + tmp) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    ll n, m;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) s[i][j] = (s[i<span class="number">-1</span>][j<span class="number">-1</span>] + s[i<span class="number">-1</span>][j] * j % mod) % mod;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">        a[m + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                ans= (ans + S(a[j] - a[i<span class="number">-1</span>] - <span class="number">1</span>, m + <span class="number">1</span>)) % mod;</span><br><span class="line">                ans = (ans + mod - S(a[j<span class="number">-1</span>] - a[i<span class="number">-1</span>], m + <span class="number">1</span>)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=5339&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ5339&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题面好难理解啊&lt;br&gt;不过多看几遍，再算算样例，也就懂了&lt;br&gt;可以转化为求$ \sum_{i=1}^ni^m $（n，m不是题面中的）&lt;br&gt;经典的自然数幂和问题，有五种经典算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伯努利数&lt;/li&gt;
&lt;li&gt;递推&lt;/li&gt;
&lt;li&gt;差分序列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我使用了另外两种方法&lt;/p&gt;
&lt;h2 id=&quot;拉格朗日插值&quot;&gt;&lt;a href=&quot;#拉格朗日插值&quot; class=&quot;headerlink&quot; title=&quot;拉格朗日插值&quot;&gt;&lt;/a&gt;拉格朗日插值&lt;/h2&gt;&lt;p&gt;$m$次自然数幂和是一个$m+1$次多项式，可以举$m=1$的例子，容易发现这一点&lt;br&gt;这样将$x=0…m+1$带进去，得到$m+2$个点，然后插值即可&lt;br&gt;暴力做法$O(m^2)$，但由于取的是等间隔的x，因此可以优化到$O(m)$&lt;/p&gt;
&lt;h2 id=&quot;第二类斯特林数&quot;&gt;&lt;a href=&quot;#第二类斯特林数&quot; class=&quot;headerlink&quot; title=&quot;第二类斯特林数&quot;&gt;&lt;/a&gt;第二类斯特林数&lt;/h2&gt;&lt;p&gt;下文中加点表示降阶函数，也就是下划线&lt;br&gt;第二类斯特林数有生成函数&lt;br&gt;$$&lt;br&gt;x^n=\sum_{i=0}^n&lt;br&gt;\begin{Bmatrix}&lt;br&gt;n \\&lt;br&gt;i \\&lt;br&gt;\end{Bmatrix}x^{i.}&lt;br&gt;$$&lt;br&gt;因此原式可以这样展开&lt;br&gt;$$&lt;br&gt;\sum_{i=0}^ni^m = \sum_{i=0}^n\sum_{j=0}^m&lt;br&gt;\begin{Bmatrix}&lt;br&gt;m \\&lt;br&gt;j \\&lt;br&gt;\end{Bmatrix}i^{j.}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;=\sum_{j=0}^m\begin{Bmatrix}&lt;br&gt;m \\&lt;br&gt;j \\&lt;br&gt;\end{Bmatrix}j!\sum_{i=0}^n\begin{pmatrix}&lt;br&gt;i \\&lt;br&gt;j \\&lt;br&gt;\end{pmatrix}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;= \sum_{j=0}^m\begin{Bmatrix}&lt;br&gt;m \\&lt;br&gt;j \\&lt;br&gt;\end{Bmatrix}j!\begin{pmatrix}&lt;br&gt;n + 1 \\&lt;br&gt;j + 1 \\&lt;br&gt;\end{pmatrix}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;=\sum_{j=1}^m\begin{Bmatrix}&lt;br&gt;m \\&lt;br&gt;j \\&lt;br&gt;\end{Bmatrix}\frac{(n+1)^{(j+1).}}{j+1}&lt;br&gt;$$&lt;br&gt;然后就可以$O(n^2)$算了&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="拉格朗日插值" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
    
      <category term="斯特林数" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
    
      <category term="拉格朗日插值" scheme="http://ratexxxx.github.io/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
    
      <category term="自然数幂和" scheme="http://ratexxxx.github.io/tags/%E8%87%AA%E7%84%B6%E6%95%B0%E5%B9%82%E5%92%8C/"/>
    
      <category term="第二类斯特林数" scheme="http://ratexxxx.github.io/tags/%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2806 [Ctsc2012]Cheat</title>
    <link href="http://ratexxxx.github.io/2019/07/13/BZOJ2806-Ctsc2012-Cheat/"/>
    <id>http://ratexxxx.github.io/2019/07/13/BZOJ2806-Ctsc2012-Cheat/</id>
    <published>2019-07-13T09:25:12.000Z</published>
    <updated>2019-08-30T12:30:32.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2806" target="_blank" rel="noopener">BZOJ2806</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>容易发现，L具有单调性，因此可以二分答案<br>考虑如何判定，分段，长度有限制，容易想到经典的1D1D动规，方程如下：<br>$$<br>f[i] = max(f[j] + i - j, f[i-1]),\ i - maxlen[i] \leq j \leq i - L<br>$$<br>其中maxlen表示以i为右端点能够匹配的最长子串<br>这个方程明显可以用单调队列优化，由于左右都有限制，因此每次入队入的是很久之前算的那个位置<br><del>我最开始的写法不知为何是错的，不知为何啊</del><br>剩下的就是怎样算maxlen<br>将所有的模板串建成广义后缀自动机，之后所有的maxlen可以用一个自动机上的指针一遍预处理出来，就是每次如果无法向下转移就跳父亲，直到可以走DAG为止，跳完父亲len要用val更新，走转移边就是len++，这样才能保证正确</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2200010</span>;</span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">2</span>], par[maxn], val[maxn], rt = <span class="number">1</span>, cnt = <span class="number">1</span>, las = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np = ++cnt, p = las; val[np] = val[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line">    <span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][x];</span><br><span class="line">        <span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line">            ch[nq][<span class="number">0</span>] = ch[q][<span class="number">0</span>]; ch[nq][<span class="number">1</span>] = ch[q][<span class="number">1</span>];</span><br><span class="line">            par[nq] = par[q];</span><br><span class="line">            par[q] = par[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    las = np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> ml[maxn], f[maxn], q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] - x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) f[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; calc(q[tail]) &lt; calc(i - l)) tail--;</span><br><span class="line">        q[++tail] = i - l;</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; q[head] &lt; i - ml[i]) head++;</span><br><span class="line">        <span class="keyword">if</span>(head &lt;= tail) f[i] = max(f[i], calc(q[head]) + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n] * <span class="number">10</span> &gt;= n * <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(str); j++) extend(str[j] - <span class="string">'0'</span>);</span><br><span class="line">        las = rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>); m = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cur = rt, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = str[j] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">while</span>(cur &amp;&amp; !ch[cur][u]) cur = par[cur], len = val[cur];</span><br><span class="line">            <span class="keyword">if</span>(!cur) &#123; ml[j] = <span class="number">0</span>; cur = rt; len = <span class="number">0</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            cur = ch[cur][u]; len++;</span><br><span class="line">            ml[j] = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = m;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid, m)) l = mid; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2806&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2806&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;容易发现，L具有单调性，因此可以二分答案&lt;br&gt;考虑如何判定，分段，长度有限制，容易想到经典的1D1D动规，方程如下：&lt;br&gt;$$&lt;br&gt;f[i] = max(f[j] + i - j, f[i-1]),\ i - maxlen[i] \leq j \leq i - L&lt;br&gt;$$&lt;br&gt;其中maxlen表示以i为右端点能够匹配的最长子串&lt;br&gt;这个方程明显可以用单调队列优化，由于左右都有限制，因此每次入队入的是很久之前算的那个位置&lt;br&gt;&lt;del&gt;我最开始的写法不知为何是错的，不知为何啊&lt;/del&gt;&lt;br&gt;剩下的就是怎样算maxlen&lt;br&gt;将所有的模板串建成广义后缀自动机，之后所有的maxlen可以用一个自动机上的指针一遍预处理出来，就是每次如果无法向下转移就跳父亲，直到可以走DAG为止，跳完父亲len要用val更新，走转移边就是len++，这样才能保证正确&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="http://ratexxxx.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://ratexxxx.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="单调队列优化" scheme="http://ratexxxx.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="后缀自动机" scheme="http://ratexxxx.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="单调队列" scheme="http://ratexxxx.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3926 [Zjoi2015]诸神眷顾的幻想乡</title>
    <link href="http://ratexxxx.github.io/2019/07/12/BZOJ3926-Zjoi2015-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/"/>
    <id>http://ratexxxx.github.io/2019/07/12/BZOJ3926-Zjoi2015-诸神眷顾的幻想乡/</id>
    <published>2019-07-12T14:44:52.000Z</published>
    <updated>2019-08-30T12:35:02.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3926" target="_blank" rel="noopener">BZOJ3926</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>20min 1A庆祝一下<br>国家队论文写过一个trie上SAM的科技<br>其实可以类比广义后缀自动机加入多个串，trie树上无非是每个点插入前将las移到其父亲对应的节点<br>本题由于叶子不超过20个，以每个叶子为根，分别遍历一遍trie，全部加入一个广义自动机中，累计每个节点的max-min+1即可<br>由于所有有向路径都可以看成以一个叶子为根的一个直的路径（也就是trie上的“子串”），因此正确性可以保证<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, C, col[maxn], head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot;</span><br><span class="line"><span class="keyword">int</span> du[maxn], cnt = <span class="number">1</span>, rt = <span class="number">1</span>, ch[maxn * <span class="number">40</span>][<span class="number">10</span>], par[maxn * <span class="number">40</span>], val[maxn * <span class="number">40</span>], pos[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np = ++cnt; val[np] = val[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line">    <span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][x];</span><br><span class="line">        <span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span>(ch[nq]));</span><br><span class="line">            par[nq] = par[q];</span><br><span class="line">            par[q] = par[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    pos[x] = extend(col[x], pos[fa]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa) dfs(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;C);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x), du[x]++, du[y]++;</span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(du[i] == <span class="number">1</span>) dfs(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) ans += val[i] - val[par[i]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3926&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3926&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;20min 1A庆祝一下&lt;br&gt;国家队论文写过一个trie上SAM的科技&lt;br&gt;其实可以类比广义后缀自动机加入多个串，trie树上无非是每个点插入前将las移到其父亲对应的节点&lt;br&gt;本题由于叶子不超过20个，以每个叶子为根，分别遍历一遍trie，全部加入一个广义自动机中，累计每个节点的max-min+1即可&lt;br&gt;由于所有有向路径都可以看成以一个叶子为根的一个直的路径（也就是trie上的“子串”），因此正确性可以保证&lt;br&gt;
    
    </summary>
    
      <category term="字符串" scheme="http://ratexxxx.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://ratexxxx.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
      <category term="后缀自动机" scheme="http://ratexxxx.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="trie" scheme="http://ratexxxx.github.io/tags/trie/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3669 [Noi2014]魔法森林</title>
    <link href="http://ratexxxx.github.io/2019/07/10/BZOJ3669-Noi2014-%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97/"/>
    <id>http://ratexxxx.github.io/2019/07/10/BZOJ3669-Noi2014-魔法森林/</id>
    <published>2019-07-10T09:22:52.000Z</published>
    <updated>2019-08-30T12:33:19.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3669" target="_blank" rel="noopener">BZOJ3669</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>第一想法是二分<br>然而不能二分a+b，更不能二分a或b<br>因此把a和b分开考虑<br>将所有边按照a排序，把b看成边权，一条一条加进去，维护1到n的最大边权最小的路径，随时更新答案<br>容易证明这条路径一定在最小生成树上<br>因此要在加边的过程中维护最小生成树<br>需要支持询问两点路径上的最大边权，以及最大边权所在的是那条边<br>加边时若构成环，则查询路径上的最大边，若大于当前边，则cut掉，然后加入当前边，否则跳过<br>若不构成环，就直接加入当前边<br>使用LCT维护，每个点记录子树最大权值及取到的位置，由于LCT只能维护点权，因此为每条边新建一个点，连到边的两个端点上<br>本题一遍过！！！<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>, maxm = <span class="number">100010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, val[maxn + maxm], fa[maxn + maxm], ch[maxn + maxm][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pos[maxn + maxm], sta[maxn + maxm], mx[maxn + maxm], rev[maxn + maxm];</span><br><span class="line"><span class="keyword">int</span> ans = inf;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edg</span> &#123;</span> <span class="keyword">int</span> x, y, a, b; &#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edg x, Edg y)</span> </span>&#123; <span class="keyword">return</span> x.a &lt; y.a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] != x &amp;&amp; ch[fa[x]][<span class="number">0</span>] != x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) <span class="built_in">printf</span>(<span class="string">"%d %d %d %d %d %d\n"</span>, i, fa[i], ch[i][<span class="number">0</span>], ch[i][<span class="number">1</span>], mx[i], rev[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mx[x] = max(val[x], max(mx[ch[x][<span class="number">0</span>]], mx[ch[x][<span class="number">1</span>]]));</span><br><span class="line">    <span class="keyword">if</span>(mx[x] == val[x]) pos[x] = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mx[x] == mx[ch[x][<span class="number">0</span>]]) pos[x] = pos[ch[x][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">else</span> pos[x] = pos[ch[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] ^= <span class="number">1</span>; rev[ch[x][<span class="number">0</span>]] ^= <span class="number">1</span>; rev[ch[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], d = get(x);</span><br><span class="line">    ch[y][d] = ch[x][d ^ <span class="number">1</span>]; fa[ch[y][d]] = y;</span><br><span class="line">    <span class="keyword">if</span>(!isroot(y)) ch[fa[y]][get(y)] = x;</span><br><span class="line">    fa[x] = fa[y];</span><br><span class="line">    ch[x][d ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">    pushup(y); pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>; sta[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) sta[++top] = fa[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i; i--) pushdown(sta[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pa = fa[x]; !isroot(x); pa = fa[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isroot(pa)) rotate(get(x) == get(pa) ? pa : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; x; t = x, x = fa[x]) </span><br><span class="line">        splay(x), ch[x][<span class="number">1</span>] = t, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); rev[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) pushdown(x), x = ch[x][<span class="number">0</span>]; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); access(y); splay(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); ch[y][<span class="number">0</span>] = fa[x] = <span class="number">0</span>; pushup(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); fa[x] = y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;edge[i].x, &amp;edge[i].y, &amp;edge[i].a, &amp;edge[i].b);</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) val[i + n] = mx[i + n] = edge[i].b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = edge[i].x, y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(findroot(x) == findroot(y)) &#123;</span><br><span class="line">            makeroot(x); access(y); splay(y);</span><br><span class="line">            <span class="keyword">if</span>(mx[y] &gt; edge[i].b) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = pos[y];</span><br><span class="line">                <span class="keyword">int</span> lc = edge[tmp - n].x, rc = edge[tmp - n].y;</span><br><span class="line">                cut(tmp, lc); cut(tmp, rc);</span><br><span class="line">                link(x, i + n); link(y, i + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> link(x, i + n), link(y, i + n);</span><br><span class="line">    <span class="comment">//debug(); cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(findroot(<span class="number">1</span>) != findroot(n)) <span class="keyword">continue</span>;</span><br><span class="line">        split(<span class="number">1</span>, n);</span><br><span class="line">        ans = min(ans, edge[i].a + mx[n]);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == inf) ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3669&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3669&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;第一想法是二分&lt;br&gt;然而不能二分a+b，更不能二分a或b&lt;br&gt;因此把a和b分开考虑&lt;br&gt;将所有边按照a排序，把b看成边权，一条一条加进去，维护1到n的最大边权最小的路径，随时更新答案&lt;br&gt;容易证明这条路径一定在最小生成树上&lt;br&gt;因此要在加边的过程中维护最小生成树&lt;br&gt;需要支持询问两点路径上的最大边权，以及最大边权所在的是那条边&lt;br&gt;加边时若构成环，则查询路径上的最大边，若大于当前边，则cut掉，然后加入当前边，否则跳过&lt;br&gt;若不构成环，就直接加入当前边&lt;br&gt;使用LCT维护，每个点记录子树最大权值及取到的位置，由于LCT只能维护点权，因此为每条边新建一个点，连到边的两个端点上&lt;br&gt;本题一遍过！！！&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCT" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LCT/"/>
    
    
      <category term="LCT" scheme="http://ratexxxx.github.io/tags/LCT/"/>
    
      <category term="最小生成树" scheme="http://ratexxxx.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2049 [Sdoi2008]Cave 洞穴勘测</title>
    <link href="http://ratexxxx.github.io/2019/07/08/BZOJ2049-Sdoi2008-Cave-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B/"/>
    <id>http://ratexxxx.github.io/2019/07/08/BZOJ2049-Sdoi2008-Cave-洞穴勘测/</id>
    <published>2019-07-08T13:58:40.000Z</published>
    <updated>2019-08-30T12:26:24.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2049" target="_blank" rel="noopener">BZOJ2049</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>不能再裸的LCT裸题<br>好久没写了，写道题复习一下，再练难的<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>, maxm = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn], ch[maxn][<span class="number">2</span>], rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"><span class="keyword">int</span> sta[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] ^= <span class="number">1</span>; rev[ch[x][<span class="number">0</span>]] ^= <span class="number">1</span>; rev[ch[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = get(x);</span><br><span class="line">    ch[y][z] = ch[x][z ^ <span class="number">1</span>]; fa[ch[y][z]] = y;</span><br><span class="line">    <span class="keyword">if</span>(!isroot(y)) ch[fa[y]][get(y)] = x; </span><br><span class="line">    fa[x] = fa[y];</span><br><span class="line">    ch[x][z ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>; sta[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) sta[++top] = fa[i];</span><br><span class="line">    <span class="keyword">while</span>(top) pushdown(sta[top--]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pa = fa[x]; !isroot(x); pa = fa[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isroot(pa)) rotate(get(x) == get(pa) ? pa : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; x; t = x, x = fa[x])</span><br><span class="line">        splay(x), ch[x][<span class="number">1</span>] = t;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); rev[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) pushdown(x), x = ch[x][<span class="number">0</span>]; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); access(y); splay(y); fa[x] = ch[y][<span class="number">0</span>] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); fa[x] = y; &#125;</span><br><span class="line"><span class="keyword">char</span> o[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, o, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'C'</span>) link(x, y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'D'</span>) cut(x, y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'Q'</span>) <span class="built_in">printf</span>(findroot(x) == findroot(y) ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2049&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2049&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;不能再裸的LCT裸题&lt;br&gt;好久没写了，写道题复习一下，再练难的&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCT" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LCT/"/>
    
    
      <category term="LCT" scheme="http://ratexxxx.github.io/tags/LCT/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2729 [HNOI2012]排队</title>
    <link href="http://ratexxxx.github.io/2019/07/08/BZOJ2729-HNOI2012-%E6%8E%92%E9%98%9F/"/>
    <id>http://ratexxxx.github.io/2019/07/08/BZOJ2729-HNOI2012-排队/</id>
    <published>2019-07-08T04:47:19.000Z</published>
    <updated>2019-08-30T12:30:13.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2729" target="_blank" rel="noopener">BZOJ2729</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>插板法<br>以男生为基准，先插老师，再插女生<br>若老师之间有男生，就是n插2，再插m<br>若老师之间无男生，则之间只有一个女生，看成一个男生，n+1插m-1<br>答案为<br>$$<br>n!A_{n+1}^2A_{n+3}^m + 2m(n+1)!A_{n+2}^{m-1}<br>$$<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bigint</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> len, a[maxn * <span class="number">1000</span>];</span><br><span class="line">&#125;ans, ans1, ans2;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> += (bigint &amp;x, bigint &amp;y) &#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">x.len = max(x.len, y.len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++) </span><br><span class="line">x.a[i] += y.a[i] + t, t = x.a[i] / <span class="number">10</span>, x.a[i] %= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(t) x.a[++x.len] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> *= (bigint &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++) </span><br><span class="line">x.a[i] *= y, x.a[i] += t, t = x.a[i] / <span class="number">10</span>, x.a[i] %= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(t) x.a[++x.len] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(bigint &amp;x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x.len; i; i--) <span class="built_in">printf</span>(<span class="string">"%d"</span>, x.a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">ans1.len = <span class="number">1</span>; ans1.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">ans2 = ans1;</span><br><span class="line">ans1 *= n + <span class="number">1</span>; ans1 *= n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans1 *= n + <span class="number">4</span> - i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans1 *= i;</span><br><span class="line">ans2 *= <span class="number">2</span> * m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) ans2 *= n + <span class="number">3</span> - i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) ans2 *= i;</span><br><span class="line">ans1 += ans2;</span><br><span class="line">print(ans1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2729&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2729&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;插板法&lt;br&gt;以男生为基准，先插老师，再插女生&lt;br&gt;若老师之间有男生，就是n插2，再插m&lt;br&gt;若老师之间无男生，则之间只有一个女生，看成一个男生，n+1插m-1&lt;br&gt;答案为&lt;br&gt;$$&lt;br&gt;n!A_{n+1}^2A_{n+3}^m + 2m(n+1)!A_{n+2}^{m-1}&lt;br&gt;$$&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="组合" scheme="http://ratexxxx.github.io/categories/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"/>
    
    
      <category term="组合数学" scheme="http://ratexxxx.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
