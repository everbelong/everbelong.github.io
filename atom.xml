<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>everbelong</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-22T07:52:25.544Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>everbelong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ1926 粟粟的书架</title>
    <link href="http://yoursite.com/2019/01/22/BZOJ1926-%E7%B2%9F%E7%B2%9F%E7%9A%84%E4%B9%A6%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/01/22/BZOJ1926-粟粟的书架/</id>
    <published>2019-01-22T07:22:56.000Z</published>
    <updated>2019-01-22T07:52:25.544Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1926" target="_blank" rel="noopener">BZOJ1926</a></p></blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>幸福幼儿园B29班的粟粟是一个聪明机灵、乖巧可爱的小朋友，她的爱好是画画和读书，尤其喜欢Thomas H. Cormen的文章。粟粟家中有一个R行C列的巨型书架，书架的每一个位置都摆有一本书，上数第i行、左数第j列摆放的书有Pi,j页厚。</p><p>粟粟每天除了读书之外，还有一件必不可少的工作就是摘苹果，她每天必须摘取一个指定的苹果。粟粟家果树上的苹果有的高、有的低，但无论如何凭粟粟自己的个头都难以摘到。不过她发现，如果在脚下放上几本书，就可以够着苹果；她同时注意到，对于第i天指定的那个苹果，只要她脚下放置书的总页数之和不低于Hi，就一定能够摘到。</p><p>由于书架内的书过多，父母担心粟粟一天内就把所有书看完而耽误了上幼儿园，于是每天只允许粟粟在一个特定区域内拿书。这个区域是一个矩形，第i天给定区域的左上角是上数第x1i行的左数第y1i本书，右下角是上数第x2i行的左数第y2i本书。换句话说，粟粟在这一天，只能在这﹙x2i－x1i＋1﹚×﹙y2i－y1i＋1﹚本书中挑选若干本垫在脚下，摘取苹果。</p><p>粟粟每次取书时都能及时放回原位，并且她的书架不会再撤下书目或换上新书，摘苹果的任务会一直持续M天。给出每本书籍的页数和每天的区域限制及采摘要求，请你告诉粟粟，她每天至少拿取多少本书，就可以摘到当天指定的苹果。<br><a id="more"></a></p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行是三个正整数R，C，M。<br>接下来是一个R行C列的矩阵，从上到下、从左向右依次给出了每本书的页数Pi，j。<br>接下来M行，第i行给出正整数x1i，y1i，x2i，y2i，Hi，表示第i天的指定区域是﹙x1i，y1i﹚与﹙x2i，y2i﹚间<br>的矩形，总页数之和要求不低于Hi。<br>保证1≤x1i≤x2i≤R，1≤y1i≤y2i≤C。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>有M行，第i 行回答粟粟在第 i 天时为摘到苹果至少需要 拿取多少本书。如果即使取走所有书都无法摘到苹果，<br>则在该行输出“Poor QLW” （不含引号）。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>5 5 7<br>14 15 9 26 53<br>58 9 7 9 32<br>38 46 26 43 38<br>32 7 9 50 28<br>8 41 9 7 17<br>1 2 5 3 139<br>3 1 5 5 399<br>3 3 4 5 91<br>4 1 4 1 33<br>1 3 5 4 185<br>3 3 4 3 23<br>3 1 3 3 108 </p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>6<br>15<br>2<br>Poor QLW<br>9<br>1<br>3 </p><h1 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h1><p>对于 10%的数据，满足 R, C≤10；<br>对于 20%的数据，满足 R, C≤40；<br>对于 50%的数据，满足 R, C≤200，M≤200,000；<br>另有 50%的数据，满足 R＝1，C≤500,000，M≤20,000；<br>对于 100%的数据，满足 1≤Pi,j≤1,000，1≤Hi≤2,000,000,000</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>先考虑矩形时的一半数据。注意到P不大于1000，因此可以预处理出与P有关的数组。用<br>val[i][j][k]表示(i, j)左上方的子矩阵中大于等于k的数的总和<br>num[i][j][k]表示(i, j)左上方的子矩阵中大于等于k的数的个数<br>然后就可以二分答案了，二分k，求矩阵前缀和，判定一下OK。</p><p>再考虑剩下的一维的大数据。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1926&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1926&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;幸福幼儿园B29班的粟粟是一个聪明机灵、乖巧可爱的小朋友，她的爱好是画画和读书，尤其喜欢Thomas H. Cormen的文章。粟粟家中有一个R行C列的巨型书架，书架的每一个位置都摆有一本书，上数第i行、左数第j列摆放的书有Pi,j页厚。&lt;/p&gt;
&lt;p&gt;粟粟每天除了读书之外，还有一件必不可少的工作就是摘苹果，她每天必须摘取一个指定的苹果。粟粟家果树上的苹果有的高、有的低，但无论如何凭粟粟自己的个头都难以摘到。不过她发现，如果在脚下放上几本书，就可以够着苹果；她同时注意到，对于第i天指定的那个苹果，只要她脚下放置书的总页数之和不低于Hi，就一定能够摘到。&lt;/p&gt;
&lt;p&gt;由于书架内的书过多，父母担心粟粟一天内就把所有书看完而耽误了上幼儿园，于是每天只允许粟粟在一个特定区域内拿书。这个区域是一个矩形，第i天给定区域的左上角是上数第x1i行的左数第y1i本书，右下角是上数第x2i行的左数第y2i本书。换句话说，粟粟在这一天，只能在这﹙x2i－x1i＋1﹚×﹙y2i－y1i＋1﹚本书中挑选若干本垫在脚下，摘取苹果。&lt;/p&gt;
&lt;p&gt;粟粟每次取书时都能及时放回原位，并且她的书架不会再撤下书目或换上新书，摘苹果的任务会一直持续M天。给出每本书籍的页数和每天的区域限制及采摘要求，请你告诉粟粟，她每天至少拿取多少本书，就可以摘到当天指定的苹果。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="主席树" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="前缀和" scheme="http://yoursite.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="二分答案" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1070 修车</title>
    <link href="http://yoursite.com/2019/01/17/BZOJ1070-%E4%BF%AE%E8%BD%A6/"/>
    <id>http://yoursite.com/2019/01/17/BZOJ1070-修车/</id>
    <published>2019-01-17T13:16:09.000Z</published>
    <updated>2019-01-17T14:21:40.744Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1070" target="_blank" rel="noopener">BZOJ1070</a></p></blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>　　同一时刻有N位车主带着他们的爱车来到了汽车维修中心。维修中心共有M位技术人员，不同的技术人员对不同<br>的车进行维修所用的时间是不同的。现在需要安排这M位技术人员所维修的车及顺序，使得顾客平均等待的时间最<br>小。 说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。<br><a id="more"></a></p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>　　第一行有两个m,n，表示技术人员数与顾客数。 接下来n行，每行m个整数。第i+1行第j个数表示第j位技术人<br>员维修第i辆车需要用的时间T。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>　　最小平均等待时间，答案精确到小数点后2位。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>2 2<br>3 2<br>1 4</p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>1.50</p><h1 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h1><p>数据范围: (2&lt;=M&lt;=9,1&lt;=N&lt;=60), (1&lt;=T&lt;=1000)</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>对于像这样的对应匹配的问题，一般可以使用网络流求解，即构建二分图，大部分时候求最大匹配（当然也不仅是匹配）。本题中一次维修要消耗一定的时间，因此需要使用最小费用最大流。</p><p>最原始的思路是，左部工人，右部客户的二部图，但本题的特殊之处在于排在后面的人会有更长的等待时间。我们仍需保持这是一个二分图，因此需要对点或边进行一些调整。</p><p>首先，要使用一个重要的思想，考虑每辆车对总等待时间的贡献，即<strong>不计算每个顾客等多久，而计算他让别人等了多久</strong></p><p>每一个工人一个车一个车的修，每修一辆车会让后面的人多等一会儿。</p><p>此时就可以想到拆点。把每一个工人节点k拆成个N点，等同于正在修他将要修的倒数第i辆车，向另外一部j点连边即代表他这个修的是j号车， 费用为$a[j][k]*i$，乘以i是因为后面的i辆车都要等待这个时间。</p><p>事实上本题的构图体现了一个<strong>阶段化拆点</strong>的思想，一个点拆成它的不同阶段，相互独立。</p><p>至于二部图的网络流构图法就不累述了，这里说几个注意点：</p><ol><li>边编号要从2开始计</li><li>不要忘记建反向边，容量0，费用-w</li><li>清空数组神马的别忘了</li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">1010</span>, E = <span class="number">200010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, tot = <span class="number">1</span>, head[V], ver[E], Next[E], cap[E], cost[E], a[<span class="number">20</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> s, t, pe[V], pv[V], maxflow, mincost, d[V], v[V];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y, cap[tot] = c, cost[tot] = w;</span><br><span class="line">    Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">        q.push(s); d[s] = <span class="number">0</span>; v[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">            v[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(cap[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = ver[i];</span><br><span class="line">                <span class="keyword">if</span>(d[y] &gt; d[x] + cost[i]) &#123;</span><br><span class="line">                    d[y] = d[x] + cost[i]; pv[y] = x; pe[y] = i;</span><br><span class="line">                    <span class="keyword">if</span>(!v[y]) v[y] = <span class="number">1</span>, q.push(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d[t] == inf) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> flow = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pv[i]) flow = min(flow, cap[pe[i]]);</span><br><span class="line">        maxflow += flow;</span><br><span class="line">        mincost += flow * d[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pv[i]) cap[pe[i]] -= flow, cap[pe[i] ^ <span class="number">1</span>] += flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    s = n * m + n + <span class="number">1</span>, t = s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[j][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) </span><br><span class="line">                add(i * n + j, m * n + k, <span class="number">1</span>, a[i+<span class="number">1</span>][k] * j), </span><br><span class="line">                add(n * m + k, i * n + j, <span class="number">0</span>, -a[i+<span class="number">1</span>][k] * j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++) add(s, i, <span class="number">1</span>, <span class="number">0</span>), add(i, s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n * m + <span class="number">1</span>; i &lt;= n * m + n; i++) add(i, t, <span class="number">1</span>, <span class="number">0</span>), add(t, i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf"</span>, (<span class="keyword">double</span>)mincost / n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1070&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1070&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;　　同一时刻有N位车主带着他们的爱车来到了汽车维修中心。维修中心共有M位技术人员，不同的技术人员对不同&lt;br&gt;的车进行维修所用的时间是不同的。现在需要安排这M位技术人员所维修的车及顺序，使得顾客平均等待的时间最&lt;br&gt;小。 说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。&lt;br&gt;
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="网络流-费用流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3994 约数个数和</title>
    <link href="http://yoursite.com/2019/01/13/BZOJ3994-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/"/>
    <id>http://yoursite.com/2019/01/13/BZOJ3994-约数个数和/</id>
    <published>2019-01-13T05:57:35.000Z</published>
    <updated>2019-01-22T07:18:58.174Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接： <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3994" target="_blank" rel="noopener">BZOJ3994</a></p></blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p> 设d(x)为x的约数个数，给定N、M，求$\sum_{i=1}^N\sum_{j=1}^Md(ij)$<br><a id="more"></a></p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入文件包含多组测试数据。</p><p>第一行，一个整数T，表示测试数据的组数。<br>接下来的T行，每行两个整数N、M。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p> T行，每行一个整数，表示你所求的答案。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>2<br>7 4<br>5 6</p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>110<br>121</p><h1 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h1><p>1&lt;=N, M&lt;=50000<br>1&lt;=T&lt;=50000</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，要先介绍一个可爱的结论：<br>$$ d(ij) = \sum_{x|i}\sum_{y|j}[gcd(x, y) = 1] $$<br>简单证明一下：<br>当$(i, j)=1$时，结果显然为i的约数个数乘j的约数个数。<br>否则，会有一部分重复，因为i*j的某一个因数可以有不同方式得到。怎样得到另一种方式呢？比如现在有$x|i,\ y|j,\ xy|ij,\ d|x$此时让x除以d，y乘以d，得到新的$xy|ij$，而这样做合法的前提是d同时是i和j的因数，或者说$gcd(x, yd)\ne 1$，当有这样的一对约数时，把结果减1，就可以得到这个式子。</p><p>结合其他几道题目，可以发现反演似乎非常青睐gcd，所有的数论函数都要尽量往最大公约数上面靠，然后再开始套路。</p><p>之后就是一道比较经典的反演题目了，总之就是推式子吧。求$$ \sum_{i=1}^N\sum_{j=1}^M\sum_{x|i}\sum_{y|j}[gcd(x, y) = 1] $$<br>相同的x, y枚举了很多次，因此先枚举x, y，贡献可以直接计算得到，原式即<br>$$\sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[gcd(i, j) = 1]$$<br>我们令$$ f(n) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[gcd(i, j) = n] $$$$ F(d) = \sum_{d|n}f(n) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac{N}{i}\rfloor\lfloor\frac{M}{j}\rfloor[d\ |\ gcd(i, j)] $$此处可以开心得去掉gcd，用漂亮的除法代替，枚举i和j分别是d的多少倍，得到$$ F(x) = \sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\lfloor\frac{N}{id}\rfloor\lfloor\frac{M}{jd}\rfloor$$<br>这时就可以使用<code>莫比乌斯反演</code>了，因为可以看到我们已经消去了gcd，也就是说式子里不存在数论函数了，于是<br>$$ f(d) = \sum_{d|n}\mu(\frac{n}{d})F(n) $$得到答案为$$ ans = f(1) = \sum_{d=1}^{min(N, M)}\mu(d)F(d) =<br>\sum_{d=1}^{min(N, M)}\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\mu(d)\lfloor\frac{N}{id}\rfloor\lfloor\frac{M}{jd}\rfloor $$<br>现在讨论代码实现，暴力需要三层循环，因此需要用<code>线性筛</code>预处理，对于每一个x，处理出$s[x] = \sum_{i=1}^x\lfloor\frac{x}{i}\rfloor$，未来查询$s[\frac{N}{d}]$，因此只需要枚举d这一个变量。<br>再利用<code>整除分块</code>，$\lfloor\frac{N}{d}\rfloor$且$\lfloor\frac{M}{d}\rfloor$相同的部分只计算一次，就可以在$O(\sqrt{n})$的时间完成一次询问，总复杂度$O(T\sqrt{n})$</p><p>关于$\mu$的计算最好作为一个模板记下啦。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">int</span> miu[N], smiu[N], v[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) miu[i] = <span class="number">1</span>, v[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v[i]) <span class="keyword">continue</span>;</span><br><span class="line">        miu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)&#123;</span><br><span class="line">            v[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>((j / i) % i == <span class="number">0</span>) miu[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> miu[j] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) smiu[i] = smiu[i<span class="number">-1</span>] + miu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= i; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = i / (i / l);</span><br><span class="line">            s[i] += <span class="number">1l</span>l * (r - l + <span class="number">1</span>) * (i / l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(<span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; m) swap(n, m);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>)&#123;</span><br><span class="line">            j = min(n / (n / i), m / (m / i));</span><br><span class="line">            ans += <span class="number">1l</span>l * (smiu[j] - smiu[i - <span class="number">1</span>]) * s[n / i] * s[m / i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接： &lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3994&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3994&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt; 设d(x)为x的约数个数，给定N、M，求$\sum_{i=1}^N\sum_{j=1}^Md(ij)$&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="莫比乌斯反演" scheme="http://yoursite.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>施工结束</title>
    <link href="http://yoursite.com/2019/01/13/%E7%BA%AA%E5%BF%B5%E6%97%A5/"/>
    <id>http://yoursite.com/2019/01/13/纪念日/</id>
    <published>2019-01-13T03:57:08.000Z</published>
    <updated>2019-01-13T09:31:15.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客建成日"><a href="#博客建成日" class="headerlink" title="博客建成日"></a>博客建成日</h1><p>2019年1月13日，该博客基本搭建搭建完成。<br><a id="more"></a><br>话说步入OI也有将近一年的时间了，之前从来没有写过博客。曾经搜题解时看到别人的博客常常是一番羡慕，但不知什么原因，或许是太懒了，一直没有为自己搭建一个blog。从昨晚起，忙碌（<del>玩</del>）了几个小时，心里还是非常有成就感的。从今天起，我应该会养成写题解、发博客的习惯，这应当是有深远意义的。<br>这篇博客主要是为了一个纪念，就像古代人建了一座房子还要写一篇序一样，我如今也是有blog的人了，不仅一番激动。<br>但愿未来这个博客会充实起来，像很多大佬一样有几十篇来自各个OJ的题解。<br>博客界面开不是很满意，未来会慢慢润色的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;博客建成日&quot;&gt;&lt;a href=&quot;#博客建成日&quot; class=&quot;headerlink&quot; title=&quot;博客建成日&quot;&gt;&lt;/a&gt;博客建成日&lt;/h1&gt;&lt;p&gt;2019年1月13日，该博客基本搭建搭建完成。&lt;br&gt;
    
    </summary>
    
      <category term="纪念日" scheme="http://yoursite.com/categories/%E7%BA%AA%E5%BF%B5%E6%97%A5/"/>
    
    
  </entry>
  
</feed>
