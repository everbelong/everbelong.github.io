<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RheToXic</title>
  
  <subtitle>a pimping OIer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-15T12:51:31.042Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>RheToXic</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ1488 [HNOI2009]图的同构</title>
    <link href="http://yoursite.com/2019/07/15/BZOJ1488-HNOI2009-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84/"/>
    <id>http://yoursite.com/2019/07/15/BZOJ1488-HNOI2009-图的同构/</id>
    <published>2019-07-15T11:50:59.000Z</published>
    <updated>2019-07-15T12:51:31.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://lydsy.com/JudgeOnline/problem.php?id=1488" target="_blank" rel="noopener">BZOJ1488</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意求N个点不同构图的个数<br>显然要用Burnside引理<br>思路就是求出每个置换的循环个数，求2的幂的平均值<br>需要注意求的是<strong>点</strong>置换下的<strong>边</strong>循环<br>分情况讨论：</p><ol><li><p>一个长度为$x$的点的循环内部有$\lfloor\frac{x}{2}\rfloor$个边的循环。</p></li><li><p>两个长度分别为$x$和$y$的点的循环之间有$gcd(x,y)$个边的循环</p></li></ol><p>这个画画图就能明白，对于第一点，实际上是不同“长度”的边，对于第二点，每个循环节的长度一定是lcm，因此个数就是gcd</p><p>但是置换共有$n!$个，无法枚举<br>事实上我们只需要知道每个循环的大小，求出来后乘以方案数即可。因此考虑枚举n的拆分，求出每种拆分的方案数。设共k个循环，长度分别为$a[i]$，每种长度有$c[i]$个，则方案数为：<br>$$<br>\frac{n!}{\Pi a[i]\Pi c[i]！}<br>$$<br>因为长度相同的要除以排列数，每一个循环里会有$a[i]$个是循环相同的，也要除掉</p><p>最后，本题卡常，gcd和逆元都要预处理，少了一个都会TLE（亲身实践）<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">65</span>, mod = <span class="number">997</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn], cnt, fac[maxn], c[maxn], ans, rev[maxn], rfac[maxn], g[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">int</span> res = <span class="number">1</span>; <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod; <span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">if</span>(!x) <span class="keyword">return</span> y; <span class="keyword">return</span> gcd(y % x, x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = fac[n], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c[i]; j++) a[++cnt] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) tmp = tmp * rev[a[i]] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(c[i]) tmp = tmp * rfac[c[i]] % mod;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) num += a[i] / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= cnt; j++) num += g[a[i]][a[j]];</span><br><span class="line">    ans = (ans + tmp * Power(<span class="number">2</span>, num) % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) &#123; c[<span class="number">1</span>] = n - s; calc(); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s + i * x &lt;= n; i++) c[x] = i, dfs(x - <span class="number">1</span>, s + i * x), c[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = fac[i<span class="number">-1</span>] * i % mod, rfac[i] = Power(fac[i], mod - <span class="number">2</span>);</span><br><span class="line">    rev[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) rev[i] = (mod - mod / i) % mod * rev[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) g[i][j] = gcd(i, j);</span><br><span class="line">    dfs(n, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * Power(fac[n], mod - <span class="number">2</span>) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://lydsy.com/JudgeOnline/problem.php?id=1488&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1488&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题意求N个点不同构图的个数&lt;br&gt;显然要用Burnside引理&lt;br&gt;思路就是求出每个置换的循环个数，求2的幂的平均值&lt;br&gt;需要注意求的是&lt;strong&gt;点&lt;/strong&gt;置换下的&lt;strong&gt;边&lt;/strong&gt;循环&lt;br&gt;分情况讨论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个长度为$x$的点的循环内部有$\lfloor\frac{x}{2}\rfloor$个边的循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两个长度分别为$x$和$y$的点的循环之间有$gcd(x,y)$个边的循环&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个画画图就能明白，对于第一点，实际上是不同“长度”的边，对于第二点，每个循环节的长度一定是lcm，因此个数就是gcd&lt;/p&gt;
&lt;p&gt;但是置换共有$n!$个，无法枚举&lt;br&gt;事实上我们只需要知道每个循环的大小，求出来后乘以方案数即可。因此考虑枚举n的拆分，求出每种拆分的方案数。设共k个循环，长度分别为$a[i]$，每种长度有$c[i]$个，则方案数为：&lt;br&gt;$$&lt;br&gt;\frac{n!}{\Pi a[i]\Pi c[i]！}&lt;br&gt;$$&lt;br&gt;因为长度相同的要除以排列数，每一个循环里会有$a[i]$个是循环相同的，也要除掉&lt;/p&gt;
&lt;p&gt;最后，本题卡常，gcd和逆元都要预处理，少了一个都会TLE（亲身实践）&lt;br&gt;
    
    </summary>
    
      <category term="-[数学][组合] -[数学][Burnside引理]" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6-%E7%BB%84%E5%90%88-%E6%95%B0%E5%AD%A6-Burnside%E5%BC%95%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2655 calc</title>
    <link href="http://yoursite.com/2019/07/15/BZOJ2655-calc/"/>
    <id>http://yoursite.com/2019/07/15/BZOJ2655-calc/</id>
    <published>2019-07-15T09:27:05.000Z</published>
    <updated>2019-07-15T09:41:16.180Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2655" target="_blank" rel="noopener">BZOJ2655</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>我真是见识到了插值这个东西的好处<br>第一步的想法是直接退出一个式子，这样最好，如果没有两两不同的限制，那么式子很简单就是$[\frac{A(A+1)}{2}]^n$<br>多了不同这个限制，那么容斥就好了，总方案$-$一对相同$+$两对相同$-…$<br>这样写出式子看看<br>$$<br>(\sum_{i=1}^Ai)^n-C_{n-1}^1(\sum_{i=1}^Ai)^{n-2}(\sum_{i=1}^Ai^2)+…<br>$$<br>但是第三项开始就不好写了，因为可能是三连等，也可能有两对分别相同<br>然而我们可以发现不管怎么写，这个式子始终是一个关于A的$2n$次多项式。每一项都是这个次数。<br>然后用插值就好了，根本不用考虑什么烦人的容斥，反正插出来都一样<br>这样A再大都可以被降到2n的级别，考虑暴力做法算$0…2n$的函数值就可以了<br>实在是太神了，感觉什么都没做，就解决了容斥的问题！<br>暴力的部分用dp就可以了，令$f[i][j]$表示j个小于等于i的正整数的所有序列的值得和，则<br>$$<br>f[i][j] = f[i-1][j-1] <em>i </em> j + f[i-1][j]<br>$$意思是，如果j个数中有i，共有j种情况，每种的值都会乘以i，从f[i-1][j-1]转移，否则和f[i-1][j]</p><p>感觉如果发现某题的式子是个多项式，那么这题就可以转化为暴力题了<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll mod, A, n, f[maxn*<span class="number">2</span>][maxn], ans;</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;A, &amp;n, &amp;mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            f[i][j] = (f[i<span class="number">-1</span>][j<span class="number">-1</span>] * i % mod * j % mod + f[i<span class="number">-1</span>][j]) % mod;</span><br><span class="line">    <span class="keyword">if</span>(A &lt;= n * <span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[A][n]); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        ll s1 = <span class="number">1</span>, s2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n * <span class="number">2</span>; j++) <span class="keyword">if</span>(i != j) </span><br><span class="line">            s1 = (A - j + mod) % mod * s1 % mod, s2 = (i - j + mod) % mod * s2 % mod;</span><br><span class="line">        ans = (ans + s1 * f[i][n] % mod * Power(s2, mod - <span class="number">2</span>) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2655&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2655&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;我真是见识到了插值这个东西的好处&lt;br&gt;第一步的想法是直接退出一个式子，这样最好，如果没有两两不同的限制，那么式子很简单就是$[\frac{A(A+1)}{2}]^n$&lt;br&gt;多了不同这个限制，那么容斥就好了，总方案$-$一对相同$+$两对相同$-…$&lt;br&gt;这样写出式子看看&lt;br&gt;$$&lt;br&gt;(\sum_{i=1}^Ai)^n-C_{n-1}^1(\sum_{i=1}^Ai)^{n-2}(\sum_{i=1}^Ai^2)+…&lt;br&gt;$$&lt;br&gt;但是第三项开始就不好写了，因为可能是三连等，也可能有两对分别相同&lt;br&gt;然而我们可以发现不管怎么写，这个式子始终是一个关于A的$2n$次多项式。每一项都是这个次数。&lt;br&gt;然后用插值就好了，根本不用考虑什么烦人的容斥，反正插出来都一样&lt;br&gt;这样A再大都可以被降到2n的级别，考虑暴力做法算$0…2n$的函数值就可以了&lt;br&gt;实在是太神了，感觉什么都没做，就解决了容斥的问题！&lt;br&gt;暴力的部分用dp就可以了，令$f[i][j]$表示j个小于等于i的正整数的所有序列的值得和，则&lt;br&gt;$$&lt;br&gt;f[i][j] = f[i-1][j-1] &lt;em&gt;i &lt;/em&gt; j + f[i-1][j]&lt;br&gt;$$意思是，如果j个数中有i，共有j种情况，每种的值都会乘以i，从f[i-1][j-1]转移，否则和f[i-1][j]&lt;/p&gt;
&lt;p&gt;感觉如果发现某题的式子是个多项式，那么这题就可以转化为暴力题了&lt;br&gt;
    
    </summary>
    
      <category term="-[多项式][拉格朗日插值] -[动态规划][计数dp]" scheme="http://yoursite.com/categories/%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%AE%A1%E6%95%B0dp/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3926 [Zjoi2015]诸神眷顾的幻想乡</title>
    <link href="http://yoursite.com/2019/07/12/BZOJ3926-Zjoi2015-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/"/>
    <id>http://yoursite.com/2019/07/12/BZOJ3926-Zjoi2015-诸神眷顾的幻想乡/</id>
    <published>2019-07-12T14:44:52.000Z</published>
    <updated>2019-07-13T00:53:12.617Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3926" target="_blank" rel="noopener">BZOJ3926</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>20min 1A庆祝一下<br>国家队论文写过一个trie上SAM的科技<br>其实可以类比广义后缀自动机加入多个串，trie树上无非是每个点插入前将las移到其父亲对应的节点<br>本题由于叶子不超过20个，以每个叶子为根，分别遍历一遍trie，全部加入一个广义自动机中，累计每个节点的max-min+1即可<br>由于所有有向路径都可以看成以一个叶子为根的一个直的路径（也就是trie上的“子串”），因此正确性可以保证<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, C, col[maxn], head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot;</span><br><span class="line"><span class="keyword">int</span> du[maxn], cnt = <span class="number">1</span>, rt = <span class="number">1</span>, ch[maxn * <span class="number">40</span>][<span class="number">10</span>], par[maxn * <span class="number">40</span>], val[maxn * <span class="number">40</span>], pos[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np = ++cnt; val[np] = val[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line">    <span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][x];</span><br><span class="line">        <span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span>(ch[nq]));</span><br><span class="line">            par[nq] = par[q];</span><br><span class="line">            par[q] = par[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    pos[x] = extend(col[x], pos[fa]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa) dfs(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;C);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x), du[x]++, du[y]++;</span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(du[i] == <span class="number">1</span>) dfs(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) ans += val[i] - val[par[i]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3926&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3926&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;20min 1A庆祝一下&lt;br&gt;国家队论文写过一个trie上SAM的科技&lt;br&gt;其实可以类比广义后缀自动机加入多个串，trie树上无非是每个点插入前将las移到其父亲对应的节点&lt;br&gt;本题由于叶子不超过20个，以每个叶子为根，分别遍历一遍trie，全部加入一个广义自动机中，累计每个节点的max-min+1即可&lt;br&gt;由于所有有向路径都可以看成以一个叶子为根的一个直的路径（也就是trie上的“子串”），因此正确性可以保证&lt;br&gt;
    
    </summary>
    
      <category term="字符串" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3277 串</title>
    <link href="http://yoursite.com/2019/07/12/BZOJ3277-%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/07/12/BZOJ3277-串/</id>
    <published>2019-07-12T12:04:13.000Z</published>
    <updated>2019-07-12T13:56:57.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3277" target="_blank" rel="noopener">BZOJ3277</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>第一道广义后缀自动机<br>其实广义后缀自动机就是每加入一个串后，将las移到根，然后毫无变化地继续建就可以<br>厉害的是这样建出来后就可以匹配原来所有字符串的子串</p><p>对于本题，每个节点开一个set记录该位置子串出现的母字符串集合，建完自动机后dfs将子树set合并到父亲上去，有用的是每个节点最后的set大小<br>然后对于每个字符串开始在自动机上跑，首先按字符在DAG上转移，若当前set大小小于k，则不停跳父亲，知道大于等于位置，然后直接将此节点的max长度累加入答案。<br>之所以直接累加max，是因为该节点的祖先们一定也满足条件<br>可以发现，这样就不重不漏的统计了该字符串所有合法的子串（走DAG相当于右端点后移，跳父亲相当于将左端点调到合适位置，累加max便是将所有右端点为此的合法子串统计了）</p><p>有一个关键点，经过亲身测试和调试，广义后缀自动机不能使用基数排序得到拓扑序，必须dfs</p><p>最后的问题是，set合并的过程看起来很暴力，那为什么他是对的？<br>目前不知道，连自动机的复杂度都不会证，回头再填坑<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">27</span>], par[maxn], val[maxn], cnt = <span class="number">1</span>, rt = <span class="number">1</span>, las = <span class="number">1</span>, n, k;</span><br><span class="line"><span class="keyword">int</span> L, sz[maxn], head[maxn], ver[maxn &lt;&lt; <span class="number">1</span>], Next[maxn &lt;&lt; <span class="number">1</span>], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s[maxn];</span><br><span class="line"><span class="built_in">string</span> str[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = las, np = ++cnt; s[np].insert(cur); val[np] = val[p] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line"><span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> q = ch[p][x];</span><br><span class="line"><span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span>(ch[nq]));</span><br><span class="line">par[nq] = par[q];</span><br><span class="line">par[q] = par[np] = nq;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">las = np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != par[x]) &#123;</span><br><span class="line">dfs(ver[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator j = s[ver[i]].begin(); j != s[ver[i]].end(); j++) s[x].insert(*j);</span><br><span class="line">&#125;</span><br><span class="line">sz[x] = s[x].size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line">L += str[i].length();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str[i].length(); j++) extend(str[i][j] - <span class="string">'a'</span>, i);</span><br><span class="line">las = rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) add(i, par[i]), add(par[i], i);</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, cur = rt;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str[i].length(); j++) &#123;</span><br><span class="line">cur = ch[cur][str[i][j] - <span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">while</span>(cur &amp;&amp; sz[cur] &lt; k) cur = par[cur];</span><br><span class="line">ans += val[cur];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3277&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3277&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;第一道广义后缀自动机&lt;br&gt;其实广义后缀自动机就是每加入一个串后，将las移到根，然后毫无变化地继续建就可以&lt;br&gt;厉害的是这样建出来后就可以匹配原来所有字符串的子串&lt;/p&gt;
&lt;p&gt;对于本题，每个节点开一个set记录该位置子串出现的母字符串集合，建完自动机后dfs将子树set合并到父亲上去，有用的是每个节点最后的set大小&lt;br&gt;然后对于每个字符串开始在自动机上跑，首先按字符在DAG上转移，若当前set大小小于k，则不停跳父亲，知道大于等于位置，然后直接将此节点的max长度累加入答案。&lt;br&gt;之所以直接累加max，是因为该节点的祖先们一定也满足条件&lt;br&gt;可以发现，这样就不重不漏的统计了该字符串所有合法的子串（走DAG相当于右端点后移，跳父亲相当于将左端点调到合适位置，累加max便是将所有右端点为此的合法子串统计了）&lt;/p&gt;
&lt;p&gt;有一个关键点，经过亲身测试和调试，广义后缀自动机不能使用基数排序得到拓扑序，必须dfs&lt;/p&gt;
&lt;p&gt;最后的问题是，set合并的过程看起来很暴力，那为什么他是对的？&lt;br&gt;目前不知道，连自动机的复杂度都不会证，回头再填坑&lt;br&gt;
    
    </summary>
    
      <category term="字符串" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3669 [Noi2014]魔法森林</title>
    <link href="http://yoursite.com/2019/07/10/BZOJ3669-Noi2014-%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97/"/>
    <id>http://yoursite.com/2019/07/10/BZOJ3669-Noi2014-魔法森林/</id>
    <published>2019-07-10T09:22:52.000Z</published>
    <updated>2019-07-10T12:45:56.464Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3669" target="_blank" rel="noopener">BZOJ3669</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>第一想法是二分<br>然而不能二分a+b，更不能二分a或b<br>因此把a和b分开考虑<br>将所有边按照a排序，把b看成边权，一条一条加进去，维护1到n的最大边权最小的路径，随时更新答案<br>容易证明这条路径一定在最小生成树上<br>因此要在加边的过程中维护最小生成树<br>需要支持询问两点路径上的最大边权，以及最大边权所在的是那条边<br>加边时若构成环，则查询路径上的最大边，若大于当前边，则cut掉，然后加入当前边，否则跳过<br>若不构成环，就直接加入当前边<br>使用LCT维护，每个点记录子树最大权值及取到的位置，由于LCT只能维护点权，因此为每条边新建一个点，连到边的两个端点上<br>本题一遍过！！！<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>, maxm = <span class="number">100010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, val[maxn + maxm], fa[maxn + maxm], ch[maxn + maxm][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pos[maxn + maxm], sta[maxn + maxm], mx[maxn + maxm], rev[maxn + maxm];</span><br><span class="line"><span class="keyword">int</span> ans = inf;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edg</span> &#123;</span> <span class="keyword">int</span> x, y, a, b; &#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edg x, Edg y)</span> </span>&#123; <span class="keyword">return</span> x.a &lt; y.a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] != x &amp;&amp; ch[fa[x]][<span class="number">0</span>] != x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) <span class="built_in">printf</span>(<span class="string">"%d %d %d %d %d %d\n"</span>, i, fa[i], ch[i][<span class="number">0</span>], ch[i][<span class="number">1</span>], mx[i], rev[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mx[x] = max(val[x], max(mx[ch[x][<span class="number">0</span>]], mx[ch[x][<span class="number">1</span>]]));</span><br><span class="line">    <span class="keyword">if</span>(mx[x] == val[x]) pos[x] = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mx[x] == mx[ch[x][<span class="number">0</span>]]) pos[x] = pos[ch[x][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">else</span> pos[x] = pos[ch[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] ^= <span class="number">1</span>; rev[ch[x][<span class="number">0</span>]] ^= <span class="number">1</span>; rev[ch[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], d = get(x);</span><br><span class="line">    ch[y][d] = ch[x][d ^ <span class="number">1</span>]; fa[ch[y][d]] = y;</span><br><span class="line">    <span class="keyword">if</span>(!isroot(y)) ch[fa[y]][get(y)] = x;</span><br><span class="line">    fa[x] = fa[y];</span><br><span class="line">    ch[x][d ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">    pushup(y); pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>; sta[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) sta[++top] = fa[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i; i--) pushdown(sta[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pa = fa[x]; !isroot(x); pa = fa[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isroot(pa)) rotate(get(x) == get(pa) ? pa : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; x; t = x, x = fa[x]) </span><br><span class="line">        splay(x), ch[x][<span class="number">1</span>] = t, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); rev[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) pushdown(x), x = ch[x][<span class="number">0</span>]; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); access(y); splay(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); ch[y][<span class="number">0</span>] = fa[x] = <span class="number">0</span>; pushup(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); fa[x] = y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;edge[i].x, &amp;edge[i].y, &amp;edge[i].a, &amp;edge[i].b);</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) val[i + n] = mx[i + n] = edge[i].b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = edge[i].x, y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(findroot(x) == findroot(y)) &#123;</span><br><span class="line">            makeroot(x); access(y); splay(y);</span><br><span class="line">            <span class="keyword">if</span>(mx[y] &gt; edge[i].b) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = pos[y];</span><br><span class="line">                <span class="keyword">int</span> lc = edge[tmp - n].x, rc = edge[tmp - n].y;</span><br><span class="line">                cut(tmp, lc); cut(tmp, rc);</span><br><span class="line">                link(x, i + n); link(y, i + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> link(x, i + n), link(y, i + n);</span><br><span class="line">    <span class="comment">//debug(); cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(findroot(<span class="number">1</span>) != findroot(n)) <span class="keyword">continue</span>;</span><br><span class="line">        split(<span class="number">1</span>, n);</span><br><span class="line">        ans = min(ans, edge[i].a + mx[n]);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == inf) ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3669&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3669&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;第一想法是二分&lt;br&gt;然而不能二分a+b，更不能二分a或b&lt;br&gt;因此把a和b分开考虑&lt;br&gt;将所有边按照a排序，把b看成边权，一条一条加进去，维护1到n的最大边权最小的路径，随时更新答案&lt;br&gt;容易证明这条路径一定在最小生成树上&lt;br&gt;因此要在加边的过程中维护最小生成树&lt;br&gt;需要支持询问两点路径上的最大边权，以及最大边权所在的是那条边&lt;br&gt;加边时若构成环，则查询路径上的最大边，若大于当前边，则cut掉，然后加入当前边，否则跳过&lt;br&gt;若不构成环，就直接加入当前边&lt;br&gt;使用LCT维护，每个点记录子树最大权值及取到的位置，由于LCT只能维护点权，因此为每条边新建一个点，连到边的两个端点上&lt;br&gt;本题一遍过！！！&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCT" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LCT/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2049 [Sdoi2008]Cave 洞穴勘测</title>
    <link href="http://yoursite.com/2019/07/08/BZOJ2049-Sdoi2008-Cave-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/07/08/BZOJ2049-Sdoi2008-Cave-洞穴勘测/</id>
    <published>2019-07-08T13:58:40.000Z</published>
    <updated>2019-07-10T09:24:03.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2049" target="_blank" rel="noopener">BZOJ2049</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>不能再裸的LCT裸题<br>好久没写了，写道题复习一下，再练难的<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>, maxm = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn], ch[maxn][<span class="number">2</span>], rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"><span class="keyword">int</span> sta[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] ^= <span class="number">1</span>; rev[ch[x][<span class="number">0</span>]] ^= <span class="number">1</span>; rev[ch[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = get(x);</span><br><span class="line">    ch[y][z] = ch[x][z ^ <span class="number">1</span>]; fa[ch[y][z]] = y;</span><br><span class="line">    <span class="keyword">if</span>(!isroot(y)) ch[fa[y]][get(y)] = x; </span><br><span class="line">    fa[x] = fa[y];</span><br><span class="line">    ch[x][z ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>; sta[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) sta[++top] = fa[i];</span><br><span class="line">    <span class="keyword">while</span>(top) pushdown(sta[top--]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pa = fa[x]; !isroot(x); pa = fa[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isroot(pa)) rotate(get(x) == get(pa) ? pa : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; x; t = x, x = fa[x])</span><br><span class="line">        splay(x), ch[x][<span class="number">1</span>] = t;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); rev[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) pushdown(x), x = ch[x][<span class="number">0</span>]; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); access(y); splay(y); fa[x] = ch[y][<span class="number">0</span>] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); fa[x] = y; &#125;</span><br><span class="line"><span class="keyword">char</span> o[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, o, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'C'</span>) link(x, y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'D'</span>) cut(x, y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'Q'</span>) <span class="built_in">printf</span>(findroot(x) == findroot(y) ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2049&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2049&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;不能再裸的LCT裸题&lt;br&gt;好久没写了，写道题复习一下，再练难的&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCT" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LCT/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2729 [HNOI2012]排队</title>
    <link href="http://yoursite.com/2019/07/08/BZOJ2729-HNOI2012-%E6%8E%92%E9%98%9F/"/>
    <id>http://yoursite.com/2019/07/08/BZOJ2729-HNOI2012-排队/</id>
    <published>2019-07-08T04:47:19.000Z</published>
    <updated>2019-07-08T06:21:56.047Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2729" target="_blank" rel="noopener">BZOJ2729</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>插板法<br>以男生为基准，先插老师，再插女生<br>若老师之间有男生，就是n插2，再插m<br>若老师之间无男生，则之间只有一个女生，看成一个男生，n+1插m-1<br>答案为<br>$$<br>n!A_{n+1}^2A_{n+3}^m + 2m(n+1)!A_{n+2}^{m-1}<br>$$<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bigint</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> len, a[maxn * <span class="number">1000</span>];</span><br><span class="line">&#125;ans, ans1, ans2;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> += (bigint &amp;x, bigint &amp;y) &#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">x.len = max(x.len, y.len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++) </span><br><span class="line">x.a[i] += y.a[i] + t, t = x.a[i] / <span class="number">10</span>, x.a[i] %= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(t) x.a[++x.len] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> *= (bigint &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++) </span><br><span class="line">x.a[i] *= y, x.a[i] += t, t = x.a[i] / <span class="number">10</span>, x.a[i] %= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(t) x.a[++x.len] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(bigint &amp;x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x.len; i; i--) <span class="built_in">printf</span>(<span class="string">"%d"</span>, x.a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">ans1.len = <span class="number">1</span>; ans1.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">ans2 = ans1;</span><br><span class="line">ans1 *= n + <span class="number">1</span>; ans1 *= n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans1 *= n + <span class="number">4</span> - i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans1 *= i;</span><br><span class="line">ans2 *= <span class="number">2</span> * m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) ans2 *= n + <span class="number">3</span> - i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) ans2 *= i;</span><br><span class="line">ans1 += ans2;</span><br><span class="line">print(ans1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2729&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2729&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;插板法&lt;br&gt;以男生为基准，先插老师，再插女生&lt;br&gt;若老师之间有男生，就是n插2，再插m&lt;br&gt;若老师之间无男生，则之间只有一个女生，看成一个男生，n+1插m-1&lt;br&gt;答案为&lt;br&gt;$$&lt;br&gt;n!A_{n+1}^2A_{n+3}^m + 2m(n+1)!A_{n+2}^{m-1}&lt;br&gt;$$&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2212 [Poi2011]Tree Rotations</title>
    <link href="http://yoursite.com/2019/07/07/BZOJ2212-Poi2011-Tree-Rotations/"/>
    <id>http://yoursite.com/2019/07/07/BZOJ2212-Poi2011-Tree-Rotations/</id>
    <published>2019-07-07T14:30:30.000Z</published>
    <updated>2019-07-07T14:47:05.726Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2212" target="_blank" rel="noopener">BZOJ2212</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>每个节点翻转所影响的逆序对是它的两棵子树之间的逆序对个数，其他的和子树内的都不影响<br>在读入的过程中就是一个dfs，在这个过程中考虑每个点是否翻转，也就是右节点中小于左节点的数对数<br>可以用线段树合并完成，每个点维护一个权值线段树和区间和<br>用子节点合并得到父节点，在合并时顺便统计一下前边所说的数对的个数，判断是否翻转，并累计答案</p><p>好了，正经话说完了，下面吐槽<br>我自认为代码写的很精炼，经过一番调试后在洛谷拿到了95分，剩下的一个点是MLE<br>最开始线段树节点数开的是maxn*50，<br>所以调成40，然后MLE<br>所以调成30，然后MLE<br>所以调成20，然后RE<br>看到人们很多写5000000，改成这个，然后MLE<br>这个点就对不了了吗[○･｀Д´･ ○]<br>去loj看看，然后发现了55个测试点，然后后面十几个点要么RE，要么TLE<br>网上的人说洛谷数据水，loj强，线段树合并过不去<br>最后去了BZOJ碰碰运气，结果RE<br>于是我下载了LOJ上一个大数据，开无线栈开始跑，打开任务管理器看占用内存<br>只见内存的那一个数据从9Mb，一路稳步上升，几分钟后达到了156Mb<br>对，几分钟后这个程序还在跑<br>然后突然156Mb降到了9Mb，程序异常退出。。。<br>不MLE+TLE+RE才怪<br>算了，我不纠结这个玄学的线段树合并了<br>它的复杂度到底会到多少啊。。。<br>下面贴上满是锅的代码<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, rt[maxn * <span class="number">8</span>], num, sum[maxn * <span class="number">30</span>], lc[maxn * <span class="number">30</span>], rc[maxn * <span class="number">30</span>], cnt;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function">ll <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> lp, <span class="keyword">int</span> rp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lp || !rp) &#123; p = lp + rp; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    p = ++cnt;</span><br><span class="line">    ll res = sum[lc[rp]] * sum[rc[lp]];</span><br><span class="line">    sum[p] = sum[lp] + sum[rp];</span><br><span class="line">    res += merge(lc[p], lc[lp], lc[rp]);</span><br><span class="line">    res += merge(rc[p], rc[lp], rc[rp]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    p = ++cnt;</span><br><span class="line">    sum[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) build(lc[p], l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> build(rc[p], mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(!x) &#123;</span><br><span class="line">        <span class="keyword">int</span> L = fuck(), R = fuck();</span><br><span class="line">        ll res = merge(rt[++num], rt[L], rt[R]);</span><br><span class="line">        ans += min(res, sum[rt[L]] * sum[rt[R]] - res);</span><br><span class="line">    &#125; <span class="keyword">else</span> build(rt[++num], <span class="number">1</span>, n, x);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    fuck();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2212&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2212&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;每个节点翻转所影响的逆序对是它的两棵子树之间的逆序对个数，其他的和子树内的都不影响&lt;br&gt;在读入的过程中就是一个dfs，在这个过程中考虑每个点是否翻转，也就是右节点中小于左节点的数对数&lt;br&gt;可以用线段树合并完成，每个点维护一个权值线段树和区间和&lt;br&gt;用子节点合并得到父节点，在合并时顺便统计一下前边所说的数对的个数，判断是否翻转，并累计答案&lt;/p&gt;
&lt;p&gt;好了，正经话说完了，下面吐槽&lt;br&gt;我自认为代码写的很精炼，经过一番调试后在洛谷拿到了95分，剩下的一个点是MLE&lt;br&gt;最开始线段树节点数开的是maxn*50，&lt;br&gt;所以调成40，然后MLE&lt;br&gt;所以调成30，然后MLE&lt;br&gt;所以调成20，然后RE&lt;br&gt;看到人们很多写5000000，改成这个，然后MLE&lt;br&gt;这个点就对不了了吗[○･｀Д´･ ○]&lt;br&gt;去loj看看，然后发现了55个测试点，然后后面十几个点要么RE，要么TLE&lt;br&gt;网上的人说洛谷数据水，loj强，线段树合并过不去&lt;br&gt;最后去了BZOJ碰碰运气，结果RE&lt;br&gt;于是我下载了LOJ上一个大数据，开无线栈开始跑，打开任务管理器看占用内存&lt;br&gt;只见内存的那一个数据从9Mb，一路稳步上升，几分钟后达到了156Mb&lt;br&gt;对，几分钟后这个程序还在跑&lt;br&gt;然后突然156Mb降到了9Mb，程序异常退出。。。&lt;br&gt;不MLE+TLE+RE才怪&lt;br&gt;算了，我不纠结这个玄学的线段树合并了&lt;br&gt;它的复杂度到底会到多少啊。。。&lt;br&gt;下面贴上满是锅的代码&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3653 谈笑风生</title>
    <link href="http://yoursite.com/2019/07/07/BZOJ3653-%E8%B0%88%E7%AC%91%E9%A3%8E%E7%94%9F/"/>
    <id>http://yoursite.com/2019/07/07/BZOJ3653-谈笑风生/</id>
    <published>2019-07-07T07:55:11.000Z</published>
    <updated>2019-07-07T08:04:49.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3653" target="_blank" rel="noopener">BZOJ3653</a>和<a href="https://www.luogu.org/problemnew/show/P3899" target="_blank" rel="noopener">洛谷P3899</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>由题意，b和a一定是祖先关系<br>若b是a的祖先，c在a的子树内，直接乘法累计即可<br>若a是b的祖先，题意转换为以a为根的子树内，与a距离$\leq k$的点的sz之和<br>可以使用主席树或线段树合并<br>主席树：<br>构造欧拉序列，以dfn为时间轴建立以dep为下标的权值线段树<br>一个节点的子树在欧拉序列上是一个区间，查分询问即可<br>线段树合并：<br>每个点建一颗以dep为下表的权值线段树，父节点由子节点得来，考虑空间会炸，所以父节点由子节点线段树合并来<br>代码为主席树，注意long long<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300010</span>, maxm = <span class="number">600010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxm], Next[maxm], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, sz[maxn], d[maxn], dfn[maxn], num;</span><br><span class="line"><span class="keyword">int</span> rt[maxn * <span class="number">4</span>], cnt, lc[maxn * <span class="number">40</span>], rc[maxn * <span class="number">40</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxn * <span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> las, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = ++cnt;</span><br><span class="line">    sum[p] = sum[las] + x;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> p;</span><br><span class="line">    lc[p] = lc[las]; rc[p] = rc[las]; </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) lc[p] = update(lc[las], l, mid, pos, x);</span><br><span class="line">    <span class="keyword">else</span> rc[p] = update(rc[las], mid + <span class="number">1</span>, r, pos, x);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    d[x] = d[fa] + <span class="number">1</span>; sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa) dfs(ver[i], x), sz[x] += sz[ver[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[x] = ++num;</span><br><span class="line">    rt[num] = update(rt[num - <span class="number">1</span>], <span class="number">1</span>, n, d[x], sz[x] - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa) build(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rp, <span class="keyword">int</span> lp, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[rp] - sum[lp];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) res += query(lc[rp], lc[lp], l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) res += query(rc[rp], rc[lp], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, Q, a, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>); build(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;k);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = min(d[a] - <span class="number">1</span>, k) * ((<span class="keyword">long</span> <span class="keyword">long</span>)sz[a] - <span class="number">1</span>);</span><br><span class="line">        ans += query(rt[dfn[a] + sz[a] - <span class="number">1</span>], rt[dfn[a] - <span class="number">1</span>], <span class="number">1</span>, n, d[a] + <span class="number">1</span>, d[a] + k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3653&lt;/a&gt;和&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3899&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P3899&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;由题意，b和a一定是祖先关系&lt;br&gt;若b是a的祖先，c在a的子树内，直接乘法累计即可&lt;br&gt;若a是b的祖先，题意转换为以a为根的子树内，与a距离$\leq k$的点的sz之和&lt;br&gt;可以使用主席树或线段树合并&lt;br&gt;主席树：&lt;br&gt;构造欧拉序列，以dfn为时间轴建立以dep为下标的权值线段树&lt;br&gt;一个节点的子树在欧拉序列上是一个区间，查分询问即可&lt;br&gt;线段树合并：&lt;br&gt;每个点建一颗以dep为下表的权值线段树，父节点由子节点得来，考虑空间会炸，所以父节点由子节点线段树合并来&lt;br&gt;代码为主席树，注意long long&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>2019扬中Day2</title>
    <link href="http://yoursite.com/2019/07/05/2019%E6%89%AC%E4%B8%ADDay2/"/>
    <id>http://yoursite.com/2019/07/05/2019扬中Day2/</id>
    <published>2019-07-05T14:25:32.000Z</published>
    <updated>2019-07-06T04:32:24.259Z</updated>
    
    <content type="html"><![CDATA[<p>这场比赛前两题我用自己的非正解算法水到了188分<br>真是好水的数据<br>题目出的很模拟赛<br><a id="more"></a><br>题目在这里<br><div class="row">    <embed src="problems.pdf" width="100%" height="550" type="application/pdf"></div></p><h1><span id="纸牌游戏cards">纸牌游戏（cards）</span></h1><p>我的算法就很奇怪了，$f[i][j]$只任选i个，gcd为j的方案数，然后第一问转化成组合数问题一通推式子得到$$ ans=\sum_{i=1}^{n/2}\frac{f[2<em>i][1]}{C_{n}^{i}}-\frac{f[2</em>i-1][1]}{C_{n}^{i-1}} $$<br>然后第二问不好做</p><p>其实正解很巧妙，难点就在于如何记录状态，要记录gcd，还要记录那些选了，但又不能状压<br>注意到如果当前gcd为x，那么之前选的所有数都是x的倍数，而所有x的倍数在此时应给是地位相等的，都再也不会更新gcd。这样就方便记录哪些数已经选过了<br>用$ f[i][j] $表示选了i个，gcd为j的概率，注意此时选的i个都是x的倍数，那么有<br>$$<br>f[i+1][j] += f[i][j]\times \frac{sum[j]-i}{n} \\<br>f[i+1][gcd(a[k], j)] += f[i][j]\times \frac{1}{n}<br>$$<br>其中$sum[j]$表示j的倍数的个数<br>转移方程很巧妙啊，本应枚举所有未选的数，但这不现实，因此枚举所有一定不可能被选过的数，剩下哪些不确定的只要知道个数就可以了</p><p>如果第一问的状态方程这样写，那么第二问用类似的方法配合SG函数方法就可以了，具体参见标程，用记忆化搜索，把乘法换成必胜必败的判定即可</p><p>my第一问<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">310</span>, maxm = <span class="number">1010</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmin</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = min(a, b); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmax</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = max(a, b); &#125;</span><br><span class="line"><span class="keyword">int</span> a[maxn], mx, n;</span><br><span class="line"><span class="keyword">double</span> f[maxn][maxm], c[maxn][maxn], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!a) <span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">return</span> gcd(b % a, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"cards.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"cards.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), mx = max(mx, a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) c[i][<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) c[i][j] = c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; c[n][i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0</span>; f[<span class="number">1</span>][a[<span class="number">1</span>]] = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= mx; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[j][k]) </span><br><span class="line">f[j + <span class="number">1</span>][gcd(k, a[i + <span class="number">1</span>])] += f[j][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i = 0; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">//for(int j = 0; j &lt;= mx; j++) cout &lt;&lt; f[i][j] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) ans += f[i][<span class="number">1</span>] / c[n][i] - f[i<span class="number">-1</span>][<span class="number">1</span>] / c[n][i<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf\n"</span>, ans);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>std满分做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> mx,a[N],g[N][N],sum[N],visit[N][N],zy[N][N],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">int</span> y=a%b;</span><br><span class="line"><span class="keyword">while</span> (y)</span><br><span class="line">&#123;</span><br><span class="line">a=b; b=y; y=a%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i][j]) <span class="keyword">return</span> g[i][j];</span><br><span class="line">visit[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (j==<span class="number">1</span>) <span class="keyword">return</span> g[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i&gt;n) <span class="keyword">return</span> g[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i&lt;=sum[j] &amp;&amp; calc(i+<span class="number">1</span>,j)==<span class="number">0</span>) <span class="keyword">return</span> g[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">if</span> ((j==<span class="number">0</span> || a[k]%j) &amp;&amp; calc(i+<span class="number">1</span>,zy[j][k])==<span class="number">0</span>) <span class="keyword">return</span> g[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> g[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"cards.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"cards.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">cur=gcd(cur,a[i]);</span><br><span class="line">mx=max(mx,a[i]);</span><br><span class="line">f[<span class="number">1</span>][a[i]]+=(<span class="keyword">double</span>)<span class="number">1</span>/n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=mx;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span> (a[j]%i==<span class="number">0</span>) sum[i]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mx;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">zy[i][j]=gcd(i,a[j]);</span><br><span class="line"><span class="keyword">if</span> (cur!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>,<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=mx;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(f[i][j])&lt;=eps || i&gt;sum[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">if</span> (a[k]%j)</span><br><span class="line">f[i+<span class="number">1</span>][zy[j][k]]+=f[i][j]*<span class="number">1</span>/(n-i);</span><br><span class="line">f[i+<span class="number">1</span>][j]+=f[i][j]*(sum[j]-i)/(n-i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i+=<span class="number">2</span>) ans+=f[i][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.10lf "</span>,ans);</span><br><span class="line">calc(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (g[<span class="number">1</span>][<span class="number">0</span>]) <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>,<span class="number">1.0</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>,<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="秀秀的森林forest">秀秀的森林（forest）</span></h1><p>本题我的做法按道理说是会被卡掉的<br>但看起来数据很随机，因此跑得飞起，直接AC<br>先讲我的做法<br>考虑dp求直径的做法，<br>砍掉一条边后下面的子树的dp值都不会改变，只要更新砍掉的边到根的节点的dp值就可以<br>因为这样dp值减小，不方便更新，所以时间倒流把砍边改成加边，先dfs预处理每个点的父亲和dp值，加边时暴力向上跳更新<br>复杂度最坏应该会高达$O(n^2)$，然而数据太水</p><p>下面是正解<br>仍然时间倒流，加上一条边后新树的直径只可能是以之前两棵树的直径端点为端点<br>这样就好做了<br>连边时4个端点两两组合用LCA求路径最大值，维护答案就可以了</p><p>之前好像见过这题。。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmin</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = min(a, b); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmax</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = max(a, b); &#125;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot, ena[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> X[maxn], Y[maxn], n, a[maxn], fa[maxn], d[maxn], rt[maxn], q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rt[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> rt[x] = get(rt[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[maxn], res = <span class="number">1</span>, lans[maxn], f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">ans[x] = f[x] = a[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x] &amp;&amp; ena[ver[i]]) &#123;</span><br><span class="line">ans[x] = max(ans[x], ans[ver[i]]);</span><br><span class="line">ans[x] = max(ans[x], f[x] + f[ver[i]]);</span><br><span class="line">f[x] = max(f[x], f[ver[i]] + a[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">fa[x] = pa; d[x] = d[pa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) dfs(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Power</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lres = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) lres = lres * x % mod;</span><br><span class="line"><span class="keyword">return</span> lres;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"forest.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"forest.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) X[i] = read(), Y[i] = read(), add(X[i], Y[i]), add(Y[i], X[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rt[i] = i, f[i] = a[i], ans[i] = a[i], res = res * ans[i] % mod;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">lans[n] = res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Q = <span class="number">1</span>; Q &lt; n; Q++) &#123;</span><br><span class="line">q[Q] = read();</span><br><span class="line"><span class="keyword">if</span>(d[X[q[Q]]] &gt; d[Y[q[Q]]]) swap(X[q[Q]], Y[q[Q]]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> rx = get(X[q[i]]), ry = get(Y[q[i]]);</span><br><span class="line">ena[ry] = <span class="number">1</span>;</span><br><span class="line">res = res * Power(ans[rx], mod - <span class="number">2</span>) % mod * Power(ans[ry], mod - <span class="number">2</span>) % mod;</span><br><span class="line">rt[ry] = rx;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = ry; j != rx; j = fa[j]) update(fa[j]);</span><br><span class="line">res = res * ans[rx] % mod;</span><br><span class="line">lans[i] = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, lans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="秀秀的照片photo">秀秀的照片（photo）</span></h1><blockquote><p>“组合数问题都是好题”</p></blockquote><p>组合数推出公式就可以了<br>显然的性质是<br>最左边和最右边一列不同颜色个数应当相同<br>中间m-2列的颜色是最两边两列颜色集合的交集的子集<br>枚举中间部分颜色个数，在枚举两端的独特的颜色个数，用C求出选颜色的方案，还要乘以用恰好那么多颜色涂那么多格子的方案数，这个用第二类stirling数求，$S[i][j]$表示i个球放到j个盒子中，每个盒子都有球的方案数，这里球对应格子，盒子对应颜色，有<br>$$S[i][j]=S[i-1][j-1]+S[i-1][j]\times j$$<br>由于考虑排列，所以乘以阶乘，最后的结果为<br>$$<br>\sum_{i=0}^{min(n, k)}C_k^i \times i^{n\times(m-2)}\sum_{j=0}^{min(n-i, (k-i)/2)}C_{k-i}^j \times C_{k-i-j}^j\times S_{n}^{i+j}\times (i+j)!<br>$$<br>按照组合数学常见套路，能预处理的都预处理<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>, maxn = <span class="number">4000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll fac[maxn + <span class="number">10</span>], infac[maxn + <span class="number">10</span>], ans, S[<span class="number">4010</span>][<span class="number">4010</span>];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fac[x] * infac[y] % mod * infac[x - y] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"photo.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"photo.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">infac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++) fac[i] = fac[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">infac[maxn] = Power(fac[maxn], mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = maxn - <span class="number">1</span>; i; i--) infac[i] = infac[i+<span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) </span><br><span class="line">S[i][j] = (S[i<span class="number">-1</span>][j<span class="number">-1</span>] + S[i<span class="number">-1</span>][j] * j % mod) % mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= min(n, k); i++) &#123;</span><br><span class="line">ll tmp = C(k, i) * Power(i, n *(m - <span class="number">2</span>)) % mod;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j + i + j &lt;= k, i + j &lt;= n; j++) &#123;</span><br><span class="line">ll tt = C(k - i, j) * C(k - i - j, j) % mod;</span><br><span class="line">ll t2 = S[n][i + j] * fac[i + j] % mod; t2 = t2 * t2 % mod;</span><br><span class="line">sum = (sum + tt * t2 % mod) % mod;</span><br><span class="line">&#125; </span><br><span class="line">ans = (ans + tmp * sum % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这场比赛前两题我用自己的非正解算法水到了188分&lt;br&gt;真是好水的数据&lt;br&gt;题目出的很模拟赛&lt;br&gt;
    
    </summary>
    
      <category term="集训" scheme="http://yoursite.com/categories/%E9%9B%86%E8%AE%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ1997 [Hnoi2010]Planar</title>
    <link href="http://yoursite.com/2019/07/05/BZOJ1997-Hnoi2010-Planar/"/>
    <id>http://yoursite.com/2019/07/05/BZOJ1997-Hnoi2010-Planar/</id>
    <published>2019-07-05T10:18:09.000Z</published>
    <updated>2019-07-05T10:29:28.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1997" target="_blank" rel="noopener">BZOJ1997</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意判断是否是平面图<br>首先平面图边数$\leq3n-6$，这样边数是$O(n)$的了<br>题目中给了一条曼哈顿回路，也就是说要做的是把剩下的边加入这个环里，加入的边要么在里面，要么在外面，两两不想交<br>这就是一个2-sat问题了<br>每条边拆成两个点，有一些要加入的边无法同时在里或同时在外，这时把他们连一些边，然后跑tarjan，存在一条边对应的两个点在同一强联通分量则不行</p><p>然而这题我做了整整半天的时间<br>最开始用dfs，一直觉得dfs和tarjan没什么区别，dfs还好写<br>但20分过不了<br>迫不得已改写tarjan，结果依旧20分<br>最后发现判定边数过多直接continue太早了，还没读完剩下的数据呢。。。<br>洛谷终于过了，但BZOJ总是TLE<br>最后原来是我因为最开始RE所以数组开的特别大，卡MLE的那种，结果多组数据清数组时花了大量的时间。。。<br>所以事实上数组不是开的越大越好，即使不会MLE也不行<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5060</span>, maxm = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxm], Next[maxm], tot, m, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> e[<span class="number">210</span>][<span class="number">210</span>], a[maxn], X[maxn], Y[maxn], cnt, pos[maxn];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], sta[maxn], top, bel[maxn], ins[maxn], num, scc;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">add(x, y + cnt); add(x + cnt, y);</span><br><span class="line">add(y, x + cnt); add(y + cnt, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line"><span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line"><span class="built_in">memset</span>(ins, <span class="number">0</span>, <span class="keyword">sizeof</span>(ins));</span><br><span class="line">tot = cnt = num = scc = top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">ins[x] = <span class="number">1</span>; sta[++top] = x;</span><br><span class="line">dfn[x] = low[x] = ++num;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(!dfn[ver[i]]) tarjan(ver[i]), low[x] = min(low[x], low[ver[i]]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ins[ver[i]] == <span class="number">1</span>) low[x] = min(low[x], dfn[ver[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x]) &#123;</span><br><span class="line">scc++;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(z != x) </span><br><span class="line">z = sta[top--], ins[z] = <span class="number">2</span>, bel[z] = scc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">jud</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt * <span class="number">2</span>; i++) <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) </span><br><span class="line"><span class="keyword">if</span>(bel[i] == bel[i + cnt]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line">clear();</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), e[x][y] = e[y][x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), pos[a[i]] = i;</span><br><span class="line"><span class="keyword">if</span>(m &gt; <span class="number">3</span> * n - <span class="number">6</span>) &#123; <span class="built_in">printf</span>(<span class="string">"NO\n"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) e[a[i]][a[i+<span class="number">1</span>]] = e[a[i+<span class="number">1</span>]][a[i]] = <span class="number">0</span>;</span><br><span class="line">e[a[n]][a[<span class="number">1</span>]] = e[a[<span class="number">1</span>]][a[n]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) <span class="keyword">if</span>(e[i][j]) &#123;</span><br><span class="line">X[++cnt] = pos[i], Y[cnt] = pos[j];</span><br><span class="line"><span class="keyword">if</span>(X[cnt] &gt; Y[cnt]) swap(X[cnt], Y[cnt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(X[i] &lt; X[j] &amp;&amp; X[j] &lt; Y[i] &amp;&amp; Y[i] &lt; Y[j]) proc(i, j);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X[j] &lt; X[i] &amp;&amp; X[i] &lt; Y[j] &amp;&amp; Y[j] &lt; Y[i]) proc(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(jud()) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1997&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1997&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题意判断是否是平面图&lt;br&gt;首先平面图边数$\leq3n-6$，这样边数是$O(n)$的了&lt;br&gt;题目中给了一条曼哈顿回路，也就是说要做的是把剩下的边加入这个环里，加入的边要么在里面，要么在外面，两两不想交&lt;br&gt;这就是一个2-sat问题了&lt;br&gt;每条边拆成两个点，有一些要加入的边无法同时在里或同时在外，这时把他们连一些边，然后跑tarjan，存在一条边对应的两个点在同一强联通分量则不行&lt;/p&gt;
&lt;p&gt;然而这题我做了整整半天的时间&lt;br&gt;最开始用dfs，一直觉得dfs和tarjan没什么区别，dfs还好写&lt;br&gt;但20分过不了&lt;br&gt;迫不得已改写tarjan，结果依旧20分&lt;br&gt;最后发现判定边数过多直接continue太早了，还没读完剩下的数据呢。。。&lt;br&gt;洛谷终于过了，但BZOJ总是TLE&lt;br&gt;最后原来是我因为最开始RE所以数组开的特别大，卡MLE的那种，结果多组数据清数组时花了大量的时间。。。&lt;br&gt;所以事实上数组不是开的越大越好，即使不会MLE也不行&lt;br&gt;
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="2-sat" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/2-sat/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ4945 [Noi2017]游戏</title>
    <link href="http://yoursite.com/2019/07/04/BZOJ4945-Noi2017-%E6%B8%B8%E6%88%8F/"/>
    <id>http://yoursite.com/2019/07/04/BZOJ4945-Noi2017-游戏/</id>
    <published>2019-07-04T10:18:39.000Z</published>
    <updated>2019-07-06T14:52:52.721Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4945" target="_blank" rel="noopener">BZOJ4945</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>本题标记着2-sat达到一个高潮<br>如果没有x，那就是一个裸的2-sat<br>然而x的个数很小，可以暴力枚举，所以实际上还是裸的2-sat<br>每个x枚举<br>1.不能选A，那么就是B、C二选一<br>2.不能选B，那么就是A、C二选一<br>这样就已经包含了ABC三种情况，所以暴力枚举的复杂度为$2^d$</p><p>下面说一说裸的2-sat怎么做<br>用tarjan算法求出所有的强连通分量<br>如果某个对偶的两点位于同一分量，则无解<br>否则有解，那么问题就是如何输出任意一解<br>对于缩点后的反图，按拓扑序，选当前节点，把她得姐妹节点删除<br>事实上不用拓扑排序，节点scc编号的大小就是反图拓扑序的大小，因此姐妹点选scc小的即可</p><p>tarjan比dfs快，我终于明白了，dfs是$O(nm)$的</p><p>这里还有一些要注意的地方，如果一个限制中提到了一定不会出现赛车，设此限制为$(x\to y)$，若x不可能选，则直接continue，若y不可能选，则x连向他的姐妹节点，巧妙地表达了x不可能选</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150010</span>, maxm = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxm], Next[maxm], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> str[maxn], qx[maxm], qy[maxm], car[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;, &#123;<span class="string">'A'</span>, <span class="string">'C'</span>&#125;, &#123;<span class="string">'A'</span>, <span class="string">'B'</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n, d, m, xpos[<span class="number">10</span>], xcnt, X[maxm], Y[maxm];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], num, scc, ins[maxn], sta[maxn], top, bel[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> rnk[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ins[x] = <span class="number">1</span>; sta[++top] = x;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ver[i]]) tarjan(ver[i]), low[x] = min(low[x], low[ver[i]]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[ver[i]] == <span class="number">1</span>) low[x] = min(low[x], dfn[ver[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x] == low[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = <span class="number">0</span>; scc++;</span><br><span class="line">        <span class="keyword">while</span>(z != x) &#123;</span><br><span class="line">            z = sta[top--]; ins[z] = <span class="number">2</span>; bel[z] = scc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; str + 1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(ins, <span class="number">0</span>, <span class="keyword">sizeof</span>(ins));</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">    num = scc = top = tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[X[i]] - <span class="string">'a'</span> == qx[i] - <span class="string">'A'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> x = rnk[str[X[i]] - <span class="string">'a'</span>][qx[i] - <span class="string">'A'</span>];</span><br><span class="line">        <span class="keyword">int</span> y = rnk[str[Y[i]] - <span class="string">'a'</span>][qy[i] - <span class="string">'A'</span>];</span><br><span class="line">        <span class="keyword">if</span>(str[Y[i]] - <span class="string">'a'</span> == qy[i] - <span class="string">'A'</span>) &#123; add(X[i] + x * n, X[i] + n * (<span class="number">1</span> - x)); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        add(x * n + X[i], y * n + Y[i]);</span><br><span class="line">        add((<span class="number">1</span> - y) * n + Y[i], (<span class="number">1</span> - x) * n + X[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(bel[i] == bel[i + n]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">if</span>(bel[i] &lt; bel[i + n]) <span class="built_in">printf</span>(<span class="string">"%c"</span>, car[str[i] - <span class="string">'a'</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>, car[str[i] - <span class="string">'a'</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; xcnt) <span class="keyword">return</span> solve();</span><br><span class="line">    str[xpos[x]] = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span>(dfs(x + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    str[xpos[x]] = <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">if</span>(dfs(x + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("input", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("user_out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, str + <span class="number">1</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(str[i] == <span class="string">'x'</span>) xpos[++xcnt] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d %c%d %c"</span>, &amp;X[i], &amp;qx[i], &amp;Y[i], &amp;qy[i]);</span><br><span class="line">    <span class="keyword">if</span>(!dfs(<span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=4945&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ4945&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;本题标记着2-sat达到一个高潮&lt;br&gt;如果没有x，那就是一个裸的2-sat&lt;br&gt;然而x的个数很小，可以暴力枚举，所以实际上还是裸的2-sat&lt;br&gt;每个x枚举&lt;br&gt;1.不能选A，那么就是B、C二选一&lt;br&gt;2.不能选B，那么就是A、C二选一&lt;br&gt;这样就已经包含了ABC三种情况，所以暴力枚举的复杂度为$2^d$&lt;/p&gt;
&lt;p&gt;下面说一说裸的2-sat怎么做&lt;br&gt;用tarjan算法求出所有的强连通分量&lt;br&gt;如果某个对偶的两点位于同一分量，则无解&lt;br&gt;否则有解，那么问题就是如何输出任意一解&lt;br&gt;对于缩点后的反图，按拓扑序，选当前节点，把她得姐妹节点删除&lt;br&gt;事实上不用拓扑排序，节点scc编号的大小就是反图拓扑序的大小，因此姐妹点选scc小的即可&lt;/p&gt;
&lt;p&gt;tarjan比dfs快，我终于明白了，dfs是$O(nm)$的&lt;/p&gt;
&lt;p&gt;这里还有一些要注意的地方，如果一个限制中提到了一定不会出现赛车，设此限制为$(x\to y)$，若x不可能选，则直接continue，若y不可能选，则x连向他的姐妹节点，巧妙地表达了x不可能选&lt;/p&gt;
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="2-sat" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/2-sat/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2208 [Jsoi2010]连通数</title>
    <link href="http://yoursite.com/2019/07/04/BZOJ2208-Jsoi2010-%E8%BF%9E%E9%80%9A%E6%95%B0/"/>
    <id>http://yoursite.com/2019/07/04/BZOJ2208-Jsoi2010-连通数/</id>
    <published>2019-07-04T10:10:56.000Z</published>
    <updated>2019-07-04T10:13:18.925Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2208" target="_blank" rel="noopener">BZOJ2208</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>传递闭包裸题<br>只是想写写bitset如何优化<br>看代码就明白了<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; f[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line"><span class="keyword">if</span>(s[j - <span class="number">1</span>] == <span class="string">'1'</span> || i == j) f[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line"><span class="keyword">if</span>(f[j].test(i)) f[j] |= f[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += f[i].count();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2208&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2208&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;传递闭包裸题&lt;br&gt;只是想写写bitset如何优化&lt;br&gt;看代码就明白了&lt;br&gt;
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="传递闭包" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3160 万径人踪灭</title>
    <link href="http://yoursite.com/2019/07/03/BZOJ3160-%E4%B8%87%E5%BE%84%E4%BA%BA%E8%B8%AA%E7%81%AD/"/>
    <id>http://yoursite.com/2019/07/03/BZOJ3160-万径人踪灭/</id>
    <published>2019-07-03T04:22:25.000Z</published>
    <updated>2019-07-03T11:20:44.605Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3160" target="_blank" rel="noopener">BZOJ3160</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意在题面里已经说过了<br>对于第三点限制，只要算出所有满足1、2点的子序列，再减去回文子串的个数就可以<br>回文子串个数直接裸的马拉车<br>考虑如何求满足的子序列个数<br>枚举对称轴x，由于位置对称，我们只要知道有多少对是相等的就可以（这里的一对指的是位置为$i$和$2x-i$的一对位置<br>这个形式很像多项式卷积，因此用fft实现<br>a和b分开处理，处理a时把a的位置置为1，与自己卷积，得到的多项式中只有对称才会产生贡献，只要询问第$2x$位就可以</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">800010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; cp;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">char</span> str[maxn], nstr[maxn];</span><br><span class="line"><span class="keyword">int</span> n, r[maxn], x[maxn], y[maxn], f[maxn]; </span><br><span class="line">ll ans;</span><br><span class="line">cp a[maxn], b[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(cp *p, <span class="keyword">int</span> N, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) <span class="keyword">if</span>(i &lt; r[i]) swap(p[i], p[r[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; N; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="function">cp <span class="title">omega</span><span class="params">(<span class="built_in">cos</span>(pi / mid), inv * <span class="built_in">sin</span>(pi / mid))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="function">cp <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++, w *= omega) &#123;</span><br><span class="line">cp x = p[i + j], y = w * p[i + j + mid];</span><br><span class="line">p[i + j] = x + y, p[i + j + mid] = x - y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nn = <span class="number">0</span>, mx = <span class="number">1</span>, pos = <span class="number">1</span>;</span><br><span class="line">nstr[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">nstr[++nn] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nstr[++nn] = str[i], nstr[++nn] = <span class="string">'#'</span>;</span><br><span class="line">nstr[++nn] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; i++) &#123;</span><br><span class="line">f[i] = min(f[<span class="number">2</span> * pos - i], mx - i);</span><br><span class="line"><span class="keyword">if</span>(f[i] &lt; <span class="number">1</span>) f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(nstr[i + f[i]] == nstr[i - f[i]]) f[i]++;</span><br><span class="line"><span class="keyword">if</span>(i + f[i] &gt; mx) mx = f[i] + i, pos = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; i++) ans = (ans - f[i] / <span class="number">2</span> + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>); n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(str[i] == <span class="string">'a'</span>) a[i] = cp(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">else</span> b[i] = cp(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">1</span>, wei = <span class="number">0</span>; <span class="keyword">while</span>(N &lt;= <span class="number">2</span> * n) N &lt;&lt;= <span class="number">1</span>, wei++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (wei - <span class="number">1</span>));</span><br><span class="line">fft(a, N, <span class="number">1</span>); fft(b, N, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) a[i] *= a[i], b[i] *= b[i];</span><br><span class="line">fft(a, N, <span class="number">-1</span>); fft(b, N, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) x[i] = (<span class="keyword">int</span>)(a[i].real() / N + <span class="number">0.5</span>), y[i] = (<span class="keyword">int</span>)(b[i].real() / N + <span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = x[i] + y[i]; </span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) tmp++;</span><br><span class="line">tmp /= <span class="number">2</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; x[i] &lt;&lt; ' ' &lt;&lt; y[i] &lt;&lt; ' ' &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">ans += (Power(<span class="number">2</span>, tmp) - <span class="number">1</span> + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">manacher();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3160&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3160&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题意在题面里已经说过了&lt;br&gt;对于第三点限制，只要算出所有满足1、2点的子序列，再减去回文子串的个数就可以&lt;br&gt;回文子串个数直接裸的马拉车&lt;br&gt;考虑如何求满足的子序列个数&lt;br&gt;枚举对称轴x，由于位置对称，我们只要知道有多少对是相等的就可以（这里的一对指的是位置为$i$和$2x-i$的一对位置&lt;br&gt;这个形式很像多项式卷积，因此用fft实现&lt;br&gt;a和b分开处理，处理a时把a的位置置为1，与自己卷积，得到的多项式中只有对称才会产生贡献，只要询问第$2x$位就可以&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="多项式" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3527 [Zjoi2014]力</title>
    <link href="http://yoursite.com/2019/07/02/BZOJ3527-Zjoi2014-%E5%8A%9B/"/>
    <id>http://yoursite.com/2019/07/02/BZOJ3527-Zjoi2014-力/</id>
    <published>2019-07-02T10:50:01.000Z</published>
    <updated>2019-07-02T10:56:16.580Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3527" target="_blank" rel="noopener">BZOJ3527</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>我们要快速的求出<br>$$<br>\sum_{j=1}^i\frac{q_j}{(i-j)^2} \\<br>\sum_{j=i}^n\frac{q_j}{(i-j)^2}<br>$$<br>可以看成是分子*分母的倒数，分母递增或递减<br>构建两个个数组<br>$$b_i = \frac{1}{i^2} \\<br>c_i = \frac{1}{(n+1-i)^2}$$<br>分别与q卷积，<br>得到的新b数组的第$i$项是前部分的结果<br>新c数组的第$i+n+1$项是后半部分<br>怎么得出来的可以画图看看<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; cp;</span><br><span class="line"><span class="keyword">double</span> q[maxn];</span><br><span class="line">cp a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="keyword">int</span> n, r[maxn];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sq</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(cp *p, <span class="keyword">int</span> N, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) <span class="keyword">if</span>(i &lt; r[i]) swap(p[i], p[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; N; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">cp <span class="title">omega</span><span class="params">(<span class="built_in">cos</span>(pi / mid), inv * <span class="built_in">sin</span>(pi / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">cp <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++, w *= omega) &#123;</span><br><span class="line">                cp x = p[i + j], y = w * p[i + j + mid];</span><br><span class="line">                p[i + j] = x + y, p[i + j + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;q[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = cp(q[i], <span class="number">0</span>), b[i] = cp(<span class="number">1.0</span> / sq(i), <span class="number">0</span>), c[i] = cp(<span class="number">1.0</span> / sq(n - i + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span>, wei = <span class="number">0</span>; <span class="keyword">while</span>(N &lt; <span class="number">2</span> * n) N &lt;&lt;= <span class="number">1</span>, wei++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (wei - <span class="number">1</span>));</span><br><span class="line">    fft(a, N, <span class="number">1</span>); fft(b, N, <span class="number">1</span>); fft(c, N, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) b[i] *= a[i], c[i] *= a[i];</span><br><span class="line">    fft(b, N, <span class="number">-1</span>), fft(c, N, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, b[i].real() / N - c[i + n + <span class="number">1</span>].real() / N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3527&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3527&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;我们要快速的求出&lt;br&gt;$$&lt;br&gt;\sum_{j=1}^i\frac{q_j}{(i-j)^2} \\&lt;br&gt;\sum_{j=i}^n\frac{q_j}{(i-j)^2}&lt;br&gt;$$&lt;br&gt;可以看成是分子*分母的倒数，分母递增或递减&lt;br&gt;构建两个个数组&lt;br&gt;$$b_i = \frac{1}{i^2} \\&lt;br&gt;c_i = \frac{1}{(n+1-i)^2}$$&lt;br&gt;分别与q卷积，&lt;br&gt;得到的新b数组的第$i$项是前部分的结果&lt;br&gt;新c数组的第$i+n+1$项是后半部分&lt;br&gt;怎么得出来的可以画图看看&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="多项式" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ4827 [Hnoi2017]礼物</title>
    <link href="http://yoursite.com/2019/07/01/BZOJ4827-Hnoi2017-%E7%A4%BC%E7%89%A9/"/>
    <id>http://yoursite.com/2019/07/01/BZOJ4827-Hnoi2017-礼物/</id>
    <published>2019-07-01T14:19:45.000Z</published>
    <updated>2019-07-01T14:29:09.339Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4827" target="_blank" rel="noopener">BZOJ4827</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意求<br>$$<br>min{\sum_{i=1}^n(x_i - y_{i+k} + C)}<br>$$<br>C是每个增加的亮度，k是旋转的位数<br>把他拆开可以写成<br>$$<br>\sum_{i=1}^n(x_i^2+y_i^2) +\sum_{i=1}^n2C(x_i-y_i)+nC^2-2\sum_{i=1}^nx_iy_{i+k}<br>$$<br>难点是求最后一项$\sum_{i=1}^nx_iy_{i+k}$的最大值<br>这种形式经常使用多项式卷积<br>把x数组倒序，y后面再连一个y，得到的两个新数组卷积<br>最后上面的式子就是$x^{n+1+k}$的系数，从$x^{n+1}$到$x^{n+n}$取最大值就可以了<br>之后C可以在m的值域内枚举，也可以直接得到，利用二次函数最值，可知$C=\frac{\sum_{i=1}^ny_i-\sum_{i=1}^nx_i}{n} $<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; cp;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> x[maxn * <span class="number">8</span>], y[maxn * <span class="number">8</span>], m, n, r[maxn * <span class="number">8</span>], f[maxn * <span class="number">8</span>], ans;</span><br><span class="line">cp a[maxn * <span class="number">8</span>], b[maxn * <span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(cp *p, <span class="keyword">int</span> N, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) <span class="keyword">if</span>(i &lt; r[i]) swap(p[i], p[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; N; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        cp omega = cp(<span class="built_in">cos</span>(pi / mid), inv * <span class="built_in">sin</span>(pi / mid));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">cp <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j++, w *= omega) &#123;</span><br><span class="line">                cp x = p[i + j], y = w * p[i + j + mid];</span><br><span class="line">                p[i + j] = x + y; p[i + j + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("gift9.in", "r", stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = cp(x[n + <span class="number">1</span> - i], <span class="number">0</span>), b[i] = b[i + n] = cp(y[i], <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; ' ' &lt;&lt; b[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span>, wei = <span class="number">0</span>; <span class="keyword">while</span>(N &lt; <span class="number">3</span> * n) N &lt;&lt;= <span class="number">1</span>, wei++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (wei - <span class="number">1</span>));</span><br><span class="line">    fft(a, N, <span class="number">1</span>); fft(b, N, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) a[i] *= b[i];</span><br><span class="line">    fft(a, N, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) f[i] = (<span class="keyword">int</span>)(a[i].real() / N + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += x[i] * x[i] + y[i] * y[i], c += y[i] - x[i];</span><br><span class="line">    c = round(c / n);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + n; i++) tmp = max(tmp, f[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += <span class="number">2</span> * c * (x[i] - y[i]);</span><br><span class="line">    ans += n * c * c - <span class="number">2</span> * tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=4827&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ4827&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题意求&lt;br&gt;$$&lt;br&gt;min{\sum_{i=1}^n(x_i - y_{i+k} + C)}&lt;br&gt;$$&lt;br&gt;C是每个增加的亮度，k是旋转的位数&lt;br&gt;把他拆开可以写成&lt;br&gt;$$&lt;br&gt;\sum_{i=1}^n(x_i^2+y_i^2) +\sum_{i=1}^n2C(x_i-y_i)+nC^2-2\sum_{i=1}^nx_iy_{i+k}&lt;br&gt;$$&lt;br&gt;难点是求最后一项$\sum_{i=1}^nx_iy_{i+k}$的最大值&lt;br&gt;这种形式经常使用多项式卷积&lt;br&gt;把x数组倒序，y后面再连一个y，得到的两个新数组卷积&lt;br&gt;最后上面的式子就是$x^{n+1+k}$的系数，从$x^{n+1}$到$x^{n+n}$取最大值就可以了&lt;br&gt;之后C可以在m的值域内枚举，也可以直接得到，利用二次函数最值，可知$C=\frac{\sum_{i=1}^ny_i-\sum_{i=1}^nx_i}{n} $&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="多项式" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3930 [CQOI2015]选数</title>
    <link href="http://yoursite.com/2019/06/30/BZOJ3930-CQOI2015-%E9%80%89%E6%95%B0/"/>
    <id>http://yoursite.com/2019/06/30/BZOJ3930-CQOI2015-选数/</id>
    <published>2019-06-30T13:58:11.000Z</published>
    <updated>2019-07-01T15:04:38.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3930" target="_blank" rel="noopener">BZOJ3930</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>整体除以gcd，相当于在一个区间内选gcd=1的方案数<br>$$<br>f(d) = \sum [gcd(a_i)=d] \\<br>F(d) = \sum [d|gcd(a_i)] = \sum_{d|n}f(n)<br>$$<br>$$<br>f(1) = \sum_{i=1}^{R}\mu(i)(\frac{R}{i}-\frac{L-1}{i})^k<br>$$<br>难点在$\mu$的计算上，因为左右端点都可能很大<br>所以使用杜教筛，很裸地计算$\mu$的前缀和<br>在这道题里记一下杜教筛<br>记$S(n)=\sum_{i=1}^nf(i)$，有$h=f*g$<br>$$<br>\sum_{i=1}^Nh(i) = \sum_{i=1}^N\sum_{d|i}g(d)f(\frac{i}{d}) \\<br>= \sum_{d=1}^N\sum_{i=1}^{\frac{N}{d}}g(d)f(i) \\<br>= \sum_{d=1}^Ng(d)\sum_{i=1}^{\frac{N}{d}}f(i) \\<br>= \sum_{d=1}^Ng(d)S(\frac{N}{d})<br>$$<br>关键的一步，提取后面的第一项<br>$$<br>\sum_{i=1}^Nh(i) = g(1)S(N) + \sum_{d=2}^Ng(d)S(\frac{N}{d})<br>$$<br>$$<br>g(1)S(N) = \sum_{i=1}^Nh(i) - \sum_{d=2}^Ng(d)S(\frac{N}{d})<br>$$<br>要求前面h的前缀和好求，后面可以整除分块<br>此乃杜教筛也</p><p>对于现在要求的mu，就是这样<br>$$<br>S(N) = 1 - \sum_{d=2}^NS(\frac{N}{d})<br>$$<br>就做完了<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> v[maxn], prim[maxn], cnt;</span><br><span class="line">ll sum[maxn], n, k, L, R, ans;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, ll&gt; miu;</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    v[<span class="number">0</span>] = v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    sum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) &#123; prim[++cnt] = i; sum[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prim[j] &lt;= N; j++) &#123;</span><br><span class="line">            v[i * prim[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prim[j]) sum[i * prim[j]] = -sum[i];</span><br><span class="line">            <span class="keyword">else</span> &#123; sum[i * prim[j]] = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) sum[i] = (sum[i] + sum[i<span class="number">-1</span>] + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">100000</span>) <span class="keyword">return</span> sum[x];</span><br><span class="line">    <span class="keyword">if</span>(miu[x]) <span class="keyword">return</span> miu[x];</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>, r; l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        res = (res + calc(x / l) * (r - l + <span class="number">1</span>) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> miu[x] = (<span class="number">1l</span>l + mod - res) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;n, &amp;k, &amp;L, &amp;R);</span><br><span class="line">    init(<span class="number">100000</span>);</span><br><span class="line">    L = (L - <span class="number">1</span>) / k; R = R / k;</span><br><span class="line">    <span class="keyword">for</span>(ll l = <span class="number">1</span>, r; l &lt;= R; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = R / (R / l); <span class="keyword">if</span>(l &lt;= L) r = min(r, L / (L / l)); </span><br><span class="line">        ans = (ans + (calc(r) - calc(l - <span class="number">1</span>) + mod) % mod * Power(R / l - L / l, n) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3930&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3930&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;整体除以gcd，相当于在一个区间内选gcd=1的方案数&lt;br&gt;$$&lt;br&gt;f(d) = \sum [gcd(a_i)=d] \\&lt;br&gt;F(d) = \sum [d|gcd(a_i)] = \sum_{d|n}f(n)&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;f(1) = \sum_{i=1}^{R}\mu(i)(\frac{R}{i}-\frac{L-1}{i})^k&lt;br&gt;$$&lt;br&gt;难点在$\mu$的计算上，因为左右端点都可能很大&lt;br&gt;所以使用杜教筛，很裸地计算$\mu$的前缀和&lt;br&gt;在这道题里记一下杜教筛&lt;br&gt;记$S(n)=\sum_{i=1}^nf(i)$，有$h=f*g$&lt;br&gt;$$&lt;br&gt;\sum_{i=1}^Nh(i) = \sum_{i=1}^N\sum_{d|i}g(d)f(\frac{i}{d}) \\&lt;br&gt;= \sum_{d=1}^N\sum_{i=1}^{\frac{N}{d}}g(d)f(i) \\&lt;br&gt;= \sum_{d=1}^Ng(d)\sum_{i=1}^{\frac{N}{d}}f(i) \\&lt;br&gt;= \sum_{d=1}^Ng(d)S(\frac{N}{d})&lt;br&gt;$$&lt;br&gt;关键的一步，提取后面的第一项&lt;br&gt;$$&lt;br&gt;\sum_{i=1}^Nh(i) = g(1)S(N) + \sum_{d=2}^Ng(d)S(\frac{N}{d})&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;g(1)S(N) = \sum_{i=1}^Nh(i) - \sum_{d=2}^Ng(d)S(\frac{N}{d})&lt;br&gt;$$&lt;br&gt;要求前面h的前缀和好求，后面可以整除分块&lt;br&gt;此乃杜教筛也&lt;/p&gt;
&lt;p&gt;对于现在要求的mu，就是这样&lt;br&gt;$$&lt;br&gt;S(N) = 1 - \sum_{d=2}^NS(\frac{N}{d})&lt;br&gt;$$&lt;br&gt;就做完了&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
      <category term="杜教筛" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2440 完全平方数</title>
    <link href="http://yoursite.com/2019/06/30/BZOJ2440-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>http://yoursite.com/2019/06/30/BZOJ2440-完全平方数/</id>
    <published>2019-06-30T11:28:49.000Z</published>
    <updated>2019-06-30T13:39:00.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2440" target="_blank" rel="noopener">BZOJ2440</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>二分答案，转化为求小于等于N的非完全平方数倍数的数有几个<br>使用容斥原理，<br>$$ans=n-1个质因子平方+2个质因子平方-3质因子平方+…$$<br>枚举所有次数为2的因数i，个数有$\frac{n}{i^2}$个，系数就是$\mu(i)$<br>不要忘记莫比乌斯函数本质就是数论中的容斥<br>我不会透露自己想反演做法想了半天<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll miu[maxn], v[maxn], prim[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">v[<span class="number">0</span>] = v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">miu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123; prim[++cnt] = i; miu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prim[j] &lt;= N; j++) &#123;</span><br><span class="line">v[i * prim[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i % prim[j]) miu[i * prim[j]] = -miu[i];</span><br><span class="line"><span class="keyword">else</span> &#123; miu[i * prim[j]] = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">res += miu[i] * (n / (i * i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">init(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line">ll k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;k);</span><br><span class="line">ll l = <span class="number">1</span>, r = <span class="number">1e10</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(calc(mid) &lt; k) l = mid + <span class="number">1</span>; <span class="keyword">else</span> r = mid; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2440&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2440&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;二分答案，转化为求小于等于N的非完全平方数倍数的数有几个&lt;br&gt;使用容斥原理，&lt;br&gt;$$ans=n-1个质因子平方+2个质因子平方-3质因子平方+…$$&lt;br&gt;枚举所有次数为2的因数i，个数有$\frac{n}{i^2}$个，系数就是$\mu(i)$&lt;br&gt;不要忘记莫比乌斯函数本质就是数论中的容斥&lt;br&gt;我不会透露自己想反演做法想了半天&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="容斥原理" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ4407 于神之怒加强版</title>
    <link href="http://yoursite.com/2019/06/30/BZOJ4407-%E4%BA%8E%E7%A5%9E%E4%B9%8B%E6%80%92%E5%8A%A0%E5%BC%BA%E7%89%88/"/>
    <id>http://yoursite.com/2019/06/30/BZOJ4407-于神之怒加强版/</id>
    <published>2019-06-30T07:37:38.000Z</published>
    <updated>2019-06-30T11:26:46.680Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4407" target="_blank" rel="noopener">BZOJ4407</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>求<br>$$<br>\sum_{i=1}^n\sum_{j=1}^mgcd(i, j)^k<br>$$<br>提取最大公约数d得到<br>$$<br>\sum_{d=1}^nd^k\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i, j) = 1]<br>$$<br>常见的套用反演，得到<br>$$<br>\sum_{d=1}^nd^k\sum_{i=1}^n\mu(i)\lfloor\frac{n}{id}\rfloor\lfloor\frac{m}{id}\rfloor<br>$$<br>令$T=id$<br>$$<br>\sum_{T=1}^n\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{d|T}d^k\mu(\frac{T}{d})<br>$$<br>前者整除分块，后者线性筛<br>对于线性筛，还是只需要想想枚举到一个已出现的质因子的情况，新的所有的因数可以看成旧的所有因数*p，再并上原来不含p的因数<br>前者更改前后$\mu$值没有变，后者在操作后变成了0<br>所以只要乘上$p^k$即可<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>, maxn = <span class="number">5000010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll s[maxn], prim[maxn], cnt, val[maxn], ans;</span><br><span class="line"><span class="keyword">int</span> n, m, k, v[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">v[<span class="number">0</span>] = v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">s[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!v[i]) &#123; prim[++cnt] = i; val[cnt] = Power(i, k); s[i] = (val[cnt] - <span class="number">1</span> + mod) % mod; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prim[j] &lt;= N; j++) &#123;</span><br><span class="line">v[i * prim[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i % prim[j]) s[i * prim[j]] = s[i] * s[prim[j]] % mod;</span><br><span class="line"><span class="keyword">else</span> &#123; s[i * prim[j]] = s[i] * val[j] % mod; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= 5; i++) cout &lt;&lt; s[i] &lt;&lt; ' '; cout &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) s[i] = (s[i] + s[i<span class="number">-1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;T, &amp;k);</span><br><span class="line">init(<span class="number">5000000</span>);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n &amp;&amp; l &lt;= m; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min(n / (n / l), m / (m / l));</span><br><span class="line">ans = (ans + <span class="number">1l</span>l * (n / l) * (m / l) % mod * (s[r] - s[l<span class="number">-1</span>] + mod) % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=4407&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ4407&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;求&lt;br&gt;$$&lt;br&gt;\sum_{i=1}^n\sum_{j=1}^mgcd(i, j)^k&lt;br&gt;$$&lt;br&gt;提取最大公约数d得到&lt;br&gt;$$&lt;br&gt;\sum_{d=1}^nd^k\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i, j) = 1]&lt;br&gt;$$&lt;br&gt;常见的套用反演，得到&lt;br&gt;$$&lt;br&gt;\sum_{d=1}^nd^k\sum_{i=1}^n\mu(i)\lfloor\frac{n}{id}\rfloor\lfloor\frac{m}{id}\rfloor&lt;br&gt;$$&lt;br&gt;令$T=id$&lt;br&gt;$$&lt;br&gt;\sum_{T=1}^n\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{d|T}d^k\mu(\frac{T}{d})&lt;br&gt;$$&lt;br&gt;前者整除分块，后者线性筛&lt;br&gt;对于线性筛，还是只需要想想枚举到一个已出现的质因子的情况，新的所有的因数可以看成旧的所有因数*p，再并上原来不含p的因数&lt;br&gt;前者更改前后$\mu$值没有变，后者在操作后变成了0&lt;br&gt;所以只要乘上$p^k$即可&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2154 Crash的数字表格</title>
    <link href="http://yoursite.com/2019/06/29/BZOJ2154-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/"/>
    <id>http://yoursite.com/2019/06/29/BZOJ2154-Crash的数字表格/</id>
    <published>2019-06-29T13:32:13.000Z</published>
    <updated>2019-07-01T15:04:58.314Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2154" target="_blank" rel="noopener">BZOJ2154</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意求<br>$$<br>\sum_{i=1}^n\sum_{j=1}^mlcm(i, j)<br>$$<br>$$<br> = \sum_{i=1}^n\sum_{j=1}^m\frac{ij}{gcd(i,i)}<br>$$<br>$$<br> = \sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^m[gcd(i, j)=d]\frac{ij}{d}<br>$$<br>套路地提取d<br>$$<br> = \sum_{d=1}^nd\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i, j) = 1]ij<br>$$<br>先处理后面一部分<br>令<br>$$<br>f(d) = \sum_{i=1}^x\sum_{j=1}^{y}[gcd(i, j)=d]ij \\<br>F(d) = \sum_{i=1}^x\sum_{j=1}^{y}[d|gcd(i, j)]ij \\<br> = \sum_{d|n}f(n) = d^2S(\frac{x}{d})S(\frac{y}{d})<br>$$<br>其中$S(n)$表示从1加到n，也就是$\frac{n(n+1)}{2}$<br>利用莫比乌斯反演<br>$$<br>f(d) = \sum_{d|k}\mu(\frac{k}{d})F(k)<br>$$<br>$$<br>ans = \sum_{d=1}^{n}df(1) = \sum_{d=1}^nd\sum_{i=1}^n\mu(i)i^2S(\frac{n}{id})S(\frac{m}{id})<br>$$<br>为了减少复杂度，从$O(n)$降到$O(\sqrt{n})$，令$T=id$，改为枚举T<br>$$<br>ans = \sum_{T=1}^nS(\frac{n}{T})S(\frac{m}{T})\sum_{d|T}dT\mu(d)<br>$$<br>至此，考虑如何实现<br>前面整除分块不用多说，讲讲后面的$\sum_{d|T}dT\mu(d)$，这是个积性函数，可以线性筛预处理出来，具体如下：<br>如果当前质因数p次数不为1<br>那么前面的所有因数要么包含一个p，要么不含p，否则贡献为零，不用考虑<br>前者会产生0和包含一个p的因数，后者会产生包含一个或不包含的<br>因此最终与没有p时相同，再乘上T的变化也就是p即可<br>如果p的次数唯一，则互质，由积性算即可</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">20101009</span>, maxn = <span class="number">10000010</span>, r2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n, m, prim[maxn], cnt, s[maxn], v[maxn], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    v[<span class="number">1</span>] = v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) &#123; prim[++cnt] = i; s[i] = (i - <span class="number">1l</span>l * i * i % mod + mod) % mod; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prim[j] &lt;= N; j++) &#123;</span><br><span class="line">            v[i * prim[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prim[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                s[i * prim[j]] = s[i] * prim[j] % mod;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> s[i * prim[j]] = s[i] * s[prim[j]] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i = 1; i &lt;= N; i++) cout &lt;&lt; s[i] &lt;&lt; ' ';cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//for(int i = 1; i &lt;= N; i++) cout &lt;&lt; s[i] &lt;&lt; ' ';cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) s[i] = (s[i] + s[i<span class="number">-1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    init(max(n, m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n &amp;&amp; l &lt;= m; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(n / (n / l), m / (m / l));</span><br><span class="line">        ll s1 = (n / l + <span class="number">1</span>) * (n / l) % mod * r2 % mod;</span><br><span class="line">        ll s2 = (m / l + <span class="number">1</span>) * (m / l) % mod * r2 % mod;</span><br><span class="line">        ans = (ans + (s[r] - s[l - <span class="number">1</span>] + mod) % mod * s1 % mod * s2 % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2154&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2154&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题意求&lt;br&gt;$$&lt;br&gt;\sum_{i=1}^n\sum_{j=1}^mlcm(i, j)&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt; = \sum_{i=1}^n\sum_{j=1}^m\frac{ij}{gcd(i,i)}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt; = \sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^m[gcd(i, j)=d]\frac{ij}{d}&lt;br&gt;$$&lt;br&gt;套路地提取d&lt;br&gt;$$&lt;br&gt; = \sum_{d=1}^nd\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i, j) = 1]ij&lt;br&gt;$$&lt;br&gt;先处理后面一部分&lt;br&gt;令&lt;br&gt;$$&lt;br&gt;f(d) = \sum_{i=1}^x\sum_{j=1}^{y}[gcd(i, j)=d]ij \\&lt;br&gt;F(d) = \sum_{i=1}^x\sum_{j=1}^{y}[d|gcd(i, j)]ij \\&lt;br&gt; = \sum_{d|n}f(n) = d^2S(\frac{x}{d})S(\frac{y}{d})&lt;br&gt;$$&lt;br&gt;其中$S(n)$表示从1加到n，也就是$\frac{n(n+1)}{2}$&lt;br&gt;利用莫比乌斯反演&lt;br&gt;$$&lt;br&gt;f(d) = \sum_{d|k}\mu(\frac{k}{d})F(k)&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;ans = \sum_{d=1}^{n}df(1) = \sum_{d=1}^nd\sum_{i=1}^n\mu(i)i^2S(\frac{n}{id})S(\frac{m}{id})&lt;br&gt;$$&lt;br&gt;为了减少复杂度，从$O(n)$降到$O(\sqrt{n})$，令$T=id$，改为枚举T&lt;br&gt;$$&lt;br&gt;ans = \sum_{T=1}^nS(\frac{n}{T})S(\frac{m}{T})\sum_{d|T}dT\mu(d)&lt;br&gt;$$&lt;br&gt;至此，考虑如何实现&lt;br&gt;前面整除分块不用多说，讲讲后面的$\sum_{d|T}dT\mu(d)$，这是个积性函数，可以线性筛预处理出来，具体如下：&lt;br&gt;如果当前质因数p次数不为1&lt;br&gt;那么前面的所有因数要么包含一个p，要么不含p，否则贡献为零，不用考虑&lt;br&gt;前者会产生0和包含一个p的因数，后者会产生包含一个或不包含的&lt;br&gt;因此最终与没有p时相同，再乘上T的变化也就是p即可&lt;br&gt;如果p的次数唯一，则互质，由积性算即可&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    
  </entry>
  
</feed>
