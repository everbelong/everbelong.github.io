<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ratexxxx</title>
  
  <subtitle>a pimping OIer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-28T13:11:15.191Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ratexxxx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ1921 [Ctsc2010]珠宝商</title>
    <link href="http://yoursite.com/2019/08/28/BZOJ1921-Ctsc2010-%E7%8F%A0%E5%AE%9D%E5%95%86/"/>
    <id>http://yoursite.com/2019/08/28/BZOJ1921-Ctsc2010-珠宝商/</id>
    <published>2019-08-28T13:09:46.000Z</published>
    <updated>2019-08-28T13:11:15.191Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1921" target="_blank" rel="noopener">BZOJ1921</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>本题综合利用后缀自动机的呀</p><p>首先第一想法是怎么写暴力，从每个点为起点开始想下走，同时在SAM上走DAG，对于树上的每走到一个点，把答案加上其SAM对应节点的endpos大小即可，复杂度$ O(n^2) $</p><p>然后看到这种统计路径的题，回想到点分和DSU，先试试点分，那么需要做的是统计以经过某个点x的路径的贡献，假设这条路径是$ u \to x \to v $<br>点分的一般思路，如果可以单独算出$ u \to x $和$ x \to v $，那么拼在一起就好了<br>但是如何拼在一起呢<br>考虑可以在M串上统计，每个u到x在匹配的位置上加一个标记，那么最后的答案就是每个位置 向前匹配的标记和*向后匹配的标记和 之和<br>发现上面说的两种路径其中一种可以变成反串上的另一种，因此只需考虑一种就可以</p><p>然后就要求后缀自动机理解透彻了<br>网上的题解都说要在后缀树上统计$ u \to x $的路径贡献<br>然后我就想，为什么还要搞后缀树，直接在DAG上统计$ x \to v $的贡献不就可以啦，每次在后面加一个字符，方法同第一种暴力一样啊<br>然而在网上找不到这种做法，于是我就手画了好多后缀自动机和后缀树（因为画挂了很多次），然后找到了原因<br>如果我们走DAG来计算贡献，那么走到一个点时，要计入的是以$ x…v $为前缀的串的个数，但在DAG上走到一个位置，这个节点代表的字串可以有在$x…v$前面加了几个字符，然后就不满足要求了，但我们同样会计入答案。也就是说这样会统计多<br>但如果在后缀树上统计$ u \to x $，那么每次是在前面加一个字符，需要向儿子走，但可以保证之后走到的每一个点代表的所有串都是以$ u…x $为后缀的，就是当且仅当的意思，所以可以正确统计<br>这个还是要搞张图看看啊</p><p>后缀自动机一个重要性质：自动机的par树即是其反串的后缀树（所以par树也叫前缀树，前缀树是反串的后缀树，多好）<br>然后建后缀树时记录一下每个点到其儿子走的是哪个字符的转移边</p><p>这样点分的做法就完善了，由于在每个分治点都要在后缀树上将标记推到儿子并统计，复杂度是$ O(nlogn + nm) $，后面一部分成了瓶颈</p><p>前人想出了一个很神仙的操作，我们发现第一个解法（暴力）复杂度与m无关，因此可以考虑当分治的子树大小低于某个值时直接暴力统计即可<br>当这个值设为$ \sqrt n $时最优，复杂度可以控制在$ O((n + m)\sqrt n) $</p><p>写在最后<br>后缀系列算法真的好神啊，后缀自动机和后缀树的坑好深啊<br>主要是有各种各样的性质，互相转换又即为方便<br>然后通过这道题我还练熟了手画自动机[滑稽]</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i(a), i##_ORZ(b); i &lt;= i##_ORZ; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drep(i, a, b) for(int i(a), i##_ORZ(b); i &gt;= i##_ORZ; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">char</span> tr[maxn], eg[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, head[maxn], ver[maxn], Next[maxn], tot, totsz, mn, rt, sz[maxn], v[maxn], B;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> par[maxn], ch[maxn][<span class="number">30</span>], val[maxn], cnt, las, rt;</span><br><span class="line"><span class="keyword">int</span> sz[maxn], pos[maxn], nxt[maxn][<span class="number">30</span>], c[maxn], A[maxn], nod[maxn], sum[maxn];</span><br><span class="line"><span class="keyword">char</span> S[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> po)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = las, np = ++cnt; nod[po] = np;</span><br><span class="line">val[np] = val[p] + <span class="number">1</span>; sz[np] = <span class="number">1</span>; pos[np] = po;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line"><span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> q = ch[p][x];</span><br><span class="line"><span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span>(ch[nq]));</span><br><span class="line">par[nq] = par[q];</span><br><span class="line">par[q] = par[np] = nq;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">las = np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cnt = rt = las = <span class="number">1</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, m) extend(S[i] - <span class="string">'a'</span>, i);</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) c[val[i]]++;</span><br><span class="line">rep(i, <span class="number">1</span>, m) c[i] += c[i<span class="number">-1</span>];</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) A[c[val[i]]--] = i;</span><br><span class="line">drep(i, cnt, <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x = A[i];</span><br><span class="line">sz[par[x]] += sz[x]; </span><br><span class="line"><span class="keyword">if</span>(!pos[par[x]]) pos[par[x]] = pos[x];</span><br><span class="line">nxt[par[x]][S[pos[x] - val[par[x]]] - <span class="string">'a'</span>] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) sum[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) sum[A[i]] += sum[par[A[i]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa, <span class="keyword">int</span> cur, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(len == val[cur]) cur = nxt[cur][tr[x] - <span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(S[pos[cur] - len] != tr[x]) cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">len++; sum[cur]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]])</span><br><span class="line">match(ver[i], x, cur, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;sam[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">sz[x] = <span class="number">1</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]]) &#123;</span><br><span class="line">getroot(ver[i], x);</span><br><span class="line">sz[x] += sz[ver[i]];</span><br><span class="line">res = max(res, sz[ver[i]]);</span><br><span class="line">&#125;</span><br><span class="line">res = max(res, totsz - sz[x]);</span><br><span class="line"><span class="keyword">if</span>(res &lt; mn) rt = x, mn = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">cur = sam[<span class="number">0</span>].ch[cur][tr[x] - <span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">ans += sam[<span class="number">0</span>].sz[cur];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]])</span><br><span class="line">calc(ver[i], x, cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brute</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">calc(x, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa &amp;&amp; !v[ver[i]])</span><br><span class="line">brute(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">sam[<span class="number">0</span>].clear(); sam[<span class="number">1</span>].clear();</span><br><span class="line">sam[<span class="number">0</span>].match(x, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); sam[<span class="number">0</span>].pushdown();</span><br><span class="line">sam[<span class="number">1</span>].match(x, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); sam[<span class="number">1</span>].pushdown();</span><br><span class="line">rep(i, <span class="number">1</span>, m) ans += <span class="number">1l</span>l * sam[<span class="number">0</span>].sum[sam[<span class="number">0</span>].nod[i]] * sam[<span class="number">1</span>].sum[sam[<span class="number">1</span>].nod[m - i + <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">sam[<span class="number">0</span>].clear(); sam[<span class="number">1</span>].clear();</span><br><span class="line">sam[<span class="number">0</span>].match(x, <span class="number">0</span>, sam[<span class="number">0</span>].ch[<span class="number">1</span>][tr[pa] - <span class="string">'a'</span>], <span class="number">1</span>); sam[<span class="number">0</span>].pushdown();</span><br><span class="line">sam[<span class="number">1</span>].match(x, <span class="number">0</span>, sam[<span class="number">1</span>].ch[<span class="number">1</span>][tr[pa] - <span class="string">'a'</span>], <span class="number">1</span>); sam[<span class="number">1</span>].pushdown();</span><br><span class="line">rep(i, <span class="number">1</span>, m) ans -= <span class="number">1l</span>l * sam[<span class="number">0</span>].sum[sam[<span class="number">0</span>].nod[i]] * sam[<span class="number">1</span>].sum[sam[<span class="number">1</span>].nod[m - i + <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsz</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">sz[x] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(!v[ver[i]] &amp;&amp; ver[i] != pa) </span><br><span class="line">getsz(ver[i], x), sz[x] += sz[ver[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(totsz &lt;= B) &#123; brute(x, <span class="number">0</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">Insert(x); v[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(!v[ver[i]]) Delete(ver[i], x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(!v[ver[i]]) &#123;</span><br><span class="line">getsz(ver[i], x);</span><br><span class="line">totsz = mn = sz[ver[i]];</span><br><span class="line">getroot(ver[i], x);</span><br><span class="line">DFS(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line">B = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, tr + <span class="number">1</span>, eg + <span class="number">1</span>);</span><br><span class="line">m = <span class="built_in">strlen</span>(eg + <span class="number">1</span>);</span><br><span class="line">rep(i, <span class="number">1</span>, m) sam[<span class="number">0</span>].S[i] = eg[i], sam[<span class="number">1</span>].S[m - i + <span class="number">1</span>] = eg[i];</span><br><span class="line">sam[<span class="number">0</span>].build(); sam[<span class="number">1</span>].build();</span><br><span class="line">totsz = mn = n; </span><br><span class="line">getroot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">DFS(rt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1921&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1921&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;本题综合利用后缀自动机的呀&lt;/p&gt;
&lt;p&gt;首先第一想法是怎么写暴力，从每个点为起点开始想下走，同时在SAM上走DAG，对于树上的每走到一个点，把答案加上其SAM对应节点的endpos大小即可，复杂度$ O(n^2) $&lt;/p&gt;
&lt;p&gt;然后看到这种统计路径的题，回想到点分和DSU，先试试点分，那么需要做的是统计以经过某个点x的路径的贡献，假设这条路径是$ u \to x \to v $&lt;br&gt;点分的一般思路，如果可以单独算出$ u \to x $和$ x \to v $，那么拼在一起就好了&lt;br&gt;但是如何拼在一起呢&lt;br&gt;考虑可以在M串上统计，每个u到x在匹配的位置上加一个标记，那么最后的答案就是每个位置 向前匹配的标记和*向后匹配的标记和 之和&lt;br&gt;发现上面说的两种路径其中一种可以变成反串上的另一种，因此只需考虑一种就可以&lt;/p&gt;
&lt;p&gt;然后就要求后缀自动机理解透彻了&lt;br&gt;网上的题解都说要在后缀树上统计$ u \to x $的路径贡献&lt;br&gt;然后我就想，为什么还要搞后缀树，直接在DAG上统计$ x \to v $的贡献不就可以啦，每次在后面加一个字符，方法同第一种暴力一样啊&lt;br&gt;然而在网上找不到这种做法，于是我就手画了好多后缀自动机和后缀树（因为画挂了很多次），然后找到了原因&lt;br&gt;如果我们走DAG来计算贡献，那么走到一个点时，要计入的是以$ x…v $为前缀的串的个数，但在DAG上走到一个位置，这个节点代表的字串可以有在$x…v$前面加了几个字符，然后就不满足要求了，但我们同样会计入答案。也就是说这样会统计多&lt;br&gt;但如果在后缀树上统计$ u \to x $，那么每次是在前面加一个字符，需要向儿子走，但可以保证之后走到的每一个点代表的所有串都是以$ u…x $为后缀的，就是当且仅当的意思，所以可以正确统计&lt;br&gt;这个还是要搞张图看看啊&lt;/p&gt;
&lt;p&gt;后缀自动机一个重要性质：自动机的par树即是其反串的后缀树（所以par树也叫前缀树，前缀树是反串的后缀树，多好）&lt;br&gt;然后建后缀树时记录一下每个点到其儿子走的是哪个字符的转移边&lt;/p&gt;
&lt;p&gt;这样点分的做法就完善了，由于在每个分治点都要在后缀树上将标记推到儿子并统计，复杂度是$ O(nlogn + nm) $，后面一部分成了瓶颈&lt;/p&gt;
&lt;p&gt;前人想出了一个很神仙的操作，我们发现第一个解法（暴力）复杂度与m无关，因此可以考虑当分治的子树大小低于某个值时直接暴力统计即可&lt;br&gt;当这个值设为$ \sqrt n $时最优，复杂度可以控制在$ O((n + m)\sqrt n) $&lt;/p&gt;
&lt;p&gt;写在最后&lt;br&gt;后缀系列算法真的好神啊，后缀自动机和后缀树的坑好深啊&lt;br&gt;主要是有各种各样的性质，互相转换又即为方便&lt;br&gt;然后通过这道题我还练熟了手画自动机[滑稽]&lt;/p&gt;
    
    </summary>
    
      <category term="字符串" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="后缀树" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ1920 [Ctsc2010]产品销售</title>
    <link href="http://yoursite.com/2019/08/28/BZOJ1920-Ctsc2010-%E4%BA%A7%E5%93%81%E9%94%80%E5%94%AE/"/>
    <id>http://yoursite.com/2019/08/28/BZOJ1920-Ctsc2010-产品销售/</id>
    <published>2019-08-28T13:06:37.000Z</published>
    <updated>2019-08-28T13:09:21.581Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接:<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1920" target="_blank" rel="noopener">BZOJ1920</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>对于30分的部分分，就是建出图后跑最小费用最大流<br>对于100分，就是模拟费用流的过程，中间用数据结构（线段树）维护</p><p>建图方式如下<br>$ s \to i $ 容量为U，费用为P<br>$ i \to i+1$ 容量为$ \infty$，费用为M<br>$ i+1 \to i$ 容量为$ \infty$，费用为C<br>$ i \to t$ 容量为D，费用为0<br>还有他们的反向边</p><p>考虑如何模拟费用流，首先得性质是，源点和汇点都是满流的，并且他们可以不退流，因此可以考虑枚举每个点i，分配他到汇点的流量使之满流<br>可以发现源点到i的流有两种：<br>$ s \to k \to k+1 \to … \to i-1 \to i ……(1)$<br>$ s \to k \to k-1 \to … \to i+1 \to i ……(2)$<br>我们每次选两种决策中费用较少的进行扩流，直到$D[i]$流满为止<br>也就是过程分为三步，<br>一、计算两种决策的代价<br>二、取较优的方式扩流，维护信息，更新答案，直到流满<br>三、从i移动到i+1，维护信息</p><h3><span id="决策2">决策（2）</span></h3><p>由于i是递增枚举的，所以从右到左的流只可能走C的正向边，可以不考虑M的反响边，代价为$ P[k] + sumC[k-1] - sumC[i] $，前面只与k有关，可以先排好序，每次跳过非法的（$k \le i || U[k]==0$）的k就可以直接询问</p><p>扩流的话，流量为$flow = min(U[k], D[i])$，将$[i, k-1]$的区间流量加上$flow$即可</p><h3><span id="决策1">决策（1）</span></h3><p>M的正向边有无限容量，但代价大，C的反向边代价小（为负），但有容量限制，为路径上所有正向边流量的最小值，因此前面每条边的代价有两种情况，$-C $或$ +M$<br>如果可以对C的流量进行维护的话，那么就可以维护正确的代价，进而求最小值<br>这个维护，需要在流量从0边成非0时设置代价为$-C$，在其又退回0后将代价加上$C+M$，可以发现每条边最多在右边时变大，在左边时变小，因此只有这两个过程就够了</p><p>扩流同上</p><p>考虑这个0的维护，如果最开始初值设为0的话，那么很难区分0到底是初值还是后来减回来的，所以一个比较好的办法是初值设为inf<br>在没有用到它的时候默认inf就是初值的0<br>然后会面临在决策（2）的时候，流量被区间加，这时需要先把所有inf设为0，再区间加，可以发现每个inf最多被设为0一次，可以用并查集优化，每次跳到下一个inf的位置即可<br>然后面临在决策（1）时区间减，会出现减到0的情况这标志着要修改代价了，只有在这个时候会真正出现0。修改完代价后我们立刻把0再变回inf，代表它已经没有流量了。之所以他可以改成inf而不会继续对区间的容量有所限制，是因为我们已经修改过费用了，新的容量正好对应着新的费用。<br>这样就完美解决了最棘手的问题。</p><h3><span id="维护的信息">维护的信息</span></h3><p>需要维护C的流量flow，支持区间加减，查询最小值及其位置，以及获得每个0的位置，单点置为某值。<br>还要维护i之前每个点到i的代价（费用）cost，支持区间加减，查询最小值及其位置，单点置为某值<br>实际上操作是类似的，可以写成一个结构体的两个对象</p><p>具体怎么维护</p><p>在$cost[1…i-1] $中查询最小值和位置k，作为决策（1）<br>从排序好的那个序列首取出合法位置k，作为决策（2）<br>判断用那个决策，<br>对于（1）在$ flow[k…i-1] $中查询最小值，和U和D取min，得到流量，将$ flow[k…i-1] $区间减这个流量。在$flow$同样的区间递归找到每个为0的位置j，在$cost[1…j]$中区间加$ C[j]+M[j] $<br>对于（2），取U和D的min作为流量，$flow$区间加流量，加之前跳并查集将inf改为0<br>直到D[i]为0<br>将$cost[1…i]$区间加P[i]（前提是U[i]不为0）<br>将$cost[1…i]$区间加M[i]或-C[i]，取决于C[i]是否有流量，这是i对于前面每个点贡献的费用</p><p>然后终于结束了</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i(a), i##_END(b); i &lt;= i##_END; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drep(i, a, b) for(int i(a), i##_END(b); i &gt;= i##_END; i--);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, D[maxn], U[maxn], P[maxn], M[maxn], C[maxn], fa[maxn], sumC[maxn];</span><br><span class="line">pii rcs[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = get(fa[x]); &#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> mn[maxn * <span class="number">4</span>], pos[maxn * <span class="number">4</span>], tag[maxn * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; mn[p] = x; pos[p] = l; tag[p] = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(p*<span class="number">2</span>, l, mid, x); build(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!tag[p]) <span class="keyword">return</span>; </span><br><span class="line">mn[p*<span class="number">2</span>] += tag[p]; mn[p*<span class="number">2</span>+<span class="number">1</span>] += tag[p];</span><br><span class="line">tag[p*<span class="number">2</span>] += tag[p]; tag[p*<span class="number">2</span>+<span class="number">1</span>] += tag[p];</span><br><span class="line">tag[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123; mn[p] += x; tag[p] += x; <span class="keyword">return</span>; &#125;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) change(p*<span class="number">2</span>, l, mid, L, R, x);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) change(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; mn[p] = x; <span class="keyword">return</span>; &#125;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(u &lt;= mid) change(p*<span class="number">2</span>, l, mid, u, x);</span><br><span class="line"><span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, u, x);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> make_pair(mn[p], pos[p]);</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="function">pii <span class="title">res</span><span class="params">(inf, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) res = min(res, query(p*<span class="number">2</span>, l, mid, L, R));</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) res = min(res, query(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, SegmentTree &amp;tar)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; tar.change(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, l, C[l] + M[l]); mn[p] = inf; <span class="keyword">return</span>; &#125;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid &amp;&amp; mn[p*<span class="number">2</span>] == <span class="number">0</span>) reset(p*<span class="number">2</span>, l, mid, L, R, tar);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid &amp;&amp; mn[p*<span class="number">2</span>+<span class="number">1</span>] == <span class="number">0</span>) reset(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, tar);</span><br><span class="line">mn[p] = min(mn[p*<span class="number">2</span>], mn[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn[p] == mn[p*<span class="number">2</span>]) pos[p] = pos[p*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> pos[p] = pos[p*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;flow, cost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"product.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"product.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); </span><br><span class="line">rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;D[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;U[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;P[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C[i]);</span><br><span class="line">rep(i, <span class="number">1</span>, n) fa[i] = i, sumC[i] = sumC[i<span class="number">-1</span>] + C[i], rcs[i] = make_pair(P[i] + sumC[i - <span class="number">1</span>], i);</span><br><span class="line">sort(rcs + <span class="number">1</span>, rcs + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">int</span> rpos = <span class="number">1</span>;</span><br><span class="line">flow.build(<span class="number">1</span>, <span class="number">1</span>, n, inf); cost.build(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">while</span>(D[i]) &#123;</span><br><span class="line">pii lcost = (i &gt; <span class="number">1</span> ? cost.query(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, i - <span class="number">1</span>) : make_pair(inf, <span class="number">0</span>)), rcost;</span><br><span class="line"><span class="keyword">while</span>(rpos &lt;= n &amp;&amp; (rcs[rpos].second &lt; i || !U[rcs[rpos].second])) ++rpos;</span><br><span class="line"><span class="keyword">if</span>(rpos &lt;= n) rcost = rcs[rpos], rcost.first -= sumC[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> rcost = make_pair(inf, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; lcost.second &lt;&lt; ' ' &lt;&lt; rcost.second &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span>(lcost &lt;= rcost) &#123;</span><br><span class="line"><span class="keyword">int</span> k = lcost.second;</span><br><span class="line">pii flowleft = flow.query(<span class="number">1</span>, <span class="number">1</span>, n, k, i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> nflow = min(flowleft.first, min(U[k], D[i]));</span><br><span class="line">flow.change(<span class="number">1</span>, <span class="number">1</span>, n, k, i - <span class="number">1</span>, -nflow);</span><br><span class="line">D[i] -= nflow; U[k] -= nflow;</span><br><span class="line">ans += <span class="number">1l</span>l * nflow * lcost.first;</span><br><span class="line"><span class="keyword">if</span>(!U[k]) cost.change(<span class="number">1</span>, <span class="number">1</span>, n, k, inf);</span><br><span class="line">flow.reset(<span class="number">1</span>, <span class="number">1</span>, n, k, i - <span class="number">1</span>, cost);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> k = rcost.second;</span><br><span class="line"><span class="keyword">int</span> nflow = min(U[k], D[i]);</span><br><span class="line">D[i] -= nflow; U[k] -= nflow;</span><br><span class="line">ans += <span class="number">1l</span>l * nflow * rcost.first;</span><br><span class="line"><span class="keyword">int</span> j = get(i);</span><br><span class="line"><span class="keyword">while</span>(j &lt;= k - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> fy = get(j + <span class="number">1</span>);</span><br><span class="line">flow.change(<span class="number">1</span>, <span class="number">1</span>, n, j, <span class="number">0</span>);</span><br><span class="line">fa[j] = fy; j = get(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k &gt; i) flow.change(<span class="number">1</span>, <span class="number">1</span>, n, i, k - <span class="number">1</span>, nflow);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == n) <span class="keyword">break</span>;</span><br><span class="line">cost.change(<span class="number">1</span>, <span class="number">1</span>, n, i, U[i] ? P[i] : inf);</span><br><span class="line">cost.change(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, i, fa[i] == i ? M[i] : -C[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接:&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1920&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1920&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;对于30分的部分分，就是建出图后跑最小费用最大流&lt;br&gt;对于100分，就是模拟费用流的过程，中间用数据结构（线段树）维护&lt;/p&gt;
&lt;p&gt;建图方式如下&lt;br&gt;$ s \to i $ 容量为U，费用为P&lt;br&gt;$ i \to i+1$ 容量为$ \infty$，费用为M&lt;br&gt;$ i+1 \to i$ 容量为$ \infty$，费用为C&lt;br&gt;$ i \to t$ 容量为D，费用为0&lt;br&gt;还有他们的反向边&lt;/p&gt;
&lt;p&gt;考虑如何模拟费用流，首先得性质是，源点和汇点都是满流的，并且他们可以不退流，因此可以考虑枚举每个点i，分配他到汇点的流量使之满流&lt;br&gt;可以发现源点到i的流有两种：&lt;br&gt;$ s \to k \to k+1 \to … \to i-1 \to i ……(1)$&lt;br&gt;$ s \to k \to k-1 \to … \to i+1 \to i ……(2)$&lt;br&gt;我们每次选两种决策中费用较少的进行扩流，直到$D[i]$流满为止&lt;br&gt;也就是过程分为三步，&lt;br&gt;一、计算两种决策的代价&lt;br&gt;二、取较优的方式扩流，维护信息，更新答案，直到流满&lt;br&gt;三、从i移动到i+1，维护信息&lt;/p&gt;
&lt;h3 id=&quot;决策（2）&quot;&gt;&lt;a href=&quot;#决策（2）&quot; class=&quot;headerlink&quot; title=&quot;决策（2）&quot;&gt;&lt;/a&gt;决策（2）&lt;/h3&gt;&lt;p&gt;由于i是递增枚举的，所以从右到左的流只可能走C的正向边，可以不考虑M的反响边，代价为$ P[k] + sumC[k-1] - sumC[i] $，前面只与k有关，可以先排好序，每次跳过非法的（$k \le i || U[k]==0$）的k就可以直接询问&lt;/p&gt;
&lt;p&gt;扩流的话，流量为$flow = min(U[k], D[i])$，将$[i, k-1]$的区间流量加上$flow$即可&lt;/p&gt;
&lt;h3 id=&quot;决策（1）&quot;&gt;&lt;a href=&quot;#决策（1）&quot; class=&quot;headerlink&quot; title=&quot;决策（1）&quot;&gt;&lt;/a&gt;决策（1）&lt;/h3&gt;&lt;p&gt;M的正向边有无限容量，但代价大，C的反向边代价小（为负），但有容量限制，为路径上所有正向边流量的最小值，因此前面每条边的代价有两种情况，$-C $或$ +M$&lt;br&gt;如果可以对C的流量进行维护的话，那么就可以维护正确的代价，进而求最小值&lt;br&gt;这个维护，需要在流量从0边成非0时设置代价为$-C$，在其又退回0后将代价加上$C+M$，可以发现每条边最多在右边时变大，在左边时变小，因此只有这两个过程就够了&lt;/p&gt;
&lt;p&gt;扩流同上&lt;/p&gt;
&lt;p&gt;考虑这个0的维护，如果最开始初值设为0的话，那么很难区分0到底是初值还是后来减回来的，所以一个比较好的办法是初值设为inf&lt;br&gt;在没有用到它的时候默认inf就是初值的0&lt;br&gt;然后会面临在决策（2）的时候，流量被区间加，这时需要先把所有inf设为0，再区间加，可以发现每个inf最多被设为0一次，可以用并查集优化，每次跳到下一个inf的位置即可&lt;br&gt;然后面临在决策（1）时区间减，会出现减到0的情况这标志着要修改代价了，只有在这个时候会真正出现0。修改完代价后我们立刻把0再变回inf，代表它已经没有流量了。之所以他可以改成inf而不会继续对区间的容量有所限制，是因为我们已经修改过费用了，新的容量正好对应着新的费用。&lt;br&gt;这样就完美解决了最棘手的问题。&lt;/p&gt;
&lt;h3 id=&quot;维护的信息&quot;&gt;&lt;a href=&quot;#维护的信息&quot; class=&quot;headerlink&quot; title=&quot;维护的信息&quot;&gt;&lt;/a&gt;维护的信息&lt;/h3&gt;&lt;p&gt;需要维护C的流量flow，支持区间加减，查询最小值及其位置，以及获得每个0的位置，单点置为某值。&lt;br&gt;还要维护i之前每个点到i的代价（费用）cost，支持区间加减，查询最小值及其位置，单点置为某值&lt;br&gt;实际上操作是类似的，可以写成一个结构体的两个对象&lt;/p&gt;
&lt;p&gt;具体怎么维护&lt;/p&gt;
&lt;p&gt;在$cost[1…i-1] $中查询最小值和位置k，作为决策（1）&lt;br&gt;从排序好的那个序列首取出合法位置k，作为决策（2）&lt;br&gt;判断用那个决策，&lt;br&gt;对于（1）在$ flow[k…i-1] $中查询最小值，和U和D取min，得到流量，将$ flow[k…i-1] $区间减这个流量。在$flow$同样的区间递归找到每个为0的位置j，在$cost[1…j]$中区间加$ C[j]+M[j] $&lt;br&gt;对于（2），取U和D的min作为流量，$flow$区间加流量，加之前跳并查集将inf改为0&lt;br&gt;直到D[i]为0&lt;br&gt;将$cost[1…i]$区间加P[i]（前提是U[i]不为0）&lt;br&gt;将$cost[1…i]$区间加M[i]或-C[i]，取决于C[i]是否有流量，这是i对于前面每个点贡献的费用&lt;/p&gt;
&lt;p&gt;然后终于结束了&lt;/p&gt;
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="费用流" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ1919 [Ctsc2010]性能优化</title>
    <link href="http://yoursite.com/2019/08/28/BZOJ1919-Ctsc2010-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/08/28/BZOJ1919-Ctsc2010-性能优化/</id>
    <published>2019-08-28T13:02:06.000Z</published>
    <updated>2019-08-28T13:27:00.933Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1919" target="_blank" rel="noopener">BZOJ1919</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>据说是循环卷积板子题 需要对FFT有深刻的理解（不能只会敲模板）</p><p>FFT本身就是支持循环卷积的，只要把长度定为n就可以<br>令$ A,B,C $分别是点值表示的数组, $ a,b,c $为原数组<br>$$<br>A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\<br>B(\omega_n^k) = \sum_{i=0}^{n-1}b_i\omega_n^{ik} \\<br>C(\omega_n^k) = A(\omega_n^k) \times B(\omega_n^k)<br>= \sum_{i=0}^{n-1}a_i\omega_n^{ik}\sum_{i=0}^{n-1}b_i\omega_n^{ik}<br>$$<br>由于$ \omega_n^{k}=\omega_n^{k+n} $, 所以将其展开可得<br>$$<br>C(\omega_n^k) = \sum_{s=0}^{n-1}T_s\omega_n^{is}\\<br>T_s = \sum_{(i+j)mod(n+1)=s}a_i\cdot b_j<br>$$<br>我们要求的循环卷积$c$也就是$T$<br>所以实际上$C$就是$c$的卷积, 直接逆卷积回去就可以了. 证毕</p><p>然后要解决的问题是如何求任意长度FFT, 因为无法将其补成2的幂, 所以原来的板子行不通了<br>考虑n可以分解成P=2、3、5、7的幂，因此每次分治可以考虑分成P段，而不是单一的2段，但式子要重新搞。下面以3为例推一边，然后给出一个一般式子<br>$$<br>A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\<br>=(a_0\omega_n^k+a_3\omega_n^{3k}+a_6\omega_n^{6k}+…) \\+(a_1\omega_n^k+a_4\omega_n^{3k}+a_7\omega_n^{6k}+…) \\+(a_2\omega_n^k+a_5\omega_n^{3k}+a_8\omega_n^{6k}+…)  \\<br>= A_0(\omega_n^{3k}) + \omega_n^kA_1(\omega_n^{3k}) + \omega_n^{2k}A_2(\omega_n^{3k})<br>$$<br>这里按照3的同余系进行分组，$A_i$代表将a按照膜3的余数分组后递归求出的点值，同理可得<br>$$<br>A(\omega_n^{k+\frac{n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{2k}{3}}A_2(\omega_n^{3k}) \\<br>A(\omega_n^{k+\frac{2n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{2n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{4n}{3}}A_2(\omega_n^{3k}) \\<br>$$<br>然后这三个数就可以一起算了，方法类似FFT<br>对于其他的P，同理有如下式子<br>$$<br>A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_n^{Pk})<br>$$<br>或者写成如下形式更能看出来如何递归子问题<br>$$<br>A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_{\frac{n}{P}}^{k})<br>$$<br>也就是n的规模缩小了$\frac{1}{P}$，递归后每一个对应位置都枚举i，j求一下，需要一个临时数组来备份上一层的结果<br>也可以写非递归的，好像要预处理一下每个位置最后会移到哪里，但是递归也能A，我就没写迭代的（其实是懒）</p><p>最后的问题是FFT复数运算会存在极大精度问题，因为本题要快速幂算C次方，值域极大。<br>所以改成NTT，题目保证n+1是质数，又已经说了n最多4个质因数，因此求一下原根就好，这里在提一下原根求法（这里的n是题目中的n，求的是n+1的原根）<br>从2到n-1枚举g，验证g是原根的条件是：任意p是n的质因数，有<br>$$<br>g^{\frac{n}{p}} \neq 1\quad mod\ (n+1)<br>$$</p><p>为了做这题不得不复习一遍FFT的推导，本来只会敲板子的ε=(´ο｀*)))</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i(a), i##_AWSL(b); i &lt;= i##_AWSL; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drep(i, a, b) for(int i(a), i##_AWSL(b); i &gt;= i##_AWSL; i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, C, mod, g, pr[<span class="number">10</span>], cnt;</span><br><span class="line">ll a[maxn], b[maxn], tmp[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getg</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">5</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">7</span> == <span class="number">0</span>) pr[++cnt] = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span>(g = <span class="number">2</span>; g &lt;= n; g++) &#123;</span><br><span class="line"><span class="keyword">int</span> tag = <span class="number">0</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) <span class="keyword">if</span>(Power(g, n / pr[i]) % mod == <span class="number">1</span>) tag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!tag) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(ll *p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> len = r - l + <span class="number">1</span>, P = <span class="number">2</span>;</span><br><span class="line">rep(i, <span class="number">1</span>, cnt) <span class="keyword">if</span>(len % pr[i] == <span class="number">0</span>) P = pr[i];</span><br><span class="line"><span class="keyword">int</span> lp = len / P;</span><br><span class="line">rep(i, <span class="number">0</span>, len - <span class="number">1</span>) tmp[(i % P) * lp + i / P] = p[l + i]; </span><br><span class="line">rep(i, <span class="number">0</span>, len - <span class="number">1</span>) p[l + i] = tmp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i += lp) ntt(p, i, i + lp - <span class="number">1</span>, inv);</span><br><span class="line">ll omega = Power(g, n / len), w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(inv &lt; <span class="number">0</span>) omega = Power(omega, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= l + lp - <span class="number">1</span>; i++, w = w * omega % mod) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= r; j += lp) tmp[j] = p[j];</span><br><span class="line">ll x = w, delta = Power(g, n / P);</span><br><span class="line"><span class="keyword">if</span>(inv &lt; <span class="number">0</span>) delta = Power(delta, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= r; j += lp, x = x * delta % mod) &#123;</span><br><span class="line">ll tim = <span class="number">1</span>; p[j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= r; k += lp, tim = tim * x % mod)</span><br><span class="line">p[j] = (p[j] + tmp[k] * tim % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;C); mod = n + <span class="number">1</span>;</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]);</span><br><span class="line">getg();</span><br><span class="line">ntt(a, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>); ntt(b, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) a[i] = a[i] * Power(b[i], C) % mod;</span><br><span class="line">ntt(a, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">ll tmp = Power(n, mod - <span class="number">2</span>);</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) a[i] = a[i] * tmp % mod;</span><br><span class="line">rep(i, <span class="number">0</span>, n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1919&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1919&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;据说是循环卷积板子题 需要对FFT有深刻的理解（不能只会敲模板）&lt;/p&gt;
&lt;p&gt;FFT本身就是支持循环卷积的，只要把长度定为n就可以&lt;br&gt;令$ A,B,C $分别是点值表示的数组, $ a,b,c $为原数组&lt;br&gt;$$&lt;br&gt;A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\&lt;br&gt;B(\omega_n^k) = \sum_{i=0}^{n-1}b_i\omega_n^{ik} \\&lt;br&gt;C(\omega_n^k) = A(\omega_n^k) \times B(\omega_n^k)&lt;br&gt;= \sum_{i=0}^{n-1}a_i\omega_n^{ik}\sum_{i=0}^{n-1}b_i\omega_n^{ik}&lt;br&gt;$$&lt;br&gt;由于$ \omega_n^{k}=\omega_n^{k+n} $, 所以将其展开可得&lt;br&gt;$$&lt;br&gt;C(\omega_n^k) = \sum_{s=0}^{n-1}T_s\omega_n^{is}\\&lt;br&gt;T_s = \sum_{(i+j)mod(n+1)=s}a_i\cdot b_j&lt;br&gt;$$&lt;br&gt;我们要求的循环卷积$c$也就是$T$&lt;br&gt;所以实际上$C$就是$c$的卷积, 直接逆卷积回去就可以了. 证毕&lt;/p&gt;
&lt;p&gt;然后要解决的问题是如何求任意长度FFT, 因为无法将其补成2的幂, 所以原来的板子行不通了&lt;br&gt;考虑n可以分解成P=2、3、5、7的幂，因此每次分治可以考虑分成P段，而不是单一的2段，但式子要重新搞。下面以3为例推一边，然后给出一个一般式子&lt;br&gt;$$&lt;br&gt;A(\omega_n^k) = \sum_{i=0}^{n-1}a_i\omega_n^{ik} \\&lt;br&gt;=(a_0\omega_n^k+a_3\omega_n^{3k}+a_6\omega_n^{6k}+…) \\+(a_1\omega_n^k+a_4\omega_n^{3k}+a_7\omega_n^{6k}+…) \\+(a_2\omega_n^k+a_5\omega_n^{3k}+a_8\omega_n^{6k}+…)  \\&lt;br&gt;= A_0(\omega_n^{3k}) + \omega_n^kA_1(\omega_n^{3k}) + \omega_n^{2k}A_2(\omega_n^{3k})&lt;br&gt;$$&lt;br&gt;这里按照3的同余系进行分组，$A_i$代表将a按照膜3的余数分组后递归求出的点值，同理可得&lt;br&gt;$$&lt;br&gt;A(\omega_n^{k+\frac{n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{2k}{3}}A_2(\omega_n^{3k}) \\&lt;br&gt;A(\omega_n^{k+\frac{2n}{3}})= A_0(\omega_n^{3k}) + \omega_n^{k+\frac{2n}{3}}A_1(\omega_n^{3k}) + \omega_n^{2k+\frac{4n}{3}}A_2(\omega_n^{3k}) \\&lt;br&gt;$$&lt;br&gt;然后这三个数就可以一起算了，方法类似FFT&lt;br&gt;对于其他的P，同理有如下式子&lt;br&gt;$$&lt;br&gt;A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_n^{Pk})&lt;br&gt;$$&lt;br&gt;或者写成如下形式更能看出来如何递归子问题&lt;br&gt;$$&lt;br&gt;A(\omega_n^{k+\frac{in}{P}}) = \sum_{j=0}^{P-1}(\omega_n^{k+\frac{in}{P}})^j A_j(\omega_{\frac{n}{P}}^{k})&lt;br&gt;$$&lt;br&gt;也就是n的规模缩小了$\frac{1}{P}$，递归后每一个对应位置都枚举i，j求一下，需要一个临时数组来备份上一层的结果&lt;br&gt;也可以写非递归的，好像要预处理一下每个位置最后会移到哪里，但是递归也能A，我就没写迭代的（其实是懒）&lt;/p&gt;
&lt;p&gt;最后的问题是FFT复数运算会存在极大精度问题，因为本题要快速幂算C次方，值域极大。&lt;br&gt;所以改成NTT，题目保证n+1是质数，又已经说了n最多4个质因数，因此求一下原根就好，这里在提一下原根求法（这里的n是题目中的n，求的是n+1的原根）&lt;br&gt;从2到n-1枚举g，验证g是原根的条件是：任意p是n的质因数，有&lt;br&gt;$$&lt;br&gt;g^{\frac{n}{p}} \neq 1\quad mod\ (n+1)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;为了做这题不得不复习一遍FFT的推导，本来只会敲板子的ε=(´ο｀*)))&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="多项式" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="FFT" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E5%A4%9A%E9%A1%B9%E5%BC%8F/FFT/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ4538 [Hnoi2016]网络</title>
    <link href="http://yoursite.com/2019/07/19/BZOJ4538-Hnoi2016-%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2019/07/19/BZOJ4538-Hnoi2016-网络/</id>
    <published>2019-07-19T14:31:31.000Z</published>
    <updated>2019-07-19T14:49:04.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4538" target="_blank" rel="noopener">BZOJ4538</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>比较裸的树剖<br>树剖后的线段树每个节点建一个堆<br>加入一个路径就把元素插入这条路径外的其他区间<br>具体实现时记录下这条路径的所有区间，排序后取补集就可以了<br>删除就打一个标记，弹出时略过即可<br>询问就是那个点经过的所有线段树节点都要取堆顶，取最大值</p><p>吐槽一下，洛谷上可以过，BZOJ上MLE<br>LOJ上最大测试点用了288Mb内存，BZ上128Mb限制，显然会爆<br>然而网上的题解竟然也会爆？？？<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot, n, m, del[maxn * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> fa[maxn], son[maxn], d[maxn], top[maxn], seg[maxn], rev[maxn], sz[maxn], cnt, num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inter</span>&#123;</span> <span class="keyword">int</span> l, r; Inter(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>) : l(l), r(r) &#123;&#125; &#125;li[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Inter a, Inter b) &#123; <span class="keyword">return</span> a.l &lt; b.l; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">fa[x] = pa; sz[x] = <span class="number">1</span>; d[x] = d[pa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) &#123;</span><br><span class="line">dfs1(ver[i], x);</span><br><span class="line"><span class="keyword">if</span>(sz[ver[i]] &gt; sz[son[x]]) son[x] = ver[i];</span><br><span class="line">sz[x] += sz[ver[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">seg[x] = ++cnt; rev[cnt] = x;</span><br><span class="line"><span class="keyword">if</span>(son[x]) top[son[x]] = top[x], dfs2(son[x]); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x] &amp;&amp; ver[i] != son[x]) &#123;</span><br><span class="line">top[ver[i]] = ver[i];</span><br><span class="line">dfs2(ver[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q[maxn * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; p &lt;&lt; ' ' &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; L &lt;&lt; ' ' &lt;&lt; R &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123; q[p].push(make_pair(x, i)); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) update(p*<span class="number">2</span>, l, mid, L, R, x, i);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) update(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, x, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(q[p].size() &amp;&amp; del[q[p].top().second]) q[p].pop();</span><br><span class="line"><span class="keyword">int</span> res = q[p].size() ? q[p].top().first : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= mid) res = max(res, query(p*<span class="number">2</span>, l, mid, x));</span><br><span class="line"><span class="keyword">else</span> res = max(res, query(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, x));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">0</span>); top[<span class="number">1</span>] = <span class="number">1</span>; dfs2(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; rev[i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> o, v; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;o);</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">0</span>) &#123;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;v);</span><br><span class="line"><span class="keyword">while</span>(top[x] != top[y]) &#123;</span><br><span class="line"><span class="keyword">if</span>(d[top[x]] &lt; d[top[y]]) swap(x, y);</span><br><span class="line">li[++num] = Inter(seg[top[x]], seg[x]);</span><br><span class="line">x = fa[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(d[x] &lt; d[y]) swap(x, y);</span><br><span class="line">li[++num] = Inter(seg[y], seg[x]);</span><br><span class="line">sort(li + <span class="number">1</span>, li + <span class="number">1</span> + num); li[<span class="number">0</span>] = Inter(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= num; i++) cout &lt;&lt; li[i].l &lt;&lt; ' ' &lt;&lt; li[i].r &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num; j++) </span><br><span class="line"><span class="keyword">if</span>(li[j].l &gt; li[j<span class="number">-1</span>].r + <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, n, li[j<span class="number">-1</span>].r + <span class="number">1</span>, li[j].l - <span class="number">1</span>, v, i);</span><br><span class="line"><span class="keyword">if</span>(li[num].r &lt; n) update(<span class="number">1</span>, <span class="number">1</span>, n, li[num].r + <span class="number">1</span>, n, v, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v), del[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, seg[v]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=4538&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ4538&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;比较裸的树剖&lt;br&gt;树剖后的线段树每个节点建一个堆&lt;br&gt;加入一个路径就把元素插入这条路径外的其他区间&lt;br&gt;具体实现时记录下这条路径的所有区间，排序后取补集就可以了&lt;br&gt;删除就打一个标记，弹出时略过即可&lt;br&gt;询问就是那个点经过的所有线段树节点都要取堆顶，取最大值&lt;/p&gt;
&lt;p&gt;吐槽一下，洛谷上可以过，BZOJ上MLE&lt;br&gt;LOJ上最大测试点用了288Mb内存，BZ上128Mb限制，显然会爆&lt;br&gt;然而网上的题解竟然也会爆？？？&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树链剖分" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3672 [Noi2014]购票</title>
    <link href="http://yoursite.com/2019/07/18/BZOJ3672-Noi2014-%E8%B4%AD%E7%A5%A8/"/>
    <id>http://yoursite.com/2019/07/18/BZOJ3672-Noi2014-购票/</id>
    <published>2019-07-18T06:56:13.000Z</published>
    <updated>2019-07-18T07:20:09.944Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3672" target="_blank" rel="noopener">BZOJ3672</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>$O(n^2)$的暴力dp很好想<br>$$<br>f[i] = min(f[j] + (dis[i] - dis[j])\times p_i + q_i),\quad dis[i] - dis[j] &lt;= l_i<br>$$<br>如果在一个序列上的话，这应该是一个经典的斜率优化，对于任意$ a &lt; b $，若要求对于i来说决策a比b更优，则<br>$$<br>p_i &lt; \frac{f[b] - f[a]}{dis[b] - dis[a]}<br>$$<br>由于p不具有单调性，因此不能从队头删除元素，而应在队列中二分查找最优的决策<br>再加上对于决策的位置有l的限制，因此还需要用线段树</p><p>那么对于本题，在树上进行转移，就需要树链剖分了<br>剖分后的线段树上每个节点开一个vector，维护这个节点的决策集合，一个原树上的点最多出现在log个vector中，因此空间复杂度是对的<br>一遍dfs进行转移，维护一个根到当前节点的栈，转移时通过跳top将所有满足小于等于$l_x$的点分割成线段树上的区间，在线段树的各个vector上二分查找最优决策，取最小值，得到当前dp值，再在线段树上进行修改，最多修改log个节点，每个节点把队尾不优的决策弹出，再压如新决策<br>网上的题解都把这个方法叫树剖线段树维护凸包</p><p>下面的代码洛谷上可过，BZOJ上会RE<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot, n, fa[maxn];</span><br><span class="line">ll edge[maxn * <span class="number">2</span>], P[maxn], q[maxn], L[maxn], dis[maxn], f[maxn];</span><br><span class="line"><span class="keyword">int</span> son[maxn], top[maxn], seg[maxn], rev[maxn], sz[maxn], cnt, sta[maxn], Tp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[maxn * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll z)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1.0</span> * (f[y] - f[x]) / (dis[y] - dis[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x]) &#123;</span><br><span class="line">        dis[ver[i]] = dis[x] + edge[i];</span><br><span class="line">        dfs1(ver[i]);</span><br><span class="line">        <span class="keyword">if</span>(sz[ver[i]] &gt; sz[son[x]]) son[x] = ver[i];</span><br><span class="line">        sz[x] += sz[ver[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    seg[x] = ++cnt; rev[cnt] = x;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) top[son[x]] = top[x], dfs2(son[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x] &amp;&amp; ver[i] != son[x]) &#123;</span><br><span class="line">        top[ver[i]] = ver[i];</span><br><span class="line">        dfs2(ver[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tail = vec[p].size();</span><br><span class="line">    <span class="keyword">while</span>(tail &gt; <span class="number">1</span> &amp;&amp; slope(rev[pos], vec[p][tail<span class="number">-1</span>]) &lt; slope(vec[p][tail<span class="number">-1</span>], vec[p][tail<span class="number">-2</span>])) tail--, vec[p].pop_back();</span><br><span class="line">    vec[p].push_back(rev[pos]);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) change(p*<span class="number">2</span>, l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = vec[p].size() - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(slope(vec[p][mid], vec[p][mid - <span class="number">1</span>]) &lt; (<span class="keyword">double</span>)P[i]) res = mid, l = mid + <span class="number">1</span>; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> v = vec[p][res];</span><br><span class="line">    <span class="keyword">return</span> f[v] + (dis[i] - dis[v]) * P[i] + q[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> calc(p, i); </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; ll res = inf;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) res = min(res, query(p*<span class="number">2</span>, l, mid, L, R, i));</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) res = min(res, query(p*<span class="number">2</span>+<span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, i));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fly</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = x; x = fa[x];</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[des]) &#123;</span><br><span class="line">        f[X] = min(f[X], query(<span class="number">1</span>, <span class="number">1</span>, n, seg[top[x]], seg[x], X));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    f[X] = min(f[X], query(<span class="number">1</span>, <span class="number">1</span>, n, seg[des], seg[x], X));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sta[++Tp] = x;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = Tp; </span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[x] - dis[mid] &gt; L[x]) l = mid + <span class="number">1</span>; <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        Fly(x, l);</span><br><span class="line">    &#125;</span><br><span class="line">    change(<span class="number">1</span>, <span class="number">1</span>, n, seg[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x]) DFS(ver[i]);</span><br><span class="line">    Tp--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;z); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld%lld%lld"</span>, &amp;fa[i], &amp;z, &amp;P[i], &amp;q[i], &amp;L[i]);</span><br><span class="line">        add(i, fa[i], z), add(fa[i], i, z);</span><br><span class="line">    &#125;</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs1(<span class="number">1</span>); dfs2(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)); f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    DFS(<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3672&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3672&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;$O(n^2)$的暴力dp很好想&lt;br&gt;$$&lt;br&gt;f[i] = min(f[j] + (dis[i] - dis[j])\times p_i + q_i),\quad dis[i] - dis[j] &amp;lt;= l_i&lt;br&gt;$$&lt;br&gt;如果在一个序列上的话，这应该是一个经典的斜率优化，对于任意$ a &amp;lt; b $，若要求对于i来说决策a比b更优，则&lt;br&gt;$$&lt;br&gt;p_i &amp;lt; \frac{f[b] - f[a]}{dis[b] - dis[a]}&lt;br&gt;$$&lt;br&gt;由于p不具有单调性，因此不能从队头删除元素，而应在队列中二分查找最优的决策&lt;br&gt;再加上对于决策的位置有l的限制，因此还需要用线段树&lt;/p&gt;
&lt;p&gt;那么对于本题，在树上进行转移，就需要树链剖分了&lt;br&gt;剖分后的线段树上每个节点开一个vector，维护这个节点的决策集合，一个原树上的点最多出现在log个vector中，因此空间复杂度是对的&lt;br&gt;一遍dfs进行转移，维护一个根到当前节点的栈，转移时通过跳top将所有满足小于等于$l_x$的点分割成线段树上的区间，在线段树的各个vector上二分查找最优决策，取最小值，得到当前dp值，再在线段树上进行修改，最多修改log个节点，每个节点把队尾不优的决策弹出，再压如新决策&lt;br&gt;网上的题解都把这个方法叫树剖线段树维护凸包&lt;/p&gt;
&lt;p&gt;下面的代码洛谷上可过，BZOJ上会RE&lt;br&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树链剖分" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="斜率优化" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ4543 [POI2014]Hotel加强版</title>
    <link href="http://yoursite.com/2019/07/17/BZOJ4543-POI2014-Hotel%E5%8A%A0%E5%BC%BA%E7%89%88/"/>
    <id>http://yoursite.com/2019/07/17/BZOJ4543-POI2014-Hotel加强版/</id>
    <published>2019-07-17T04:59:42.000Z</published>
    <updated>2019-07-18T05:58:05.663Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4543" target="_blank" rel="noopener">BZOJ4543</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>长链剖分第一题<br>考虑答案只可能后两种情况</p><ol><li>一个点往下三个分支</li><li>一个点往下两个分支，其中一个再往下有两个分支</li></ol><p>考虑都在最上方的LCA处统计，鉴于第二种比较特殊，我们定义两个dp数组</p><p>令$f[i][j]$表示i的子树中与i距离为j的点数<br>令$g[i][j]$表示i的子树中，两个点到其lca距离均为d，且lca到i的距离为$d - j$的点对数</p><p>这样就可以在最上方的LCA由f和g拼接出两种情况，转移方程如下：(v是u的儿子)<br>$$<br>f[u][j] += f[v][j-1]<br>$$$$<br>g[u][j] += g[v][j+1]<br>$$$$<br>ans += f[u][j-1] \times g[v][j] + f[v][j] \times g[u][j+1]<br>$$$$<br>ans += g[u][0]<br>$$<br>这样的做法是$O(n^2)$的<br>可以使用长链剖分优化到$ O(nlogn) $<br>每个点的f和g数组可以由重儿子继承来，再讲请儿子合并进去<br>巧妙的地方在于，合并轻儿子时并不需要枚举满的第二维，只要枚举轻儿子的链长，因为轻儿子向下的最长长度就是链长。因此总共枚举的第二维实际上是$ O(n) $的<br>正是这一点巧妙地保证了时间复杂度。从重儿子继承只是其中必要的一环，优化的关键在于转移是可以与深度有关的。<br>不仅仅是状态与深度有关，转移也要与深度有关</p><p>还有关于如何从重儿子继承的问题，可以直接复制指针，但数组指针无法修改，单单是一个指针的话没有内存是无法下标访问的，因此事先为所有点声明好空间（也是$O(n)$)的。代码中的id变量的作用就是为每个指针预留下足够的空间。<br>具体可以研究代码，是一个新技巧。<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ver[++tot] = y, Next[tot] = head[x], head[x] = tot; &#125;</span><br><span class="line"><span class="keyword">int</span> son[maxn], mx[maxn], *f[maxn], *g[maxn], fa[maxn], tmp[maxn * <span class="number">6</span>], *id = tmp;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">    fa[x] = pa; mx[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) &#123;</span><br><span class="line">        dfs(ver[i], x);</span><br><span class="line">        <span class="keyword">if</span>(mx[ver[i]] + <span class="number">1</span> &gt; mx[x]) son[x] = ver[i], mx[x] = mx[ver[i]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Give</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; f[x] = id; id += mx[x] + <span class="number">1</span>; id += mx[x] + <span class="number">1</span>; g[x] = id; id += mx[x] + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) f[son[x]] = f[x] + <span class="number">1</span>, g[son[x]] = g[x] - <span class="number">1</span>, dp(son[x]);</span><br><span class="line">    f[x][<span class="number">0</span>] = <span class="number">1</span>; ans += g[x][<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x] &amp;&amp; ver[i] != son[x])&#123;</span><br><span class="line">        Give(ver[i]); dp(ver[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mx[ver[i]]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j) ans += f[x][j<span class="number">-1</span>] * g[ver[i]][j];</span><br><span class="line">            ans += g[x][j+<span class="number">1</span>] * f[ver[i]][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mx[ver[i]]; j++) &#123;</span><br><span class="line">            g[x][j+<span class="number">1</span>] += f[x][j+<span class="number">1</span>] * f[ver[i]][j];</span><br><span class="line">            <span class="keyword">if</span>(j) g[x][j<span class="number">-1</span>] += g[ver[i]][j];</span><br><span class="line">            f[x][j+<span class="number">1</span>] += f[ver[i]][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>); Give(<span class="number">1</span>); dp(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=4543&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ4543&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;长链剖分第一题&lt;br&gt;考虑答案只可能后两种情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个点往下三个分支&lt;/li&gt;
&lt;li&gt;一个点往下两个分支，其中一个再往下有两个分支&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;考虑都在最上方的LCA处统计，鉴于第二种比较特殊，我们定义两个dp数组&lt;/p&gt;
&lt;p&gt;令$f[i][j]$表示i的子树中与i距离为j的点数&lt;br&gt;令$g[i][j]$表示i的子树中，两个点到其lca距离均为d，且lca到i的距离为$d - j$的点对数&lt;/p&gt;
&lt;p&gt;这样就可以在最上方的LCA由f和g拼接出两种情况，转移方程如下：(v是u的儿子)&lt;br&gt;$$&lt;br&gt;f[u][j] += f[v][j-1]&lt;br&gt;$$$$&lt;br&gt;g[u][j] += g[v][j+1]&lt;br&gt;$$$$&lt;br&gt;ans += f[u][j-1] \times g[v][j] + f[v][j] \times g[u][j+1]&lt;br&gt;$$$$&lt;br&gt;ans += g[u][0]&lt;br&gt;$$&lt;br&gt;这样的做法是$O(n^2)$的&lt;br&gt;可以使用长链剖分优化到$ O(nlogn) $&lt;br&gt;每个点的f和g数组可以由重儿子继承来，再讲请儿子合并进去&lt;br&gt;巧妙的地方在于，合并轻儿子时并不需要枚举满的第二维，只要枚举轻儿子的链长，因为轻儿子向下的最长长度就是链长。因此总共枚举的第二维实际上是$ O(n) $的&lt;br&gt;正是这一点巧妙地保证了时间复杂度。从重儿子继承只是其中必要的一环，优化的关键在于转移是可以与深度有关的。&lt;br&gt;不仅仅是状态与深度有关，转移也要与深度有关&lt;/p&gt;
&lt;p&gt;还有关于如何从重儿子继承的问题，可以直接复制指针，但数组指针无法修改，单单是一个指针的话没有内存是无法下标访问的，因此事先为所有点声明好空间（也是$O(n)$)的。代码中的id变量的作用就是为每个指针预留下足够的空间。&lt;br&gt;具体可以研究代码，是一个新技巧。&lt;br&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="长链剖分" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="树形dp" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2dp/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ1488 [HNOI2009]图的同构</title>
    <link href="http://yoursite.com/2019/07/15/BZOJ1488-HNOI2009-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84/"/>
    <id>http://yoursite.com/2019/07/15/BZOJ1488-HNOI2009-图的同构/</id>
    <published>2019-07-15T11:50:59.000Z</published>
    <updated>2019-07-16T06:12:56.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://lydsy.com/JudgeOnline/problem.php?id=1488" target="_blank" rel="noopener">BZOJ1488</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意求N个点不同构图的个数<br>显然要用Burnside引理<br>思路就是求出每个置换的循环个数，求2的幂的平均值<br>需要注意求的是<strong>点</strong>置换下的<strong>边</strong>循环<br>分情况讨论：</p><ol><li><p>一个长度为$x$的点的循环内部有$\lfloor\frac{x}{2}\rfloor$个边的循环。</p></li><li><p>两个长度分别为$x$和$y$的点的循环之间有$gcd(x,y)$个边的循环</p></li></ol><p>这个画画图就能明白，对于第一点，实际上是不同“长度”的边，对于第二点，每个循环节的长度一定是lcm，因此个数就是gcd</p><p>但是置换共有$n!$个，无法枚举<br>事实上我们只需要知道每个循环的大小，求出来后乘以方案数即可。因此考虑枚举n的拆分，求出每种拆分的方案数。设共k个循环，长度分别为$a[i]$，每种长度有$c[i]$个，则方案数为：<br>$$<br>\frac{n!}{\Pi a[i]\Pi c[i]！}<br>$$<br>因为长度相同的要除以排列数，每一个循环里会有$a[i]$个是循环相同的，也要除掉</p><p>最后，本题卡常，gcd和逆元都要预处理，少了一个都会TLE（亲身实践）<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">65</span>, mod = <span class="number">997</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn], cnt, fac[maxn], c[maxn], ans, rev[maxn], rfac[maxn], g[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">int</span> res = <span class="number">1</span>; <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod; <span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">if</span>(!x) <span class="keyword">return</span> y; <span class="keyword">return</span> gcd(y % x, x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = fac[n], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c[i]; j++) a[++cnt] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) tmp = tmp * rev[a[i]] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(c[i]) tmp = tmp * rfac[c[i]] % mod;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) num += a[i] / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= cnt; j++) num += g[a[i]][a[j]];</span><br><span class="line">    ans = (ans + tmp * Power(<span class="number">2</span>, num) % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) &#123; c[<span class="number">1</span>] = n - s; calc(); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s + i * x &lt;= n; i++) c[x] = i, dfs(x - <span class="number">1</span>, s + i * x), c[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = fac[i<span class="number">-1</span>] * i % mod, rfac[i] = Power(fac[i], mod - <span class="number">2</span>);</span><br><span class="line">    rev[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) rev[i] = (mod - mod / i) % mod * rev[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) g[i][j] = gcd(i, j);</span><br><span class="line">    dfs(n, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * Power(fac[n], mod - <span class="number">2</span>) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://lydsy.com/JudgeOnline/problem.php?id=1488&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1488&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题意求N个点不同构图的个数&lt;br&gt;显然要用Burnside引理&lt;br&gt;思路就是求出每个置换的循环个数，求2的幂的平均值&lt;br&gt;需要注意求的是&lt;strong&gt;点&lt;/strong&gt;置换下的&lt;strong&gt;边&lt;/strong&gt;循环&lt;br&gt;分情况讨论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个长度为$x$的点的循环内部有$\lfloor\frac{x}{2}\rfloor$个边的循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两个长度分别为$x$和$y$的点的循环之间有$gcd(x,y)$个边的循环&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个画画图就能明白，对于第一点，实际上是不同“长度”的边，对于第二点，每个循环节的长度一定是lcm，因此个数就是gcd&lt;/p&gt;
&lt;p&gt;但是置换共有$n!$个，无法枚举&lt;br&gt;事实上我们只需要知道每个循环的大小，求出来后乘以方案数即可。因此考虑枚举n的拆分，求出每种拆分的方案数。设共k个循环，长度分别为$a[i]$，每种长度有$c[i]$个，则方案数为：&lt;br&gt;$$&lt;br&gt;\frac{n!}{\Pi a[i]\Pi c[i]！}&lt;br&gt;$$&lt;br&gt;因为长度相同的要除以排列数，每一个循环里会有$a[i]$个是循环相同的，也要除掉&lt;/p&gt;
&lt;p&gt;最后，本题卡常，gcd和逆元都要预处理，少了一个都会TLE（亲身实践）&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="组合" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88/"/>
    
      <category term="Burnside引理" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/Burnside%E5%BC%95%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2655 calc</title>
    <link href="http://yoursite.com/2019/07/15/BZOJ2655-calc/"/>
    <id>http://yoursite.com/2019/07/15/BZOJ2655-calc/</id>
    <published>2019-07-15T09:27:05.000Z</published>
    <updated>2019-07-18T05:58:47.564Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2655" target="_blank" rel="noopener">BZOJ2655</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>我真是见识到了插值这个东西的好处<br>第一步的想法是直接退出一个式子，这样最好，如果没有两两不同的限制，那么式子很简单就是$[\frac{A(A+1)}{2}]^n$<br>多了不同这个限制，那么容斥就好了，总方案$-$一对相同$+$两对相同$-…$<br>这样写出式子看看<br>$$<br>(\sum_{i=1}^Ai)^n-C_{n-1}^1(\sum_{i=1}^Ai)^{n-2}(\sum_{i=1}^Ai^2)+…<br>$$<br>但是第三项开始就不好写了，因为可能是三连等，也可能有两对分别相同<br>然而我们可以发现不管怎么写，这个式子始终是一个关于A的$2n$次多项式。每一项都是这个次数。<br>然后用插值就好了，根本不用考虑什么烦人的容斥，反正插出来都一样<br>这样A再大都可以被降到2n的级别，考虑暴力做法算$0…2n$的函数值就可以了<br>实在是太神了，感觉什么都没做，就解决了容斥的问题！<br>暴力的部分用dp就可以了，令$f[i][j]$表示j个小于等于i的正整数的所有序列的值得和，则<br>$$<br>f[i][j] = f[i-1][j-1] \times i \times j + f[i-1][j]<br>$$<br>意思是，如果j个数中有i，共有j种情况，每种的值都会乘以i，从f[i-1][j-1]转移，否则和f[i-1][j]相同</p><p>感觉如果发现某题的式子是个多项式，那么这题就可以转化为暴力题了<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll mod, A, n, f[maxn*<span class="number">2</span>][maxn], ans;</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;A, &amp;n, &amp;mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            f[i][j] = (f[i<span class="number">-1</span>][j<span class="number">-1</span>] * i % mod * j % mod + f[i<span class="number">-1</span>][j]) % mod;</span><br><span class="line">    <span class="keyword">if</span>(A &lt;= n * <span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[A][n]); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        ll s1 = <span class="number">1</span>, s2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n * <span class="number">2</span>; j++) <span class="keyword">if</span>(i != j) </span><br><span class="line">            s1 = (A - j + mod) % mod * s1 % mod, s2 = (i - j + mod) % mod * s2 % mod;</span><br><span class="line">        ans = (ans + s1 * f[i][n] % mod * Power(s2, mod - <span class="number">2</span>) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2655&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2655&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;我真是见识到了插值这个东西的好处&lt;br&gt;第一步的想法是直接退出一个式子，这样最好，如果没有两两不同的限制，那么式子很简单就是$[\frac{A(A+1)}{2}]^n$&lt;br&gt;多了不同这个限制，那么容斥就好了，总方案$-$一对相同$+$两对相同$-…$&lt;br&gt;这样写出式子看看&lt;br&gt;$$&lt;br&gt;(\sum_{i=1}^Ai)^n-C_{n-1}^1(\sum_{i=1}^Ai)^{n-2}(\sum_{i=1}^Ai^2)+…&lt;br&gt;$$&lt;br&gt;但是第三项开始就不好写了，因为可能是三连等，也可能有两对分别相同&lt;br&gt;然而我们可以发现不管怎么写，这个式子始终是一个关于A的$2n$次多项式。每一项都是这个次数。&lt;br&gt;然后用插值就好了，根本不用考虑什么烦人的容斥，反正插出来都一样&lt;br&gt;这样A再大都可以被降到2n的级别，考虑暴力做法算$0…2n$的函数值就可以了&lt;br&gt;实在是太神了，感觉什么都没做，就解决了容斥的问题！&lt;br&gt;暴力的部分用dp就可以了，令$f[i][j]$表示j个小于等于i的正整数的所有序列的值得和，则&lt;br&gt;$$&lt;br&gt;f[i][j] = f[i-1][j-1] \times i \times j + f[i-1][j]&lt;br&gt;$$&lt;br&gt;意思是，如果j个数中有i，共有j种情况，每种的值都会乘以i，从f[i-1][j-1]转移，否则和f[i-1][j]相同&lt;/p&gt;
&lt;p&gt;感觉如果发现某题的式子是个多项式，那么这题就可以转化为暴力题了&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="拉格朗日插值" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
    
      <category term="计数dp" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%AE%A1%E6%95%B0dp/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ5339 [TJOI2018]教科书般的亵渎</title>
    <link href="http://yoursite.com/2019/07/14/BZOJ5339-TJOI2018-%E6%95%99%E7%A7%91%E4%B9%A6%E8%88%AC%E7%9A%84%E4%BA%B5%E6%B8%8E/"/>
    <id>http://yoursite.com/2019/07/14/BZOJ5339-TJOI2018-教科书般的亵渎/</id>
    <published>2019-07-14T13:11:55.000Z</published>
    <updated>2019-07-18T06:05:08.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5339" target="_blank" rel="noopener">BZOJ5339</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题面好难理解啊<br>不过多看几遍，再算算样例，也就懂了<br>可以转化为求$ \sum_{i=1}^ni^m $（n，m不是题面中的）<br>经典的自然数幂和问题，有五种经典算法</p><ul><li>伯努利数</li><li>递推</li><li>差分序列</li></ul><p>我使用了另外两种方法</p><h2><span id="拉格朗日插值">拉格朗日插值</span></h2><p>$m$次自然数幂和是一个$m+1$次多项式，可以举$m=1$的例子，容易发现这一点<br>这样将$x=0…m+1$带进去，得到$m+2$个点，然后插值即可<br>暴力做法$O(m^2)$，但由于取的是等间隔的x，因此可以优化到$O(m)$</p><h2><span id="第二类斯特林数">第二类斯特林数</span></h2><p>下文中加点表示降阶函数，也就是下划线<br>第二类斯特林数有生成函数<br>$$<br>x^n=\sum_{i=0}^n<br>\begin{Bmatrix}<br>n \\<br>i \\<br>\end{Bmatrix}x^{i.}<br>$$<br>因此原式可以这样展开<br>$$<br>\sum_{i=0}^ni^m = \sum_{i=0}^n\sum_{j=0}^m<br>\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}i^{j.}<br>$$<br>$$<br>=\sum_{j=0}^m\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}j!\sum_{i=0}^n\begin{pmatrix}<br>i \\<br>j \\<br>\end{pmatrix}<br>$$<br>$$<br>= \sum_{j=0}^m\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}j!\begin{pmatrix}<br>n + 1 \\<br>j + 1 \\<br>\end{pmatrix}<br>$$<br>$$<br>=\sum_{j=1}^m\begin{Bmatrix}<br>m \\<br>j \\<br>\end{Bmatrix}\frac{(n+1)^{(j+1).}}{j+1}<br>$$<br>然后就可以$O(n^2)$算了<br><a id="more"></a></p><h1><span id="code">Code</span></h1><h2><span id="拉格朗日插值">拉格朗日插值</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">60</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn], pre[maxn], suf[maxn], y[maxn], fac[maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    y[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m + <span class="number">1</span>; i++) y[i] = (y[i<span class="number">-1</span>] + Power(i, m)) % mod;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= m + <span class="number">1</span>) <span class="keyword">return</span> y[n];</span><br><span class="line">    pre[<span class="number">0</span>] = n; suf[m + <span class="number">1</span>] = n - m - <span class="number">1</span>; fac[<span class="number">0</span>] = <span class="number">1</span>; suf[m + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) pre[i] = pre[i<span class="number">-1</span>] * (n - i) % mod, fac[i] = fac[i<span class="number">-1</span>] * Power(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i--) suf[i] = suf[i+<span class="number">1</span>] * (n - i) % mod;</span><br><span class="line">    ll res = suf[<span class="number">1</span>] * fac[m + <span class="number">1</span>] % mod * y[<span class="number">0</span>] % mod;</span><br><span class="line">    <span class="keyword">if</span>((m + <span class="number">1</span>) &amp; <span class="number">1</span>) res = (mod - res) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ll tmp = suf[i + <span class="number">1</span>] * pre[i - <span class="number">1</span>] % mod * fac[i] % mod * fac[m + <span class="number">1</span> - i] % mod;</span><br><span class="line">        <span class="keyword">if</span>((m - i + <span class="number">1</span>) &amp; <span class="number">1</span>) tmp = (mod - tmp) % mod;</span><br><span class="line">        res = (res + tmp * y[i] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    ll n, m;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">        a[m + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                ans= (ans + S(a[j] - a[i<span class="number">-1</span>] - <span class="number">1</span>, m + <span class="number">1</span>)) % mod;</span><br><span class="line">                ans = (ans + mod - S(a[j<span class="number">-1</span>] - a[i<span class="number">-1</span>], m + <span class="number">1</span>)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="第二类斯特林数">第二类斯特林数</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">60</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn], pre[maxn], suf[maxn], y[maxn], fac[maxn], s[maxn][maxn];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= m) &#123; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = (res + Power(i, m)) % mod; <span class="keyword">return</span> res; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        ll tmp = s[m][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n - i + <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++) tmp = tmp * j % mod;</span><br><span class="line">        tmp = tmp * Power(i + <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        res = (res + tmp) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    ll n, m;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) s[i][j] = (s[i<span class="number">-1</span>][j<span class="number">-1</span>] + s[i<span class="number">-1</span>][j] * j % mod) % mod;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">        a[m + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                ans= (ans + S(a[j] - a[i<span class="number">-1</span>] - <span class="number">1</span>, m + <span class="number">1</span>)) % mod;</span><br><span class="line">                ans = (ans + mod - S(a[j<span class="number">-1</span>] - a[i<span class="number">-1</span>], m + <span class="number">1</span>)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=5339&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ5339&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题面好难理解啊&lt;br&gt;不过多看几遍，再算算样例，也就懂了&lt;br&gt;可以转化为求$ \sum_{i=1}^ni^m $（n，m不是题面中的）&lt;br&gt;经典的自然数幂和问题，有五种经典算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伯努利数&lt;/li&gt;
&lt;li&gt;递推&lt;/li&gt;
&lt;li&gt;差分序列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我使用了另外两种方法&lt;/p&gt;
&lt;h2 id=&quot;拉格朗日插值&quot;&gt;&lt;a href=&quot;#拉格朗日插值&quot; class=&quot;headerlink&quot; title=&quot;拉格朗日插值&quot;&gt;&lt;/a&gt;拉格朗日插值&lt;/h2&gt;&lt;p&gt;$m$次自然数幂和是一个$m+1$次多项式，可以举$m=1$的例子，容易发现这一点&lt;br&gt;这样将$x=0…m+1$带进去，得到$m+2$个点，然后插值即可&lt;br&gt;暴力做法$O(m^2)$，但由于取的是等间隔的x，因此可以优化到$O(m)$&lt;/p&gt;
&lt;h2 id=&quot;第二类斯特林数&quot;&gt;&lt;a href=&quot;#第二类斯特林数&quot; class=&quot;headerlink&quot; title=&quot;第二类斯特林数&quot;&gt;&lt;/a&gt;第二类斯特林数&lt;/h2&gt;&lt;p&gt;下文中加点表示降阶函数，也就是下划线&lt;br&gt;第二类斯特林数有生成函数&lt;br&gt;$$&lt;br&gt;x^n=\sum_{i=0}^n&lt;br&gt;\begin{Bmatrix}&lt;br&gt;n \\&lt;br&gt;i \\&lt;br&gt;\end{Bmatrix}x^{i.}&lt;br&gt;$$&lt;br&gt;因此原式可以这样展开&lt;br&gt;$$&lt;br&gt;\sum_{i=0}^ni^m = \sum_{i=0}^n\sum_{j=0}^m&lt;br&gt;\begin{Bmatrix}&lt;br&gt;m \\&lt;br&gt;j \\&lt;br&gt;\end{Bmatrix}i^{j.}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;=\sum_{j=0}^m\begin{Bmatrix}&lt;br&gt;m \\&lt;br&gt;j \\&lt;br&gt;\end{Bmatrix}j!\sum_{i=0}^n\begin{pmatrix}&lt;br&gt;i \\&lt;br&gt;j \\&lt;br&gt;\end{pmatrix}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;= \sum_{j=0}^m\begin{Bmatrix}&lt;br&gt;m \\&lt;br&gt;j \\&lt;br&gt;\end{Bmatrix}j!\begin{pmatrix}&lt;br&gt;n + 1 \\&lt;br&gt;j + 1 \\&lt;br&gt;\end{pmatrix}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;=\sum_{j=1}^m\begin{Bmatrix}&lt;br&gt;m \\&lt;br&gt;j \\&lt;br&gt;\end{Bmatrix}\frac{(n+1)^{(j+1).}}{j+1}&lt;br&gt;$$&lt;br&gt;然后就可以$O(n^2)$算了&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="拉格朗日插值" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
    
      <category term="斯特林数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2806 [Ctsc2012]Cheat</title>
    <link href="http://yoursite.com/2019/07/13/BZOJ2806-Ctsc2012-Cheat/"/>
    <id>http://yoursite.com/2019/07/13/BZOJ2806-Ctsc2012-Cheat/</id>
    <published>2019-07-13T09:25:12.000Z</published>
    <updated>2019-07-16T06:12:33.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2806" target="_blank" rel="noopener">BZOJ2806</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>容易发现，L具有单调性，因此可以二分答案<br>考虑如何判定，分段，长度有限制，容易想到经典的1D1D动规，方程如下：<br>$$<br>f[i] = max(f[j] + i - j, f[i-1]),\ i - maxlen[i] \leq j \leq i - L<br>$$<br>其中maxlen表示以i为右端点能够匹配的最长子串<br>这个方程明显可以用单调队列优化，由于左右都有限制，因此每次入队入的是很久之前算的那个位置<br><del>我最开始的写法不知为何是错的，不知为何啊</del><br>剩下的就是怎样算maxlen<br>将所有的模板串建成广义后缀自动机，之后所有的maxlen可以用一个自动机上的指针一遍预处理出来，就是每次如果无法向下转移就跳父亲，直到可以走DAG为止，跳完父亲len要用val更新，走转移边就是len++，这样才能保证正确</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2200010</span>;</span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">2</span>], par[maxn], val[maxn], rt = <span class="number">1</span>, cnt = <span class="number">1</span>, las = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np = ++cnt, p = las; val[np] = val[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line">    <span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][x];</span><br><span class="line">        <span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line">            ch[nq][<span class="number">0</span>] = ch[q][<span class="number">0</span>]; ch[nq][<span class="number">1</span>] = ch[q][<span class="number">1</span>];</span><br><span class="line">            par[nq] = par[q];</span><br><span class="line">            par[q] = par[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    las = np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> ml[maxn], f[maxn], q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] - x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) f[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; calc(q[tail]) &lt; calc(i - l)) tail--;</span><br><span class="line">        q[++tail] = i - l;</span><br><span class="line">        <span class="keyword">while</span>(head &lt;= tail &amp;&amp; q[head] &lt; i - ml[i]) head++;</span><br><span class="line">        <span class="keyword">if</span>(head &lt;= tail) f[i] = max(f[i], calc(q[head]) + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n] * <span class="number">10</span> &gt;= n * <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(str); j++) extend(str[j] - <span class="string">'0'</span>);</span><br><span class="line">        las = rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>); m = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cur = rt, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = str[j] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">while</span>(cur &amp;&amp; !ch[cur][u]) cur = par[cur], len = val[cur];</span><br><span class="line">            <span class="keyword">if</span>(!cur) &#123; ml[j] = <span class="number">0</span>; cur = rt; len = <span class="number">0</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            cur = ch[cur][u]; len++;</span><br><span class="line">            ml[j] = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = m;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid, m)) l = mid; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2806&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2806&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;容易发现，L具有单调性，因此可以二分答案&lt;br&gt;考虑如何判定，分段，长度有限制，容易想到经典的1D1D动规，方程如下：&lt;br&gt;$$&lt;br&gt;f[i] = max(f[j] + i - j, f[i-1]),\ i - maxlen[i] \leq j \leq i - L&lt;br&gt;$$&lt;br&gt;其中maxlen表示以i为右端点能够匹配的最长子串&lt;br&gt;这个方程明显可以用单调队列优化，由于左右都有限制，因此每次入队入的是很久之前算的那个位置&lt;br&gt;&lt;del&gt;我最开始的写法不知为何是错的，不知为何啊&lt;/del&gt;&lt;br&gt;剩下的就是怎样算maxlen&lt;br&gt;将所有的模板串建成广义后缀自动机，之后所有的maxlen可以用一个自动机上的指针一遍预处理出来，就是每次如果无法向下转移就跳父亲，直到可以走DAG为止，跳完父亲len要用val更新，走转移边就是len++，这样才能保证正确&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="单调队列优化" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3926 [Zjoi2015]诸神眷顾的幻想乡</title>
    <link href="http://yoursite.com/2019/07/12/BZOJ3926-Zjoi2015-%E8%AF%B8%E7%A5%9E%E7%9C%B7%E9%A1%BE%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/"/>
    <id>http://yoursite.com/2019/07/12/BZOJ3926-Zjoi2015-诸神眷顾的幻想乡/</id>
    <published>2019-07-12T14:44:52.000Z</published>
    <updated>2019-07-13T00:53:12.617Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3926" target="_blank" rel="noopener">BZOJ3926</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>20min 1A庆祝一下<br>国家队论文写过一个trie上SAM的科技<br>其实可以类比广义后缀自动机加入多个串，trie树上无非是每个点插入前将las移到其父亲对应的节点<br>本题由于叶子不超过20个，以每个叶子为根，分别遍历一遍trie，全部加入一个广义自动机中，累计每个节点的max-min+1即可<br>由于所有有向路径都可以看成以一个叶子为根的一个直的路径（也就是trie上的“子串”），因此正确性可以保证<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, C, col[maxn], head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot;</span><br><span class="line"><span class="keyword">int</span> du[maxn], cnt = <span class="number">1</span>, rt = <span class="number">1</span>, ch[maxn * <span class="number">40</span>][<span class="number">10</span>], par[maxn * <span class="number">40</span>], val[maxn * <span class="number">40</span>], pos[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np = ++cnt; val[np] = val[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line">    <span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = ch[p][x];</span><br><span class="line">        <span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span>(ch[nq]));</span><br><span class="line">            par[nq] = par[q];</span><br><span class="line">            par[q] = par[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    pos[x] = extend(col[x], pos[fa]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa) dfs(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;C);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x), du[x]++, du[y]++;</span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(du[i] == <span class="number">1</span>) dfs(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) ans += val[i] - val[par[i]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3926&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3926&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;20min 1A庆祝一下&lt;br&gt;国家队论文写过一个trie上SAM的科技&lt;br&gt;其实可以类比广义后缀自动机加入多个串，trie树上无非是每个点插入前将las移到其父亲对应的节点&lt;br&gt;本题由于叶子不超过20个，以每个叶子为根，分别遍历一遍trie，全部加入一个广义自动机中，累计每个节点的max-min+1即可&lt;br&gt;由于所有有向路径都可以看成以一个叶子为根的一个直的路径（也就是trie上的“子串”），因此正确性可以保证&lt;br&gt;
    
    </summary>
    
      <category term="字符串" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3277 串</title>
    <link href="http://yoursite.com/2019/07/12/BZOJ3277-%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/07/12/BZOJ3277-串/</id>
    <published>2019-07-12T12:04:13.000Z</published>
    <updated>2019-07-12T13:56:57.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3277" target="_blank" rel="noopener">BZOJ3277</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>第一道广义后缀自动机<br>其实广义后缀自动机就是每加入一个串后，将las移到根，然后毫无变化地继续建就可以<br>厉害的是这样建出来后就可以匹配原来所有字符串的子串</p><p>对于本题，每个节点开一个set记录该位置子串出现的母字符串集合，建完自动机后dfs将子树set合并到父亲上去，有用的是每个节点最后的set大小<br>然后对于每个字符串开始在自动机上跑，首先按字符在DAG上转移，若当前set大小小于k，则不停跳父亲，知道大于等于位置，然后直接将此节点的max长度累加入答案。<br>之所以直接累加max，是因为该节点的祖先们一定也满足条件<br>可以发现，这样就不重不漏的统计了该字符串所有合法的子串（走DAG相当于右端点后移，跳父亲相当于将左端点调到合适位置，累加max便是将所有右端点为此的合法子串统计了）</p><p>有一个关键点，经过亲身测试和调试，广义后缀自动机不能使用基数排序得到拓扑序，必须dfs</p><p>最后的问题是，set合并的过程看起来很暴力，那为什么他是对的？<br>目前不知道，连自动机的复杂度都不会证，回头再填坑<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">27</span>], par[maxn], val[maxn], cnt = <span class="number">1</span>, rt = <span class="number">1</span>, las = <span class="number">1</span>, n, k;</span><br><span class="line"><span class="keyword">int</span> L, sz[maxn], head[maxn], ver[maxn &lt;&lt; <span class="number">1</span>], Next[maxn &lt;&lt; <span class="number">1</span>], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s[maxn];</span><br><span class="line"><span class="built_in">string</span> str[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = las, np = ++cnt; s[np].insert(cur); val[np] = val[p] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = par[p];</span><br><span class="line"><span class="keyword">if</span>(!p) par[np] = rt;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> q = ch[p][x];</span><br><span class="line"><span class="keyword">if</span>(val[q] == val[p] + <span class="number">1</span>) par[np] = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> nq = ++cnt; val[nq] = val[p] + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span>(ch[nq]));</span><br><span class="line">par[nq] = par[q];</span><br><span class="line">par[q] = par[np] = nq;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = par[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">las = np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != par[x]) &#123;</span><br><span class="line">dfs(ver[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator j = s[ver[i]].begin(); j != s[ver[i]].end(); j++) s[x].insert(*j);</span><br><span class="line">&#125;</span><br><span class="line">sz[x] = s[x].size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line">L += str[i].length();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str[i].length(); j++) extend(str[i][j] - <span class="string">'a'</span>, i);</span><br><span class="line">las = rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) add(i, par[i]), add(par[i], i);</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, cur = rt;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str[i].length(); j++) &#123;</span><br><span class="line">cur = ch[cur][str[i][j] - <span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">while</span>(cur &amp;&amp; sz[cur] &lt; k) cur = par[cur];</span><br><span class="line">ans += val[cur];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3277&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3277&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;第一道广义后缀自动机&lt;br&gt;其实广义后缀自动机就是每加入一个串后，将las移到根，然后毫无变化地继续建就可以&lt;br&gt;厉害的是这样建出来后就可以匹配原来所有字符串的子串&lt;/p&gt;
&lt;p&gt;对于本题，每个节点开一个set记录该位置子串出现的母字符串集合，建完自动机后dfs将子树set合并到父亲上去，有用的是每个节点最后的set大小&lt;br&gt;然后对于每个字符串开始在自动机上跑，首先按字符在DAG上转移，若当前set大小小于k，则不停跳父亲，知道大于等于位置，然后直接将此节点的max长度累加入答案。&lt;br&gt;之所以直接累加max，是因为该节点的祖先们一定也满足条件&lt;br&gt;可以发现，这样就不重不漏的统计了该字符串所有合法的子串（走DAG相当于右端点后移，跳父亲相当于将左端点调到合适位置，累加max便是将所有右端点为此的合法子串统计了）&lt;/p&gt;
&lt;p&gt;有一个关键点，经过亲身测试和调试，广义后缀自动机不能使用基数排序得到拓扑序，必须dfs&lt;/p&gt;
&lt;p&gt;最后的问题是，set合并的过程看起来很暴力，那为什么他是对的？&lt;br&gt;目前不知道，连自动机的复杂度都不会证，回头再填坑&lt;br&gt;
    
    </summary>
    
      <category term="字符串" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3669 [Noi2014]魔法森林</title>
    <link href="http://yoursite.com/2019/07/10/BZOJ3669-Noi2014-%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97/"/>
    <id>http://yoursite.com/2019/07/10/BZOJ3669-Noi2014-魔法森林/</id>
    <published>2019-07-10T09:22:52.000Z</published>
    <updated>2019-07-10T12:45:56.464Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3669" target="_blank" rel="noopener">BZOJ3669</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>第一想法是二分<br>然而不能二分a+b，更不能二分a或b<br>因此把a和b分开考虑<br>将所有边按照a排序，把b看成边权，一条一条加进去，维护1到n的最大边权最小的路径，随时更新答案<br>容易证明这条路径一定在最小生成树上<br>因此要在加边的过程中维护最小生成树<br>需要支持询问两点路径上的最大边权，以及最大边权所在的是那条边<br>加边时若构成环，则查询路径上的最大边，若大于当前边，则cut掉，然后加入当前边，否则跳过<br>若不构成环，就直接加入当前边<br>使用LCT维护，每个点记录子树最大权值及取到的位置，由于LCT只能维护点权，因此为每条边新建一个点，连到边的两个端点上<br>本题一遍过！！！<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>, maxm = <span class="number">100010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, val[maxn + maxm], fa[maxn + maxm], ch[maxn + maxm][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pos[maxn + maxm], sta[maxn + maxm], mx[maxn + maxm], rev[maxn + maxm];</span><br><span class="line"><span class="keyword">int</span> ans = inf;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edg</span> &#123;</span> <span class="keyword">int</span> x, y, a, b; &#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edg x, Edg y)</span> </span>&#123; <span class="keyword">return</span> x.a &lt; y.a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] != x &amp;&amp; ch[fa[x]][<span class="number">0</span>] != x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) <span class="built_in">printf</span>(<span class="string">"%d %d %d %d %d %d\n"</span>, i, fa[i], ch[i][<span class="number">0</span>], ch[i][<span class="number">1</span>], mx[i], rev[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mx[x] = max(val[x], max(mx[ch[x][<span class="number">0</span>]], mx[ch[x][<span class="number">1</span>]]));</span><br><span class="line">    <span class="keyword">if</span>(mx[x] == val[x]) pos[x] = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mx[x] == mx[ch[x][<span class="number">0</span>]]) pos[x] = pos[ch[x][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">else</span> pos[x] = pos[ch[x][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] ^= <span class="number">1</span>; rev[ch[x][<span class="number">0</span>]] ^= <span class="number">1</span>; rev[ch[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], d = get(x);</span><br><span class="line">    ch[y][d] = ch[x][d ^ <span class="number">1</span>]; fa[ch[y][d]] = y;</span><br><span class="line">    <span class="keyword">if</span>(!isroot(y)) ch[fa[y]][get(y)] = x;</span><br><span class="line">    fa[x] = fa[y];</span><br><span class="line">    ch[x][d ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">    pushup(y); pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>; sta[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) sta[++top] = fa[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i; i--) pushdown(sta[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pa = fa[x]; !isroot(x); pa = fa[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isroot(pa)) rotate(get(x) == get(pa) ? pa : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; x; t = x, x = fa[x]) </span><br><span class="line">        splay(x), ch[x][<span class="number">1</span>] = t, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); rev[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) pushdown(x), x = ch[x][<span class="number">0</span>]; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); access(y); splay(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; split(x, y); ch[y][<span class="number">0</span>] = fa[x] = <span class="number">0</span>; pushup(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); fa[x] = y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;edge[i].x, &amp;edge[i].y, &amp;edge[i].a, &amp;edge[i].b);</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) val[i + n] = mx[i + n] = edge[i].b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = edge[i].x, y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(findroot(x) == findroot(y)) &#123;</span><br><span class="line">            makeroot(x); access(y); splay(y);</span><br><span class="line">            <span class="keyword">if</span>(mx[y] &gt; edge[i].b) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = pos[y];</span><br><span class="line">                <span class="keyword">int</span> lc = edge[tmp - n].x, rc = edge[tmp - n].y;</span><br><span class="line">                cut(tmp, lc); cut(tmp, rc);</span><br><span class="line">                link(x, i + n); link(y, i + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> link(x, i + n), link(y, i + n);</span><br><span class="line">    <span class="comment">//debug(); cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(findroot(<span class="number">1</span>) != findroot(n)) <span class="keyword">continue</span>;</span><br><span class="line">        split(<span class="number">1</span>, n);</span><br><span class="line">        ans = min(ans, edge[i].a + mx[n]);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == inf) ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3669&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3669&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;第一想法是二分&lt;br&gt;然而不能二分a+b，更不能二分a或b&lt;br&gt;因此把a和b分开考虑&lt;br&gt;将所有边按照a排序，把b看成边权，一条一条加进去，维护1到n的最大边权最小的路径，随时更新答案&lt;br&gt;容易证明这条路径一定在最小生成树上&lt;br&gt;因此要在加边的过程中维护最小生成树&lt;br&gt;需要支持询问两点路径上的最大边权，以及最大边权所在的是那条边&lt;br&gt;加边时若构成环，则查询路径上的最大边，若大于当前边，则cut掉，然后加入当前边，否则跳过&lt;br&gt;若不构成环，就直接加入当前边&lt;br&gt;使用LCT维护，每个点记录子树最大权值及取到的位置，由于LCT只能维护点权，因此为每条边新建一个点，连到边的两个端点上&lt;br&gt;本题一遍过！！！&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCT" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LCT/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2049 [Sdoi2008]Cave 洞穴勘测</title>
    <link href="http://yoursite.com/2019/07/08/BZOJ2049-Sdoi2008-Cave-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/07/08/BZOJ2049-Sdoi2008-Cave-洞穴勘测/</id>
    <published>2019-07-08T13:58:40.000Z</published>
    <updated>2019-07-10T09:24:03.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2049" target="_blank" rel="noopener">BZOJ2049</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>不能再裸的LCT裸题<br>好久没写了，写道题复习一下，再练难的<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>, maxm = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn], ch[maxn][<span class="number">2</span>], rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] != x &amp;&amp; ch[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"><span class="keyword">int</span> sta[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] ^= <span class="number">1</span>; rev[ch[x][<span class="number">0</span>]] ^= <span class="number">1</span>; rev[ch[x][<span class="number">1</span>]] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = get(x);</span><br><span class="line">    ch[y][z] = ch[x][z ^ <span class="number">1</span>]; fa[ch[y][z]] = y;</span><br><span class="line">    <span class="keyword">if</span>(!isroot(y)) ch[fa[y]][get(y)] = x; </span><br><span class="line">    fa[x] = fa[y];</span><br><span class="line">    ch[x][z ^ <span class="number">1</span>] = y; fa[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>; sta[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; !isroot(i); i = fa[i]) sta[++top] = fa[i];</span><br><span class="line">    <span class="keyword">while</span>(top) pushdown(sta[top--]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pa = fa[x]; !isroot(x); pa = fa[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isroot(pa)) rotate(get(x) == get(pa) ? pa : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; x; t = x, x = fa[x])</span><br><span class="line">        splay(x), ch[x][<span class="number">1</span>] = t;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); rev[x] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; access(x); splay(x); <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) pushdown(x), x = ch[x][<span class="number">0</span>]; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); access(y); splay(y); fa[x] = ch[y][<span class="number">0</span>] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); fa[x] = y; &#125;</span><br><span class="line"><span class="keyword">char</span> o[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, o, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'C'</span>) link(x, y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'D'</span>) cut(x, y);</span><br><span class="line">        <span class="keyword">if</span>(o[<span class="number">0</span>] == <span class="string">'Q'</span>) <span class="built_in">printf</span>(findroot(x) == findroot(y) ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2049&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2049&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;不能再裸的LCT裸题&lt;br&gt;好久没写了，写道题复习一下，再练难的&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCT" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LCT/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2729 [HNOI2012]排队</title>
    <link href="http://yoursite.com/2019/07/08/BZOJ2729-HNOI2012-%E6%8E%92%E9%98%9F/"/>
    <id>http://yoursite.com/2019/07/08/BZOJ2729-HNOI2012-排队/</id>
    <published>2019-07-08T04:47:19.000Z</published>
    <updated>2019-07-08T06:21:56.047Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2729" target="_blank" rel="noopener">BZOJ2729</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>插板法<br>以男生为基准，先插老师，再插女生<br>若老师之间有男生，就是n插2，再插m<br>若老师之间无男生，则之间只有一个女生，看成一个男生，n+1插m-1<br>答案为<br>$$<br>n!A_{n+1}^2A_{n+3}^m + 2m(n+1)!A_{n+2}^{m-1}<br>$$<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bigint</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> len, a[maxn * <span class="number">1000</span>];</span><br><span class="line">&#125;ans, ans1, ans2;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> += (bigint &amp;x, bigint &amp;y) &#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">x.len = max(x.len, y.len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++) </span><br><span class="line">x.a[i] += y.a[i] + t, t = x.a[i] / <span class="number">10</span>, x.a[i] %= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(t) x.a[++x.len] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> *= (bigint &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++) </span><br><span class="line">x.a[i] *= y, x.a[i] += t, t = x.a[i] / <span class="number">10</span>, x.a[i] %= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(t) x.a[++x.len] = t % <span class="number">10</span>, t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(bigint &amp;x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x.len; i; i--) <span class="built_in">printf</span>(<span class="string">"%d"</span>, x.a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">ans1.len = <span class="number">1</span>; ans1.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">ans2 = ans1;</span><br><span class="line">ans1 *= n + <span class="number">1</span>; ans1 *= n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans1 *= n + <span class="number">4</span> - i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans1 *= i;</span><br><span class="line">ans2 *= <span class="number">2</span> * m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) ans2 *= n + <span class="number">3</span> - i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) ans2 *= i;</span><br><span class="line">ans1 += ans2;</span><br><span class="line">print(ans1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2729&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2729&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;插板法&lt;br&gt;以男生为基准，先插老师，再插女生&lt;br&gt;若老师之间有男生，就是n插2，再插m&lt;br&gt;若老师之间无男生，则之间只有一个女生，看成一个男生，n+1插m-1&lt;br&gt;答案为&lt;br&gt;$$&lt;br&gt;n!A_{n+1}^2A_{n+3}^m + 2m(n+1)!A_{n+2}^{m-1}&lt;br&gt;$$&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BZOJ2212 [Poi2011]Tree Rotations</title>
    <link href="http://yoursite.com/2019/07/07/BZOJ2212-Poi2011-Tree-Rotations/"/>
    <id>http://yoursite.com/2019/07/07/BZOJ2212-Poi2011-Tree-Rotations/</id>
    <published>2019-07-07T14:30:30.000Z</published>
    <updated>2019-07-07T14:47:05.726Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2212" target="_blank" rel="noopener">BZOJ2212</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>每个节点翻转所影响的逆序对是它的两棵子树之间的逆序对个数，其他的和子树内的都不影响<br>在读入的过程中就是一个dfs，在这个过程中考虑每个点是否翻转，也就是右节点中小于左节点的数对数<br>可以用线段树合并完成，每个点维护一个权值线段树和区间和<br>用子节点合并得到父节点，在合并时顺便统计一下前边所说的数对的个数，判断是否翻转，并累计答案</p><p>好了，正经话说完了，下面吐槽<br>我自认为代码写的很精炼，经过一番调试后在洛谷拿到了95分，剩下的一个点是MLE<br>最开始线段树节点数开的是maxn*50，<br>所以调成40，然后MLE<br>所以调成30，然后MLE<br>所以调成20，然后RE<br>看到人们很多写5000000，改成这个，然后MLE<br>这个点就对不了了吗[○･｀Д´･ ○]<br>去loj看看，然后发现了55个测试点，然后后面十几个点要么RE，要么TLE<br>网上的人说洛谷数据水，loj强，线段树合并过不去<br>最后去了BZOJ碰碰运气，结果RE<br>于是我下载了LOJ上一个大数据，开无线栈开始跑，打开任务管理器看占用内存<br>只见内存的那一个数据从9Mb，一路稳步上升，几分钟后达到了156Mb<br>对，几分钟后这个程序还在跑<br>然后突然156Mb降到了9Mb，程序异常退出。。。<br>不MLE+TLE+RE才怪<br>算了，我不纠结这个玄学的线段树合并了<br>它的复杂度到底会到多少啊。。。<br>下面贴上满是锅的代码<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, rt[maxn * <span class="number">8</span>], num, sum[maxn * <span class="number">30</span>], lc[maxn * <span class="number">30</span>], rc[maxn * <span class="number">30</span>], cnt;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function">ll <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> lp, <span class="keyword">int</span> rp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lp || !rp) &#123; p = lp + rp; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    p = ++cnt;</span><br><span class="line">    ll res = sum[lc[rp]] * sum[rc[lp]];</span><br><span class="line">    sum[p] = sum[lp] + sum[rp];</span><br><span class="line">    res += merge(lc[p], lc[lp], lc[rp]);</span><br><span class="line">    res += merge(rc[p], rc[lp], rc[rp]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    p = ++cnt;</span><br><span class="line">    sum[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) build(lc[p], l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> build(rc[p], mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(!x) &#123;</span><br><span class="line">        <span class="keyword">int</span> L = fuck(), R = fuck();</span><br><span class="line">        ll res = merge(rt[++num], rt[L], rt[R]);</span><br><span class="line">        ans += min(res, sum[rt[L]] * sum[rt[R]] - res);</span><br><span class="line">    &#125; <span class="keyword">else</span> build(rt[++num], <span class="number">1</span>, n, x);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    fuck();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2212&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ2212&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;每个节点翻转所影响的逆序对是它的两棵子树之间的逆序对个数，其他的和子树内的都不影响&lt;br&gt;在读入的过程中就是一个dfs，在这个过程中考虑每个点是否翻转，也就是右节点中小于左节点的数对数&lt;br&gt;可以用线段树合并完成，每个点维护一个权值线段树和区间和&lt;br&gt;用子节点合并得到父节点，在合并时顺便统计一下前边所说的数对的个数，判断是否翻转，并累计答案&lt;/p&gt;
&lt;p&gt;好了，正经话说完了，下面吐槽&lt;br&gt;我自认为代码写的很精炼，经过一番调试后在洛谷拿到了95分，剩下的一个点是MLE&lt;br&gt;最开始线段树节点数开的是maxn*50，&lt;br&gt;所以调成40，然后MLE&lt;br&gt;所以调成30，然后MLE&lt;br&gt;所以调成20，然后RE&lt;br&gt;看到人们很多写5000000，改成这个，然后MLE&lt;br&gt;这个点就对不了了吗[○･｀Д´･ ○]&lt;br&gt;去loj看看，然后发现了55个测试点，然后后面十几个点要么RE，要么TLE&lt;br&gt;网上的人说洛谷数据水，loj强，线段树合并过不去&lt;br&gt;最后去了BZOJ碰碰运气，结果RE&lt;br&gt;于是我下载了LOJ上一个大数据，开无线栈开始跑，打开任务管理器看占用内存&lt;br&gt;只见内存的那一个数据从9Mb，一路稳步上升，几分钟后达到了156Mb&lt;br&gt;对，几分钟后这个程序还在跑&lt;br&gt;然后突然156Mb降到了9Mb，程序异常退出。。。&lt;br&gt;不MLE+TLE+RE才怪&lt;br&gt;算了，我不纠结这个玄学的线段树合并了&lt;br&gt;它的复杂度到底会到多少啊。。。&lt;br&gt;下面贴上满是锅的代码&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ3653 谈笑风生</title>
    <link href="http://yoursite.com/2019/07/07/BZOJ3653-%E8%B0%88%E7%AC%91%E9%A3%8E%E7%94%9F/"/>
    <id>http://yoursite.com/2019/07/07/BZOJ3653-谈笑风生/</id>
    <published>2019-07-07T07:55:11.000Z</published>
    <updated>2019-07-07T08:04:49.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3653" target="_blank" rel="noopener">BZOJ3653</a>和<a href="https://www.luogu.org/problemnew/show/P3899" target="_blank" rel="noopener">洛谷P3899</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>由题意，b和a一定是祖先关系<br>若b是a的祖先，c在a的子树内，直接乘法累计即可<br>若a是b的祖先，题意转换为以a为根的子树内，与a距离$\leq k$的点的sz之和<br>可以使用主席树或线段树合并<br>主席树：<br>构造欧拉序列，以dfn为时间轴建立以dep为下标的权值线段树<br>一个节点的子树在欧拉序列上是一个区间，查分询问即可<br>线段树合并：<br>每个点建一颗以dep为下表的权值线段树，父节点由子节点得来，考虑空间会炸，所以父节点由子节点线段树合并来<br>代码为主席树，注意long long<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300010</span>, maxm = <span class="number">600010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxm], Next[maxm], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, sz[maxn], d[maxn], dfn[maxn], num;</span><br><span class="line"><span class="keyword">int</span> rt[maxn * <span class="number">4</span>], cnt, lc[maxn * <span class="number">40</span>], rc[maxn * <span class="number">40</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxn * <span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> las, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = ++cnt;</span><br><span class="line">    sum[p] = sum[las] + x;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> p;</span><br><span class="line">    lc[p] = lc[las]; rc[p] = rc[las]; </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) lc[p] = update(lc[las], l, mid, pos, x);</span><br><span class="line">    <span class="keyword">else</span> rc[p] = update(rc[las], mid + <span class="number">1</span>, r, pos, x);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    d[x] = d[fa] + <span class="number">1</span>; sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa) dfs(ver[i], x), sz[x] += sz[ver[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[x] = ++num;</span><br><span class="line">    rt[num] = update(rt[num - <span class="number">1</span>], <span class="number">1</span>, n, d[x], sz[x] - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa) build(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rp, <span class="keyword">int</span> lp, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[rp] - sum[lp];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= mid) res += query(lc[rp], lc[lp], l, mid, L, R);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; mid) res += query(rc[rp], rc[lp], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, Q, a, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), add(x, y), add(y, x);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>); build(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;k);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = min(d[a] - <span class="number">1</span>, k) * ((<span class="keyword">long</span> <span class="keyword">long</span>)sz[a] - <span class="number">1</span>);</span><br><span class="line">        ans += query(rt[dfn[a] + sz[a] - <span class="number">1</span>], rt[dfn[a] - <span class="number">1</span>], <span class="number">1</span>, n, d[a] + <span class="number">1</span>, d[a] + k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ3653&lt;/a&gt;和&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3899&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P3899&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;由题意，b和a一定是祖先关系&lt;br&gt;若b是a的祖先，c在a的子树内，直接乘法累计即可&lt;br&gt;若a是b的祖先，题意转换为以a为根的子树内，与a距离$\leq k$的点的sz之和&lt;br&gt;可以使用主席树或线段树合并&lt;br&gt;主席树：&lt;br&gt;构造欧拉序列，以dfn为时间轴建立以dep为下标的权值线段树&lt;br&gt;一个节点的子树在欧拉序列上是一个区间，查分询问即可&lt;br&gt;线段树合并：&lt;br&gt;每个点建一颗以dep为下表的权值线段树，父节点由子节点得来，考虑空间会炸，所以父节点由子节点线段树合并来&lt;br&gt;代码为主席树，注意long long&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>2019扬中Day2</title>
    <link href="http://yoursite.com/2019/07/05/2019%E6%89%AC%E4%B8%ADDay2/"/>
    <id>http://yoursite.com/2019/07/05/2019扬中Day2/</id>
    <published>2019-07-05T14:25:32.000Z</published>
    <updated>2019-07-06T04:32:24.259Z</updated>
    
    <content type="html"><![CDATA[<p>这场比赛前两题我用自己的非正解算法水到了188分<br>真是好水的数据<br>题目出的很模拟赛<br><a id="more"></a><br>题目在这里<br><div class="row">    <embed src="problems.pdf" width="100%" height="550" type="application/pdf"></div></p><h1><span id="纸牌游戏cards">纸牌游戏（cards）</span></h1><p>我的算法就很奇怪了，$f[i][j]$只任选i个，gcd为j的方案数，然后第一问转化成组合数问题一通推式子得到$$ ans=\sum_{i=1}^{n/2}\frac{f[2<em>i][1]}{C_{n}^{i}}-\frac{f[2</em>i-1][1]}{C_{n}^{i-1}} $$<br>然后第二问不好做</p><p>其实正解很巧妙，难点就在于如何记录状态，要记录gcd，还要记录那些选了，但又不能状压<br>注意到如果当前gcd为x，那么之前选的所有数都是x的倍数，而所有x的倍数在此时应给是地位相等的，都再也不会更新gcd。这样就方便记录哪些数已经选过了<br>用$ f[i][j] $表示选了i个，gcd为j的概率，注意此时选的i个都是x的倍数，那么有<br>$$<br>f[i+1][j] += f[i][j]\times \frac{sum[j]-i}{n} \\<br>f[i+1][gcd(a[k], j)] += f[i][j]\times \frac{1}{n}<br>$$<br>其中$sum[j]$表示j的倍数的个数<br>转移方程很巧妙啊，本应枚举所有未选的数，但这不现实，因此枚举所有一定不可能被选过的数，剩下哪些不确定的只要知道个数就可以了</p><p>如果第一问的状态方程这样写，那么第二问用类似的方法配合SG函数方法就可以了，具体参见标程，用记忆化搜索，把乘法换成必胜必败的判定即可</p><p>my第一问<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">310</span>, maxm = <span class="number">1010</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmin</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = min(a, b); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmax</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = max(a, b); &#125;</span><br><span class="line"><span class="keyword">int</span> a[maxn], mx, n;</span><br><span class="line"><span class="keyword">double</span> f[maxn][maxm], c[maxn][maxn], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!a) <span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">return</span> gcd(b % a, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"cards.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"cards.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read(), mx = max(mx, a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) c[i][<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) c[i][j] = c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; c[n][i] &lt;&lt; ' '; cout &lt;&lt; endl;</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0</span>; f[<span class="number">1</span>][a[<span class="number">1</span>]] = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= mx; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[j][k]) </span><br><span class="line">f[j + <span class="number">1</span>][gcd(k, a[i + <span class="number">1</span>])] += f[j][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i = 0; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">//for(int j = 0; j &lt;= mx; j++) cout &lt;&lt; f[i][j] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) ans += f[i][<span class="number">1</span>] / c[n][i] - f[i<span class="number">-1</span>][<span class="number">1</span>] / c[n][i<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf\n"</span>, ans);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>std满分做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> mx,a[N],g[N][N],sum[N],visit[N][N],zy[N][N],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a==<span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">int</span> y=a%b;</span><br><span class="line"><span class="keyword">while</span> (y)</span><br><span class="line">&#123;</span><br><span class="line">a=b; b=y; y=a%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visit[i][j]) <span class="keyword">return</span> g[i][j];</span><br><span class="line">visit[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (j==<span class="number">1</span>) <span class="keyword">return</span> g[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i&gt;n) <span class="keyword">return</span> g[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i&lt;=sum[j] &amp;&amp; calc(i+<span class="number">1</span>,j)==<span class="number">0</span>) <span class="keyword">return</span> g[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">if</span> ((j==<span class="number">0</span> || a[k]%j) &amp;&amp; calc(i+<span class="number">1</span>,zy[j][k])==<span class="number">0</span>) <span class="keyword">return</span> g[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> g[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"cards.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"cards.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">cur=gcd(cur,a[i]);</span><br><span class="line">mx=max(mx,a[i]);</span><br><span class="line">f[<span class="number">1</span>][a[i]]+=(<span class="keyword">double</span>)<span class="number">1</span>/n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=mx;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span> (a[j]%i==<span class="number">0</span>) sum[i]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mx;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">zy[i][j]=gcd(i,a[j]);</span><br><span class="line"><span class="keyword">if</span> (cur!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>,<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=mx;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(f[i][j])&lt;=eps || i&gt;sum[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">if</span> (a[k]%j)</span><br><span class="line">f[i+<span class="number">1</span>][zy[j][k]]+=f[i][j]*<span class="number">1</span>/(n-i);</span><br><span class="line">f[i+<span class="number">1</span>][j]+=f[i][j]*(sum[j]-i)/(n-i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i+=<span class="number">2</span>) ans+=f[i][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.10lf "</span>,ans);</span><br><span class="line">calc(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (g[<span class="number">1</span>][<span class="number">0</span>]) <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>,<span class="number">1.0</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>,<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="秀秀的森林forest">秀秀的森林（forest）</span></h1><p>本题我的做法按道理说是会被卡掉的<br>但看起来数据很随机，因此跑得飞起，直接AC<br>先讲我的做法<br>考虑dp求直径的做法，<br>砍掉一条边后下面的子树的dp值都不会改变，只要更新砍掉的边到根的节点的dp值就可以<br>因为这样dp值减小，不方便更新，所以时间倒流把砍边改成加边，先dfs预处理每个点的父亲和dp值，加边时暴力向上跳更新<br>复杂度最坏应该会高达$O(n^2)$，然而数据太水</p><p>下面是正解<br>仍然时间倒流，加上一条边后新树的直径只可能是以之前两棵树的直径端点为端点<br>这样就好做了<br>连边时4个端点两两组合用LCA求路径最大值，维护答案就可以了</p><p>之前好像见过这题。。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">'-'</span> &amp;&amp; (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)) c = getchar(); <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>, c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>, c = getchar(); <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmin</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = min(a, b); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmax</span><span class="params">(T &amp;a, T b)</span> </span>&#123; <span class="keyword">return</span> a = max(a, b); &#125;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxn * <span class="number">2</span>], Next[maxn * <span class="number">2</span>], tot, ena[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> X[maxn], Y[maxn], n, a[maxn], fa[maxn], d[maxn], rt[maxn], q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rt[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> rt[x] = get(rt[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[maxn], res = <span class="number">1</span>, lans[maxn], f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">ans[x] = f[x] = a[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != fa[x] &amp;&amp; ena[ver[i]]) &#123;</span><br><span class="line">ans[x] = max(ans[x], ans[ver[i]]);</span><br><span class="line">ans[x] = max(ans[x], f[x] + f[ver[i]]);</span><br><span class="line">f[x] = max(f[x], f[ver[i]] + a[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pa)</span> </span>&#123;</span><br><span class="line">fa[x] = pa; d[x] = d[pa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) <span class="keyword">if</span>(ver[i] != pa) dfs(ver[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Power</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lres = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) lres = lres * x % mod;</span><br><span class="line"><span class="keyword">return</span> lres;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"forest.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"forest.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) X[i] = read(), Y[i] = read(), add(X[i], Y[i]), add(Y[i], X[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rt[i] = i, f[i] = a[i], ans[i] = a[i], res = res * ans[i] % mod;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">lans[n] = res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> Q = <span class="number">1</span>; Q &lt; n; Q++) &#123;</span><br><span class="line">q[Q] = read();</span><br><span class="line"><span class="keyword">if</span>(d[X[q[Q]]] &gt; d[Y[q[Q]]]) swap(X[q[Q]], Y[q[Q]]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> rx = get(X[q[i]]), ry = get(Y[q[i]]);</span><br><span class="line">ena[ry] = <span class="number">1</span>;</span><br><span class="line">res = res * Power(ans[rx], mod - <span class="number">2</span>) % mod * Power(ans[ry], mod - <span class="number">2</span>) % mod;</span><br><span class="line">rt[ry] = rx;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = ry; j != rx; j = fa[j]) update(fa[j]);</span><br><span class="line">res = res * ans[rx] % mod;</span><br><span class="line">lans[i] = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, lans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="秀秀的照片photo">秀秀的照片（photo）</span></h1><blockquote><p>“组合数问题都是好题”</p></blockquote><p>组合数推出公式就可以了<br>显然的性质是<br>最左边和最右边一列不同颜色个数应当相同<br>中间m-2列的颜色是最两边两列颜色集合的交集的子集<br>枚举中间部分颜色个数，在枚举两端的独特的颜色个数，用C求出选颜色的方案，还要乘以用恰好那么多颜色涂那么多格子的方案数，这个用第二类stirling数求，$S[i][j]$表示i个球放到j个盒子中，每个盒子都有球的方案数，这里球对应格子，盒子对应颜色，有<br>$$S[i][j]=S[i-1][j-1]+S[i-1][j]\times j$$<br>由于考虑排列，所以乘以阶乘，最后的结果为<br>$$<br>\sum_{i=0}^{min(n, k)}C_k^i \times i^{n\times(m-2)}\sum_{j=0}^{min(n-i, (k-i)/2)}C_{k-i}^j \times C_{k-i-j}^j\times S_{n}^{i+j}\times (i+j)!<br>$$<br>按照组合数学常见套路，能预处理的都预处理<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>, maxn = <span class="number">4000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll fac[maxn + <span class="number">10</span>], infac[maxn + <span class="number">10</span>], ans, S[<span class="number">4010</span>][<span class="number">4010</span>];</span><br><span class="line"><span class="function">ll <span class="title">Power</span><span class="params">(ll x, ll p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p; p &gt;&gt;= <span class="number">1</span>, x = x * x % mod) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fac[x] * infac[y] % mod * infac[x - y] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"photo.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"photo.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">infac[<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++) fac[i] = fac[i<span class="number">-1</span>] * i % mod;</span><br><span class="line">infac[maxn] = Power(fac[maxn], mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = maxn - <span class="number">1</span>; i; i--) infac[i] = infac[i+<span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++) </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) </span><br><span class="line">S[i][j] = (S[i<span class="number">-1</span>][j<span class="number">-1</span>] + S[i<span class="number">-1</span>][j] * j % mod) % mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= min(n, k); i++) &#123;</span><br><span class="line">ll tmp = C(k, i) * Power(i, n *(m - <span class="number">2</span>)) % mod;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j + i + j &lt;= k, i + j &lt;= n; j++) &#123;</span><br><span class="line">ll tt = C(k - i, j) * C(k - i - j, j) % mod;</span><br><span class="line">ll t2 = S[n][i + j] * fac[i + j] % mod; t2 = t2 * t2 % mod;</span><br><span class="line">sum = (sum + tt * t2 % mod) % mod;</span><br><span class="line">&#125; </span><br><span class="line">ans = (ans + tmp * sum % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这场比赛前两题我用自己的非正解算法水到了188分&lt;br&gt;真是好水的数据&lt;br&gt;题目出的很模拟赛&lt;br&gt;
    
    </summary>
    
      <category term="集训" scheme="http://yoursite.com/categories/%E9%9B%86%E8%AE%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ1997 [Hnoi2010]Planar</title>
    <link href="http://yoursite.com/2019/07/05/BZOJ1997-Hnoi2010-Planar/"/>
    <id>http://yoursite.com/2019/07/05/BZOJ1997-Hnoi2010-Planar/</id>
    <published>2019-07-05T10:18:09.000Z</published>
    <updated>2019-07-05T10:29:28.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1997" target="_blank" rel="noopener">BZOJ1997</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>题意判断是否是平面图<br>首先平面图边数$\leq3n-6$，这样边数是$O(n)$的了<br>题目中给了一条曼哈顿回路，也就是说要做的是把剩下的边加入这个环里，加入的边要么在里面，要么在外面，两两不想交<br>这就是一个2-sat问题了<br>每条边拆成两个点，有一些要加入的边无法同时在里或同时在外，这时把他们连一些边，然后跑tarjan，存在一条边对应的两个点在同一强联通分量则不行</p><p>然而这题我做了整整半天的时间<br>最开始用dfs，一直觉得dfs和tarjan没什么区别，dfs还好写<br>但20分过不了<br>迫不得已改写tarjan，结果依旧20分<br>最后发现判定边数过多直接continue太早了，还没读完剩下的数据呢。。。<br>洛谷终于过了，但BZOJ总是TLE<br>最后原来是我因为最开始RE所以数组开的特别大，卡MLE的那种，结果多组数据清数组时花了大量的时间。。。<br>所以事实上数组不是开的越大越好，即使不会MLE也不行<br><a id="more"></a></p><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5060</span>, maxm = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxm], Next[maxm], tot, m, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> e[<span class="number">210</span>][<span class="number">210</span>], a[maxn], X[maxn], Y[maxn], cnt, pos[maxn];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], sta[maxn], top, bel[maxn], ins[maxn], num, scc;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">add(x, y + cnt); add(x + cnt, y);</span><br><span class="line">add(y, x + cnt); add(y + cnt, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line"><span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line"><span class="built_in">memset</span>(ins, <span class="number">0</span>, <span class="keyword">sizeof</span>(ins));</span><br><span class="line">tot = cnt = num = scc = top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">ins[x] = <span class="number">1</span>; sta[++top] = x;</span><br><span class="line">dfn[x] = low[x] = ++num;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(!dfn[ver[i]]) tarjan(ver[i]), low[x] = min(low[x], low[ver[i]]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ins[ver[i]] == <span class="number">1</span>) low[x] = min(low[x], dfn[ver[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x] == low[x]) &#123;</span><br><span class="line">scc++;</span><br><span class="line"><span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(z != x) </span><br><span class="line">z = sta[top--], ins[z] = <span class="number">2</span>, bel[z] = scc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">jud</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt * <span class="number">2</span>; i++) <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) </span><br><span class="line"><span class="keyword">if</span>(bel[i] == bel[i + cnt]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line">clear();</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), e[x][y] = e[y][x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), pos[a[i]] = i;</span><br><span class="line"><span class="keyword">if</span>(m &gt; <span class="number">3</span> * n - <span class="number">6</span>) &#123; <span class="built_in">printf</span>(<span class="string">"NO\n"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) e[a[i]][a[i+<span class="number">1</span>]] = e[a[i+<span class="number">1</span>]][a[i]] = <span class="number">0</span>;</span><br><span class="line">e[a[n]][a[<span class="number">1</span>]] = e[a[<span class="number">1</span>]][a[n]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) <span class="keyword">if</span>(e[i][j]) &#123;</span><br><span class="line">X[++cnt] = pos[i], Y[cnt] = pos[j];</span><br><span class="line"><span class="keyword">if</span>(X[cnt] &gt; Y[cnt]) swap(X[cnt], Y[cnt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(X[i] &lt; X[j] &amp;&amp; X[j] &lt; Y[i] &amp;&amp; Y[i] &lt; Y[j]) proc(i, j);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X[j] &lt; X[i] &amp;&amp; X[i] &lt; Y[j] &amp;&amp; Y[j] &lt; Y[i]) proc(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(jud()) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1997&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ1997&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;题意判断是否是平面图&lt;br&gt;首先平面图边数$\leq3n-6$，这样边数是$O(n)$的了&lt;br&gt;题目中给了一条曼哈顿回路，也就是说要做的是把剩下的边加入这个环里，加入的边要么在里面，要么在外面，两两不想交&lt;br&gt;这就是一个2-sat问题了&lt;br&gt;每条边拆成两个点，有一些要加入的边无法同时在里或同时在外，这时把他们连一些边，然后跑tarjan，存在一条边对应的两个点在同一强联通分量则不行&lt;/p&gt;
&lt;p&gt;然而这题我做了整整半天的时间&lt;br&gt;最开始用dfs，一直觉得dfs和tarjan没什么区别，dfs还好写&lt;br&gt;但20分过不了&lt;br&gt;迫不得已改写tarjan，结果依旧20分&lt;br&gt;最后发现判定边数过多直接continue太早了，还没读完剩下的数据呢。。。&lt;br&gt;洛谷终于过了，但BZOJ总是TLE&lt;br&gt;最后原来是我因为最开始RE所以数组开的特别大，卡MLE的那种，结果多组数据清数组时花了大量的时间。。。&lt;br&gt;所以事实上数组不是开的越大越好，即使不会MLE也不行&lt;br&gt;
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="2-sat" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/2-sat/"/>
    
    
  </entry>
  
  <entry>
    <title>BZOJ4945 [Noi2017]游戏</title>
    <link href="http://yoursite.com/2019/07/04/BZOJ4945-Noi2017-%E6%B8%B8%E6%88%8F/"/>
    <id>http://yoursite.com/2019/07/04/BZOJ4945-Noi2017-游戏/</id>
    <published>2019-07-04T10:18:39.000Z</published>
    <updated>2019-07-06T14:52:52.721Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4945" target="_blank" rel="noopener">BZOJ4945</a></p></blockquote><h1><span id="solution">Solution</span></h1><p>本题标记着2-sat达到一个高潮<br>如果没有x，那就是一个裸的2-sat<br>然而x的个数很小，可以暴力枚举，所以实际上还是裸的2-sat<br>每个x枚举<br>1.不能选A，那么就是B、C二选一<br>2.不能选B，那么就是A、C二选一<br>这样就已经包含了ABC三种情况，所以暴力枚举的复杂度为$2^d$</p><p>下面说一说裸的2-sat怎么做<br>用tarjan算法求出所有的强连通分量<br>如果某个对偶的两点位于同一分量，则无解<br>否则有解，那么问题就是如何输出任意一解<br>对于缩点后的反图，按拓扑序，选当前节点，把她得姐妹节点删除<br>事实上不用拓扑排序，节点scc编号的大小就是反图拓扑序的大小，因此姐妹点选scc小的即可</p><p>tarjan比dfs快，我终于明白了，dfs是$O(nm)$的</p><p>这里还有一些要注意的地方，如果一个限制中提到了一定不会出现赛车，设此限制为$(x\to y)$，若x不可能选，则直接continue，若y不可能选，则x连向他的姐妹节点，巧妙地表达了x不可能选</p><a id="more"></a><h1><span id="code">Code</span></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">150010</span>, maxm = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ver[maxm], Next[maxm], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> str[maxn], qx[maxm], qy[maxm], car[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;, &#123;<span class="string">'A'</span>, <span class="string">'C'</span>&#125;, &#123;<span class="string">'A'</span>, <span class="string">'B'</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n, d, m, xpos[<span class="number">10</span>], xcnt, X[maxm], Y[maxm];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], num, scc, ins[maxn], sta[maxn], top, bel[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> rnk[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ins[x] = <span class="number">1</span>; sta[++top] = x;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = Next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ver[i]]) tarjan(ver[i]), low[x] = min(low[x], low[ver[i]]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[ver[i]] == <span class="number">1</span>) low[x] = min(low[x], dfn[ver[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x] == low[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = <span class="number">0</span>; scc++;</span><br><span class="line">        <span class="keyword">while</span>(z != x) &#123;</span><br><span class="line">            z = sta[top--]; ins[z] = <span class="number">2</span>; bel[z] = scc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; str + 1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(ins, <span class="number">0</span>, <span class="keyword">sizeof</span>(ins));</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">    num = scc = top = tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[X[i]] - <span class="string">'a'</span> == qx[i] - <span class="string">'A'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> x = rnk[str[X[i]] - <span class="string">'a'</span>][qx[i] - <span class="string">'A'</span>];</span><br><span class="line">        <span class="keyword">int</span> y = rnk[str[Y[i]] - <span class="string">'a'</span>][qy[i] - <span class="string">'A'</span>];</span><br><span class="line">        <span class="keyword">if</span>(str[Y[i]] - <span class="string">'a'</span> == qy[i] - <span class="string">'A'</span>) &#123; add(X[i] + x * n, X[i] + n * (<span class="number">1</span> - x)); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        add(x * n + X[i], y * n + Y[i]);</span><br><span class="line">        add((<span class="number">1</span> - y) * n + Y[i], (<span class="number">1</span> - x) * n + X[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(bel[i] == bel[i + n]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">if</span>(bel[i] &lt; bel[i + n]) <span class="built_in">printf</span>(<span class="string">"%c"</span>, car[str[i] - <span class="string">'a'</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>, car[str[i] - <span class="string">'a'</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; xcnt) <span class="keyword">return</span> solve();</span><br><span class="line">    str[xpos[x]] = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span>(dfs(x + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    str[xpos[x]] = <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">if</span>(dfs(x + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("input", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("user_out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, str + <span class="number">1</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(str[i] == <span class="string">'x'</span>) xpos[++xcnt] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d %c%d %c"</span>, &amp;X[i], &amp;qx[i], &amp;Y[i], &amp;qy[i]);</span><br><span class="line">    <span class="keyword">if</span>(!dfs(<span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=4945&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BZOJ4945&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h1&gt;&lt;p&gt;本题标记着2-sat达到一个高潮&lt;br&gt;如果没有x，那就是一个裸的2-sat&lt;br&gt;然而x的个数很小，可以暴力枚举，所以实际上还是裸的2-sat&lt;br&gt;每个x枚举&lt;br&gt;1.不能选A，那么就是B、C二选一&lt;br&gt;2.不能选B，那么就是A、C二选一&lt;br&gt;这样就已经包含了ABC三种情况，所以暴力枚举的复杂度为$2^d$&lt;/p&gt;
&lt;p&gt;下面说一说裸的2-sat怎么做&lt;br&gt;用tarjan算法求出所有的强连通分量&lt;br&gt;如果某个对偶的两点位于同一分量，则无解&lt;br&gt;否则有解，那么问题就是如何输出任意一解&lt;br&gt;对于缩点后的反图，按拓扑序，选当前节点，把她得姐妹节点删除&lt;br&gt;事实上不用拓扑排序，节点scc编号的大小就是反图拓扑序的大小，因此姐妹点选scc小的即可&lt;/p&gt;
&lt;p&gt;tarjan比dfs快，我终于明白了，dfs是$O(nm)$的&lt;/p&gt;
&lt;p&gt;这里还有一些要注意的地方，如果一个限制中提到了一定不会出现赛车，设此限制为$(x\to y)$，若x不可能选，则直接continue，若y不可能选，则x连向他的姐妹节点，巧妙地表达了x不可能选&lt;/p&gt;
    
    </summary>
    
      <category term="图论" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="2-sat" scheme="http://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/2-sat/"/>
    
    
  </entry>
  
</feed>
